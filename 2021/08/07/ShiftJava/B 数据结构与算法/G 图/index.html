<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] 图基础1. 概述图是一种数据结构，其中结点可以具有零个或多个相邻元素。需要表示多对多的关系时就需要用图。 一系列点以及把它们连起来的边就构成了一幅图，图是现实生活中许多东西的抽象比如地图或者电路图，在数学中也有图论这一分支专门研究图的性质。 2. 基本术语 顶点（V）：结点也可以称为顶点。  边（E）：两个结点之间的连接称为边。  度数：某一个顶点的度数即为依附于它的边的总数。  路径">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;B 数据结构与算法&#x2F;G 图">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] 图基础1. 概述图是一种数据结构，其中结点可以具有零个或多个相邻元素。需要表示多对多的关系时就需要用图。 一系列点以及把它们连起来的边就构成了一幅图，图是现实生活中许多东西的抽象比如地图或者电路图，在数学中也有图论这一分支专门研究图的性质。 2. 基本术语 顶点（V）：结点也可以称为顶点。  边（E）：两个结点之间的连接称为边。  度数：某一个顶点的度数即为依附于它的边的总数。  路径">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577423800423.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577424719876.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1569759979392.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1569759958984.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577423708265.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577424128799.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577425111837.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577425314717.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577427388269.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;image-20200521155254582.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577428969930.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577429935449.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577430096084.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577430067875.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;image-20200521160929680.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577431690959.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577431843894.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577432773034.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577433213643.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577434100377.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577434860390.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577438382052.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577437155880.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577444989131.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;G%20%E5%9B%BE&#x2F;assets&#x2F;1577423800423.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/B 数据结构与算法/G 图/"/>





  <title>ShiftJava/B 数据结构与算法/G 图 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/G%20%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/B 数据结构与算法/G 图</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>图是一种数据结构，其中结点可以具有零个或多个相邻元素。需要表示多对多的关系时就需要用图。</p>
<p>一系列点以及把它们连起来的边就构成了一幅图，图是现实生活中许多东西的抽象比如地图或者电路图，在数学中也有图论这一分支专门研究图的性质。</p>
<h5 id="2-基本术语"><a href="#2-基本术语" class="headerlink" title="2. 基本术语"></a>2. 基本术语</h5><ul>
<li><p><strong>顶点（V）</strong>：结点也可以称为<strong>顶点</strong>。</p>
</li>
<li><p><strong>边（E）</strong>：两个结点之间的连接称为<strong>边</strong>。</p>
</li>
<li><p><strong>度数</strong>：某一个顶点的度数即为依附于它的<strong>边的总数</strong>。</p>
</li>
<li><p><strong>路径</strong>：由边顺序连接起来的一系列顶点。</p>
</li>
<li><p><strong>环</strong>：该路径上的任意一个顶点都可以沿着这条路径回到原来的顶点。</p>
</li>
<li><p><strong>连通图</strong>：如果从任意一个顶点都存在一条路径到达另一个任意定点，那么这幅图是连通图。</p>
</li>
</ul>
<p>特殊的情况自环和平行边如下图所示。<br><img src="assets/1577423800423.png" alt="1577423800423" style="zoom:60%;" /></p>
<p>树是一幅<strong>无环连通图</strong>。互不相连的树组成的集合成为<strong>森林</strong>。</p>
<img src="assets/1577424719876.png" alt="1577424719876" style="zoom:50%;" />

<h5 id="3-图的表示"><a href="#3-图的表示" class="headerlink" title="3. 图的表示"></a>3. 图的表示</h5><p>图的表示方式主要有两种：二维数组表示（邻接矩阵）、链表表示（邻接表）。</p>
<h6 id="1-邻接矩阵"><a href="#1-邻接矩阵" class="headerlink" title="(1) 邻接矩阵"></a>(1) 邻接矩阵</h6><p><strong>邻接矩阵</strong>是表示图形中<strong>顶点之间相邻关系</strong>的矩阵，对于 N 个顶点的图而言，矩阵是的 row 和 col 表示的是 1….n 个点。</p>
<img src="assets/1569759979392.png" alt="1569759979392" style="zoom:60%;" />

<p>邻接矩阵需要为<strong>每个顶点都分配 N 个边的空间</strong>，其实有很多边都是不存在,会造成空间的一定<strong>损失</strong>。对于<strong>稀疏图</strong>会造成较大的空间浪费。对于<strong>稠密图</strong>则非常适合。</p>
<h6 id="2-邻接表"><a href="#2-邻接表" class="headerlink" title="(2) 邻接表"></a>(2) 邻接表</h6><p><strong>邻接表</strong>的实现只关心<strong>存在的边</strong>，不关心不存在的边。因此没有空间浪费，适合<strong>稀疏图</strong>。邻接表由==<strong>数组 + 链表</strong>==组成。</p>
<img src="assets/1569759958984.png" alt="1569759958984" style="zoom:57%;" />

<p>标号为 0 的结点的相关联的结点为 1 2 3 4。<br>标号为 1 的结点的相关联结点为 0 4。<br>标号为 2 的结点相关联的结点为 0 4 5。</p>
<h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><p><strong>无向图</strong>就是<strong>图中的边是没有方向</strong>的。</p>
<img src="assets/1577423708265.png" alt="1577423708265" style="zoom: 50%;" />

<h5 id="2-无向图的表示"><a href="#2-无向图的表示" class="headerlink" title="2. 无向图的表示"></a>2. 无向图的表示</h5><p>以下图为例。</p>
<img src="assets/1577424128799.png" alt="1577424128799" style="zoom:57%;" />

<p>显然，这个无向图有 13 个点。</p>
<ul>
<li><p>0 可以通往 1, 2, 5, 6；</p>
</li>
<li><p>6 可以通往 0, 4 ; </p>
</li>
<li><p>5 可以通往0, 3, 4。</p>
</li>
</ul>
<p>即 0 的邻居点有 1, 2, 5 ,6；而 6 的邻居点有 0, 4。</p>
<p>目前有两种主流的表示方法：<strong>邻接矩阵（Adjacency-matrix）和邻接列表（Adjacency-list）。</strong></p>
<h6 id="1-邻接矩阵-1"><a href="#1-邻接矩阵-1" class="headerlink" title="(1) 邻接矩阵"></a>(1) 邻接矩阵</h6><p>如果两个点<strong>相邻</strong>，则<strong>用 1 表示，否则用 0</strong>。例如 1 是 0 的邻居点，所以 0 和 1 相交对应的格子为 1。</p>
<p>从这个图可以看出，如果每个点不是与大量的其它点互为邻居，则会有很多 0 出现。如果点的数量庞大，矩阵将十分巨大，且有很多空间浪费（0 占据的格子）。邻接矩阵在<strong>稠密图</strong>中较为适合。</p>
<img src="assets/1577425111837.png" alt="1577425111837" style="zoom:57%;" />

<h6 id="2-邻接表数组"><a href="#2-邻接表数组" class="headerlink" title="(2) 邻接表数组"></a>(2) 邻接表数组</h6><p>就是用一个<strong>数组</strong>把所有点装起来，每个位置是由<strong>对应点的所有邻居点形成的数组</strong>。使用邻接表可以只保留<strong>有效信息</strong>，从而大大减少空间的需求。</p>
<p>如 <strong>adj[0] = 6, 2, 1, 5</strong> (0 可以通往 1, 2, 5, 6);</p>
<p><strong>adj[6] = 0, 4</strong>（6 可以通往 0, 4）。</p>
<p>这个列表比较适合每个点只与少量其它点相邻的情况。即适用于<strong>稀疏图</strong>的情况。</p>
<img src="assets/1577425314717.png" alt="1577425314717" style="zoom:60%;" />

<p>在上述的数据结构中<strong>每条边会出现两次</strong>。性能特点如下：</p>
<ol>
<li><p>使用的空间和 <strong>V + E</strong> 成正比。</p>
</li>
<li><p><strong>添加一条边</strong>所需的时间为<strong>常数</strong>。</p>
</li>
<li><p>遍历顶点 V 所有的相邻顶点所需的时间和 V 的<strong>度数</strong>成正比。</p>
</li>
</ol>
<p>可以根据实际情况进行选择用<strong>列表还是矩阵。</strong></p>
<p>通过创建一个矩阵或者列表，程序可以知道这个无向图有哪些点和点与点之间的联系。</p>
<h5 id="3-基础结构代码实现"><a href="#3-基础结构代码实现" class="headerlink" title="3. 基础结构代码实现"></a>3. 基础结构代码实现</h5><p>这里使用<strong>邻接矩阵</strong>的方式。</p>
<p><strong>图类</strong>如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放结点的HashMap</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">    <span class="comment">// 存放边的Set</span></span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结点类</strong>如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结点值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">// 入度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> in;</span><br><span class="line">    <span class="comment">// 出度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> out;</span><br><span class="line">    <span class="comment">// 邻接结点的List表</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts;</span><br><span class="line">    <span class="comment">// 边的list</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">        nexts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>边类</strong>如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 权重</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="comment">// From结点</span></span><br><span class="line">	<span class="keyword">public</span> Node from;</span><br><span class="line">    <span class="comment">// To结点</span></span><br><span class="line">	<span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> weight, Node from, Node to)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.weight = weight;</span><br><span class="line">		<span class="keyword">this</span>.from = from;</span><br><span class="line">		<span class="keyword">this</span>.to = to;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于常见的给定的图结构，都是可以转化为上述的结构。比如传入一个<strong>邻接矩阵</strong>转为上述给定的图结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// matrix 所有的边</span></span><br><span class="line"><span class="comment">// N*3 的矩阵</span></span><br><span class="line"><span class="comment">// [weight, from节点上面的值，to节点上面的值]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title">createGraph</span><span class="params">(Integer[][] matrix)</span> </span>&#123;</span><br><span class="line">    Graph graph = <span class="keyword">new</span> Graph();</span><br><span class="line">    <span class="comment">// matrix[0][0], matrix[0][1]  matrix[0][2] 一次读取矩阵一行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123; </span><br><span class="line">        <span class="comment">// 构造数据</span></span><br><span class="line">        Integer from = matrix[i][<span class="number">0</span>];</span><br><span class="line">        Integer to = matrix[i][<span class="number">1</span>];</span><br><span class="line">        Integer weight = matrix[i][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 如果from是新节点则创建并放入图中</span></span><br><span class="line">        <span class="keyword">if</span> (!graph.nodes.containsKey(from)) &#123;</span><br><span class="line">            graph.nodes.put(from, <span class="keyword">new</span> Node(from));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果to是新节点则创建并放入图中</span></span><br><span class="line">        <span class="keyword">if</span> (!graph.nodes.containsKey(to)) &#123;</span><br><span class="line">            graph.nodes.put(to, <span class="keyword">new</span> Node(to));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造边</span></span><br><span class="line">        Node fromNode = graph.nodes.get(from);</span><br><span class="line">        Node toNode = graph.nodes.get(to);</span><br><span class="line">        Edge newEdge = <span class="keyword">new</span> Edge(weight, fromNode, toNode);</span><br><span class="line">        <span class="comment">// 添加next节点</span></span><br><span class="line">        fromNode.nexts.add(toNode);</span><br><span class="line">        <span class="comment">// 设置入度和出度</span></span><br><span class="line">        fromNode.out++;</span><br><span class="line">        toNode.in++;</span><br><span class="line">        fromNode.edges.add(newEdge);</span><br><span class="line">        graph.edges.add(newEdge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>图经常也需要遍历所有数据</strong>，并且它最好能够反映节点之间的相关信息，所以就有了两个很重要的搜索方法，<strong>深度优先和广度优先搜索</strong>，下面先介绍深度优先搜索。</p>
<h5 id="4-深度优先搜索（DFS）"><a href="#4-深度优先搜索（DFS）" class="headerlink" title="4. 深度优先搜索（DFS）"></a>4. 深度优先搜索（DFS）</h5><p><strong>深度优先搜索</strong>(DepthFirstSearch) 的主要特征就是，假设一个顶点有不少相邻顶点，当搜索到该顶点，对于它的相邻顶点并不是现在就对所有都进行搜索，而是对一个顶点继续往后搜索，<strong>直到某个顶点</strong>，他周围的相邻顶点<strong>都已经被访问过</strong>了，这时他就可以<strong>返回</strong>，对它来的那个顶点的其余顶点进行搜索。</p>
<p>简单来说就是，在访问一个顶点时：</p>
<ul>
<li>将它<strong>标记为已访问</strong>。</li>
<li>递归地访问它的所有<strong>没有被标记过</strong>的邻居顶点。</li>
</ul>
<p>一路走到尽头，然后返回上一个分支，走另一条路到尽头，再返回，再走其他路，直到全部走完为止。</p>
<p><strong>深度优先搜索</strong>的实现可以利用<strong>递归</strong>很简单地实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base case</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 使用一个栈用于遍历</span></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用一个Set保存已经访问过的结点</span></span><br><span class="line">    HashSet&lt;Node&gt; visitedSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 将头结点如栈和Set</span></span><br><span class="line">    stack.add(node);</span><br><span class="line">    visitedSet.add(node);</span><br><span class="line">    <span class="comment">// 打印头结点代表已经访问</span></span><br><span class="line">    System.out.println(node.value);</span><br><span class="line">    <span class="comment">// 栈不为空持续遍历</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 从栈弹出一个结点</span></span><br><span class="line">        Node cur = stack.pop();</span><br><span class="line">        <span class="comment">// 遍历当前弹出结点的nexts链表</span></span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">            <span class="comment">// 如果这个结点没有遍历过则压栈</span></span><br><span class="line">            <span class="keyword">if</span> (!visitedSet.contains(next)) &#123;</span><br><span class="line">                <span class="comment">// 注意把cur结点再次压栈</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                stack.push(next);</span><br><span class="line">                visitedSet.add(next);</span><br><span class="line">                <span class="comment">// 打印当前结点</span></span><br><span class="line">                System.out.println(next.value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用的是一个 Set 保存<strong>被访问的结点</strong>，算法 4 中的代码使用一个 <strong>boolean[] 数组标识某个顶点是否被访问过</strong>，这在以后与图相关的算法中很常见，因为必须直到哪些顶点被访问过了。</p>
<p>过程如下面的图：</p>
<img src="assets/1577427388269.png" alt="1577427388269" style="zoom: 70%;" />

<h5 id="5-广度优先搜索（BFS）"><a href="#5-广度优先搜索（BFS）" class="headerlink" title="5. 广度优先搜索（BFS）"></a>5. 广度优先搜索（BFS）</h5><p>广度优先搜索（BreadthFirstSearch）相对于深度优先搜索侧重点不一样，深度优先好比是一个人走迷宫，一次只能选定一条路走下去，而广度优先搜索好比是<strong>一次能够有任意多个人</strong>，一次就走到和一个顶点相连的所有未访问过的顶点，然后再从这些顶点出发，继续这个过程。</p>
<p>具体实现的时候我们使用<strong>先进先出队列</strong>来实现这个过程：</p>
<ol>
<li>首先将<strong>起点加入队列</strong>，然后<strong>将其出队</strong>，把和起点相连的<strong>顶点加入队列</strong>;</li>
<li>将<strong>队首</strong>元素 V <strong>出队</strong>并标记它；</li>
<li>将和 V 相连的<strong>未标记</strong>的元素加入队列，然后继续执行步骤 2 直到队列<strong>为空</strong>。</li>
</ol>
<p>广度优先搜索的一个重要作用就是它<strong>能够找出最短路径</strong>，这个很好理解，因为广度优先搜索相当于每次从一个起点开始向所有可能的方向走一步，那么第一次到达目的地的这个路径一定是最短的，而到达了之后由于这个点已经被访问过而不会再被访问，这个路径就不会被更改了。</p>
<p>下面是利用广度优先进行路径搜索的代码：即从给定的 <strong>Node</strong> 出发进行 BFS。就类似于二叉树的<strong>层序</strong>遍历，只不过多了一个已访问数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Base case</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 使用队列进行遍历</span></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用Set存储已经遍历的结点</span></span><br><span class="line">    HashSet&lt;Node&gt; visitedSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 加入头结点</span></span><br><span class="line">    queue.add(node);</span><br><span class="line">    visitedSet.add(node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 弹出一个结点</span></span><br><span class="line">        Node cur = queue.poll();</span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        <span class="comment">// 迭代处理各个没有遍历的结点</span></span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">            <span class="comment">// 如果没有遍历过则加入队列中</span></span><br><span class="line">            <span class="keyword">if</span> (!visitedSet.contains(next)) &#123;</span><br><span class="line">                visitedSet.add(next);</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-连通分量"><a href="#6-连通分量" class="headerlink" title="6. 连通分量"></a>6. 连通分量</h5><p>无向图的连通分量（或者仅分量）是一个子图，<strong>其中任何两个顶点通过路径相互连接</strong>，并且在超图中不连接顶点。例如，图中显示的图形有三个连接的组件。没有边缘的顶点本身就是一个连通的组件。自身连接的图形只有一个连接组件，由整个图组成。</p>
<img src="assets/image-20200521155254582.png" alt="image-20200521155254582" style="zoom:37%;" />

<p>在有向图的数学理论中，如果每个顶点都可以从其他顶点到达，则图被称为<strong>强连通或不连通</strong>。任意有向图的强连通分量或连通分量形成一个划分成本身强连接的子图。可以在线性时间内（即Θ（V + E））测试图的强连通性，或者查找其强连通分量。</p>
<p>无向图 G 的极大连通子图称为 G 的连通分量（Connected）。任何连通图的连通分量都只有一个，即使是其本身，非连通的无向图有多个连通分量。</p>
<p>一个图可能是<strong>不连通</strong>的，那么找出图中<strong>有几个连通分量</strong>，找出两个顶点是否位于同一个连通分量都可以用深度优先搜索或者广度优先搜索完成，但是<strong>深度优先搜索 DFS 实现起来更简单</strong>。</p>
<p>先看代码实现（基于<strong>算法 4</strong>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CC</span> <span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; G.V(); s++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[s])&#123;</span><br><span class="line">                dfs(G, s);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        marked[v] =<span class="keyword">true</span>;</span><br><span class="line">        id[v] = count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w : G.adj(v))</span><br><span class="line">            <span class="keyword">if</span>(!marked[w])</span><br><span class="line">                dfs(G, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connected</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中维护了<strong>两个数组</strong>，一个是常见的 <strong>marked[]</strong> 数组，用来表示是否被访问过，另一个是 <strong>id[]</strong> 数组，用来判定每个顶点<strong>属于哪个连通分量</strong>。<br>在构造函数中我们使用了<strong>深度优先搜索函数 dfs</strong>，对于一个顶点来说， <strong>dfs()</strong> 会遍历这个顶点<strong>所在的连通分量所有的顶点</strong>才会返回，接着执行下一语句也就是 count++ 刚好可以给<strong>下一个连通分量</strong>使用，而这些语句外围的 for 循环则可以保证会遍历所有顶点，这样就能找出所有连通分量并将它们<strong>区分</strong>开来。</p>
<ul>
<li>深度优先搜索的预处理时间使用的时间和空间和 V+E 成正比且可以在常数时间内处理关于图的连通性的查询。</li>
</ul>
<p>如下图有<strong>三个</strong>联通分量。其 id 值分别为 0, 1, 2。</p>
<img src="assets/1577428969930.png" alt="1577428969930" style="zoom: 67%;" />

<h5 id="7-检测是否为无环图"><a href="#7-检测是否为无环图" class="headerlink" title="7. 检测是否为无环图"></a>7. 检测是否为无环图</h5><p>检测无环图的代码有点难以理解，首先代码如下（基于算法 4）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasCycle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cycle</span><span class="params">(Graph G)</span></span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s=<span class="number">0</span>;s&lt;G.V();s++)</span><br><span class="line">            <span class="keyword">if</span> (!marked[s])</span><br><span class="line">                dfs(G,s,s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v, <span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w: G.adj(v))&#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[w])</span><br><span class="line">                dfs(G, w, v); <span class="comment">// 可以看出第二个函数表示该顶点的上一个顶点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w != u) hasCycle = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasCycle;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有两个关键，一个是为什么要将深度优先搜索函数 dfs() 设计成有两个参数的，观察 for 语句里面的<strong>递归用法</strong>，就知道了，第二个参数<strong>代表当前顶点的上一个顶点是哪一个</strong>。然而这有什么用？这里需要知道一点<strong>连通无环图就是一颗树</strong>，然后我们以叶节点为例，考虑深度优先搜索进行到这里的情况，假设叶节点为 w ，它的上一个节点为 v，那么我们首先调用了 dfs(G, w, v)，然后是 marked[w] = true; 节点 w 被访问，然后进入 for 循环，这时候 w 的相邻节点只有 v，if 循环被跳过，在 else 语句里面 v==v 那么 hasCycle 就不会被置为 false，所以综上，这样设计成两个参数就是因为在无向图里面两个顶点互相相邻，那么就一定会有子顶点会访问到父顶点的情况，这时候访问到的已经被访问的顶点就是上一个顶点，而如果图<strong>里面有环</strong>那么显而易见，这个被访问过的顶点并不是上一个顶点，这样就能够检测出环了。</p>
<h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><h5 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>简单的来说有向图就是<strong>连接带方向</strong>的图。有向图的例子在现实生活中也很多，比如在一段时间内银行间的现金流动，或者在某些地方的一些道路是单向的啊，那么这些现金流以及单向的道路就要用带方向的边来描述，这时有向图就有了用武之地。一个有向图的例子如下：</p>
<img src="assets/1577429935449.png" alt="1577429935449" style="zoom:47%;" />

<p>有向图该怎么实现呢？对于无向图可以使用邻接表来实现，这种表达方式非常高效，并且略加思考就可以发现，<strong>邻接表完全可以直接套用在有向图上</strong>。假设要添加一条 v-&gt;w 的边，只要每次调用 <strong>add</strong>() 函数的时候只在 adj[v] 所指向的 Bag 添加 w 即可，这么看来无向图可以看作是有向图的特殊情况，即凡是有边相连的两个顶点一定有两个互相来回的边，所以对于无向图，在添加一条边的时候需要在两个顶点都添加一条边。每条边<strong>只会出现一次</strong>。</p>
<img src="assets/1577430096084.png" alt="1577430096084" style="zoom:50%;" />

<p><img src="assets/1577430067875.png" alt="1577430067875"></p>
<p>下面给出有向图的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V; <span class="comment">// number of vertex</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">int</span> E;      <span class="comment">// number of edge</span></span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj;  <span class="comment">//adjacent list</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digraph</span><span class="params">(<span class="keyword">int</span> V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V  = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;V;v++)&#123;</span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digraph</span><span class="params">(In in)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(in.readInt());</span><br><span class="line">        <span class="keyword">int</span> E = in.readInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;E;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> v = in.readInt();</span><br><span class="line">            <span class="keyword">int</span> w = in.readInt();</span><br><span class="line">            addEdge(v,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> V;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> E;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 只需要添加一次边即可</span></span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Digraph <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Digraph  R= <span class="keyword">new</span> Digraph(V);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>;v&lt;V;v++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w:adj(v))</span><br><span class="line">                R.addEdge(w, v);</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出有向图 Digraph 的实现中多了一个 reverse() 函数，这是将<strong>所有边全部反向</strong>，这个函数在后面会有作用。</p>
<h5 id="2-可达性"><a href="#2-可达性" class="headerlink" title="2. 可达性"></a>2. 可达性</h5><p>对于有向图我们依然有<strong>搜索</strong>的需要，并且我们依然可以使用深度优先以及广度优先搜索，首先可以解决的问题是<strong>可达性，从一个或一组顶点出发能否到达一点</strong>，使用深度优先或者广度优先都可以实现，然后还能找到一个路径，同时利用广度优先还能找出最短路径，这些问题的解决方式<strong>和无向图基本没有差别</strong>，只是将 Graph 替换为 Digraph 就行，所以不再详述。</p>
<h5 id="3-有向无环图DAG"><a href="#3-有向无环图DAG" class="headerlink" title="3. 有向无环图DAG"></a>3. 有向无环图DAG</h5><p><strong>DAG</strong>（Directed Acyclic Graph）即为<strong>有向无环图</strong>，就是没有有向的环路的有向图，这在现实生活中也很常见，比如一些具有优先级的任务流程。</p>
<p>对 DAG 有一些处理算法，不过在那之前，先来看看<strong>怎么判断一副有向图是否为 DAG</strong>。</p>
<p>其实很简单，首先<strong>只要有一个有向环，这个图就不是 DAG</strong>，所以只要检测出一个<strong>有向环</strong>，就可以返回了，不用再找下去了。第二这里使用<strong>深度优先搜索</strong>，深度优先沿着一条路径一直找下的特性刚好符合这里的要求，广度优先搜索是没有用的，那么什么时候判断存在一个有向环呢就是在走的时候碰到了还没有返回的顶点，用一个布尔数组 onStack 为每一个顶点保存一个是否还处于堆栈上没有返回的标志，这样，一旦在深度优先搜索的时候碰到了一个还在栈上的顶点，那么就能够确认这个有向图含有有向环，即不是 DAG。代码如下（基于算法 4）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedCycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; cycle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedCycle</span><span class="params">(Digraph G)</span></span>&#123;</span><br><span class="line">        onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[v]) dfs(G,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        onStack[v] =<span class="keyword">true</span>;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w : G.adj(v))&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.hasCycle()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!marked[w])&#123;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(onStack[w])&#123;</span><br><span class="line">                cycle = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = v; x != v; x = edgeTo[x])</span><br><span class="line">                    cycle.push(x);</span><br><span class="line">                cycle.push(w);</span><br><span class="line">                cycle.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里要注意没有这句话，在沿着路经返回的时候会不断往cycle栈里面压入数据</span></span><br><span class="line">        onStack[v] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">cycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码最后能够返回一个<strong>路径</strong>。</p>
<h5 id="4-拓扑排序"><a href="#4-拓扑排序" class="headerlink" title="4. 拓扑排序"></a>4. 拓扑排序</h5><p>下面先介绍一个概念<strong>拓扑排序：给定一副有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素</strong>，拓扑排序有着很多应用，比如<strong>任务调度，课程安排，类之间的继承</strong>等等。</p>
<p>排成之后的效果如下图:</p>
<img src="assets/image-20200521160929680.png" alt="image-20200521160929680" style="zoom:67%;" />

<p><strong>当且仅当一幅==有向图是无环图==时它才能进行拓扑排序</strong>。</p>
<p>这是显然的，存在环的话无论怎么排都不可能让图中的左右边都朝着同一方向。应该利用上面的方法判断是否有环，然后再进行全面的搜索，但是我们可以以一定的顺序将遍历完成后的结果保存在一个数据结构中，下面是三种<strong>典型的排序</strong>：</p>
<ul>
<li><strong>前序</strong>：在递归调用前将顶点加入队列。</li>
<li><strong>后序</strong>：在递归调用后将顶点加入队列。</li>
<li><strong>逆后序</strong>：在归调用后将顶点压入栈。</li>
</ul>
<p>这实现起来也很简单，只需要在深度优先搜索的代码中加入相应的对数据结构的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有向图中基于深度优先搜索的顶点排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstOrder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="comment">// 所有顶点的前序排序</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; pre;</span><br><span class="line">    <span class="comment">// 所有顶点的后序排序</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; post;</span><br><span class="line">    <span class="comment">// 所有顶点的逆后序排序</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; reversePost;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstOrder</span><span class="params">(Digraph G)</span></span>&#123;</span><br><span class="line">        pre = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">        post = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">        reversePost = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v =<span class="number">0</span> ;v&lt;G.V();v++)</span><br><span class="line">            <span class="keyword">if</span>(!marked[v]) dfs(G,v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        pre.enqueue(v);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w:G.adj(v))</span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) dfs(G,  w);</span><br><span class="line"></span><br><span class="line">        post.enqueue(v);</span><br><span class="line">        reversePost.push(v);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">post</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> post();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">reversePost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reversePost;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中，pre(), post(), reversePost() 分别能够<strong>返回顶点的前序，后序以及逆后序</strong>。</p>
<p>现在我们已经很容易就能够实现拓扑排序了，因为有一个定理：</p>
<p><strong>==一幅有向无环图的拓扑排序即为所有顶点的逆后序排序。==</strong></p>
<p>实现代码如下（基于<strong>自定义</strong>图结构）：整个过程看<strong>注释</strong>就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 拓扑排序</span></span><br><span class="line"><span class="comment"> * @param graph 图</span></span><br><span class="line"><span class="comment"> * 必须是有向无环图才可以</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title">sortedTopology</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key：某一个node</span></span><br><span class="line">    <span class="comment">// value：剩余的入度</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; inMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 入度为0的点，才能进这个队列</span></span><br><span class="line">    Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历图的所有节点得到inMap和zeroInQueue</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123;</span><br><span class="line">        <span class="comment">// 初始时所有的节点的剩余入度就是其原始入度</span></span><br><span class="line">        inMap.put(node, node.in);</span><br><span class="line">        <span class="comment">// 如果某节点入度为0则加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (node.in == <span class="number">0</span>) &#123;</span><br><span class="line">            zeroInQueue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存放拓扑排序的结果，依次加入result</span></span><br><span class="line">    List&lt;Node&gt; sortResultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 从入度为0的节点开始排序</span></span><br><span class="line">    <span class="keyword">while</span> (!zeroInQueue.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 弹出一个入度为0的结点并加入结果队列</span></span><br><span class="line">        Node cur = zeroInQueue.poll();</span><br><span class="line">        sortResultList.add(cur);</span><br><span class="line">        <span class="comment">// 遍历这个结点的邻居</span></span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">            <span class="comment">// 变量之后将邻居的剩余入度减1</span></span><br><span class="line">            inMap.put(next, inMap.get(next) - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 当某个结点的剩余入度为0时则放入0入度队列中</span></span><br><span class="line">            <span class="keyword">if</span> (inMap.get(next) == <span class="number">0</span>) &#123;</span><br><span class="line">                zeroInQueue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回排序结果</span></span><br><span class="line">    <span class="keyword">return</span> sortResultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决任务调度类问题的步骤：</p>
<ul>
<li>指明<strong>任务和优先级</strong>条件。</li>
<li>不断检测并去除有向图中的<strong>所有环</strong>，以确保存在<strong>可行</strong>方案。</li>
<li>使用<strong>拓扑排序</strong>解决调度问题。</li>
</ul>
<h5 id="5-Kosaraju算法"><a href="#5-Kosaraju算法" class="headerlink" title="5. Kosaraju算法"></a>5. Kosaraju算法</h5><p>Kosaraju 算法是用来<strong>找出有向图强连通分量</strong>的，前面的一些方法在这里也有一些作用，不过在那之前先介绍清楚几个概念。</p>
<ul>
<li><strong>强连通</strong>：对于两个顶点 v 和 w，分别存在一条从 v 到 w 和从 w 到 v 的有向路径，即两个顶点是<strong>互相可达</strong>的。那么称这两个顶点是强连通的。</li>
<li><strong>强连通分量</strong>：是有向图 G 的一个子集，它的<strong>所有顶点</strong>都互相是强连通的。</li>
</ul>
<p>下图含有  5 个强连通分量。</p>
<img src="assets/1577431690959.png" alt="1577431690959" style="zoom:50%;" />

<p><strong>两个顶点是强连通的当且仅当它们都在一个==普通的有向环==中</strong>。</p>
<p><strong>Kosaraju 算法可以给出有向图中有几个强连通分量以及两个顶点是否在一个强连通分量里面。</strong></p>
<p>算法的<strong>步骤</strong>主要是：对有向图 G 的<strong>反向图</strong> G^R^ 进行<strong>==拓扑排序==</strong>，<strong>然后根据这个顺序使用==深度优先==处理有向图 G，然后每一次递归所经过的顶点都在一个强连通分量里面。</strong></p>
<p>下面给出一个比较直观的证明：首先对于每一个强连通分量为了直观起见，我们将其视作一个<strong>点</strong>，那么我们的目标就是找出这个收缩过之后的图有几个顶点，联系之前的无向图的连通分量的算法，我们希望每个节点返回一次。这该怎么达到呢？这时<strong>拓扑排序</strong>就派上用场了，我们先对图求反，再对其做拓扑排序，这时候得到的结果，我们不考虑强连通分量中的点，在强连通分量之间就是完全的拓扑排序的反序，按照这个顺序在 G 中进行深度优先搜索，我们就会每次搜索完强连通分量内的点，然后无法到达其他连通分量，就只能返回，达到了我们前面说的对每个强连通分量缩成的节点每次都返回一次。<br><img src="assets/1577431843894.png" alt="1577431843894" style="zoom:80%;" /></p>
<p>上图是《算法4》中的一个例子，右边的图中，每一个方框内都是一个<strong>强连通分量</strong>，然后可以发现，按照反向图的逆后序进行深度优先搜索的话，强联通分量之间的边都是逆着的，这就完成了上面所说的每个收缩后的节点返回一次的目的。</p>
<p>最后说一点可能不对的想法，在思考证明方法的过程中我想到一种情况，我们第一次搜索反向图是为了得到缩点之后的连通分量之间的边是逆着的图，但是好像单纯对原图搜索，取其后序好像也行，但是实验之后发现结果不对，但是百思不得其解，后来找了个小例子发现了一个可能性，关键在于强连通分量之间是可达的，这个道理好像是显而易见的，但是应该就是这种方法行不通的原因，举个极端例子，在某个顶点出发是完全有可能一次就遍历整个图，并且第一个完成遍历的顶点就和它相连，那么当我们按照后序第二次遍历的时候就会一下子遍历整个图，那么最后我们就会只得到一个连通分量，这显然是不对的。</p>
<p>下面是计算强连通分量的 Kosaraju 算法代码的实现（基于算法 4）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KosarajuSCC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KosarajuSCC</span><span class="params">(MyDigraph G)</span></span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        id = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        DepthFirstOrder order = <span class="keyword">new</span> DepthFirstOrder(G.reverse());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s:order.reversePost())</span><br><span class="line">            <span class="keyword">if</span>(!marked[s])&#123;</span><br><span class="line">                dfs(G,s);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(MyDigraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        marked[v] =<span class="keyword">true</span>;</span><br><span class="line">        id[v] =count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w:G.adj(v))</span><br><span class="line">            <span class="keyword">if</span>(!marked[w])</span><br><span class="line">                dfs(G, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stronglyConnected</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[v] == id[w];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Kosaraju 算法的预处理所需的时间和空间与 V+E 成正比且支持<strong>常数时间</strong>的<strong>有向图强连通性</strong>的查询。</p>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><h5 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>在前面我们了解到了无向图和加权有向图，类似的我们给无向图的每一条边加上<strong>权重</strong>，就得到了加权无向图，加权无向图在现实中也有许多应用，在这一篇，我们讨论对它的一个重要的处理，就是找出图中（本篇中默认为<strong>加权无向图</strong>）的最小生成树。</p>
<p><strong>最小生成树：图的生成树是它的一棵含有所有顶点的无环连通子图。加权图的最小生成树（MST）是它的一棵权值之和最小的生成树</strong>。</p>
<p><em>默认权值是不相同的，否则会产生不唯一的最小生成树</em>。</p>
<p>最小生成树算法有<strong>很多应用</strong>，比如顶点是城市，边是城市之间的航线，那么最小生成树可以看作覆盖这些城市做需要的<strong>最短总航线</strong>，下面我们先来看基本的实现原理。</p>
<h5 id="2-切分定理"><a href="#2-切分定理" class="headerlink" title="2. 切分定理"></a>2. 切分定理</h5><ul>
<li>切分：将图的<strong>顶点集</strong>分为两个非空并且没有交集的集合。下图即切分为<strong>白色和灰色</strong>两部分的顶点。</li>
<li><strong>横切边</strong>：链接两个属于不同集合的顶点的边。（下图的红色边）</li>
</ul>
<img src="assets/1577432773034.png" alt="1577432773034" style="zoom: 50%;" />

<p><strong>切分定理</strong>：在一副加权图中，给定<strong>任意的切分</strong>，<strong>它的横切边中的==权重最小者==必然属于图中的最小生成树</strong>。</p>
<p>==<strong>权重最小的横切边必然属于最小生成树。</strong>==</p>
<h5 id="3-最小生成树的贪心算法"><a href="#3-最小生成树的贪心算法" class="headerlink" title="3. 最小生成树的贪心算法"></a>3. 最小生成树的贪心算法</h5><p>贪心思想：<strong>使用切分定理找到最小生成树的一条边，==不断重复==直到找到最小生成树的所有边。</strong></p>
<p>贪心算法是所有最小生成树算法的基础，基本原理就是从<strong>一个点</strong>开始，以已经找到的最小生成树的顶点，和其他顶点作为一个切分，<strong>找出权重最小的横切边</strong>，加入最小生成树，不断进行下去，直到包含了所有顶点。</p>
<p>过程如下：</p>
<p>将含有 V 个顶点的任意加权连通图中<strong>属于</strong>最小生成树的<strong>边标记为黑色</strong>。</p>
<ol>
<li>初始状态下所有<strong>边均为灰色</strong>，找到一种切分，它产生的横切边<strong>均不为黑色</strong>。</li>
<li>将它<strong>权重最小</strong>的横切边标记为<strong>黑色</strong>。</li>
<li>反复，直到标记了 <strong>V-1 条黑色</strong>边为止。</li>
</ol>
<img src="assets/1577433213643.png" alt="1577433213643" style="zoom: 70%;" />

<h5 id="4-Prim算法"><a href="#4-Prim算法" class="headerlink" title="4. Prim算法"></a>4. Prim算法</h5><p>这里介绍的 Prim 算法和下面将要介绍的 Kruskal 算法基本原理都是上面说的<strong>贪心算法</strong>，可以发现算法实现的关键就是<strong>找出横切边</strong>。</p>
<p>下面是从算法 4 上截取的一幅图：</p>
<p><img src="assets/1577434100377.png" alt="1577434100377"></p>
<p>可以大致看下算法的运行过程，首先将 0 加入优先队列，之后将其弹出，插入和 0 相邻的顶点，图中左边显示了 edgeTo[] 和 distTo[]，红色的值代表当前阶段在优先队列中的边，也就是图示中细红色的边。再看第 6 步，原本是 0-4 这条边连接在生成树上的，但是当树生长到 5 节点的时候，发现 5-4 的权重更低，所以就更改了 4 连到树上的边。最后还有一点需要注意，树内的顶点是不能连接的，否则就会<strong>形成环</strong>，所以在生长的过程中不能连接 marked[] 为 true 的节点。</p>
<p>下面是基于自定义结构的 Prim 算法得到最小生成树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结点权重比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用Prim算法获取最小生成树的边集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">primMST</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解锁的边进入小根堆</span></span><br><span class="line">    PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 依次挑选的的边在result里</span></span><br><span class="line">    Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 随便挑了一个点</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123;</span><br><span class="line">        <span class="comment">// node是开始点</span></span><br><span class="line">        <span class="keyword">if</span> (!set.contains(node)) &#123;</span><br><span class="line">            <span class="comment">// 不在集合的点就加入set</span></span><br><span class="line">            set.add(node);</span><br><span class="line">            <span class="comment">// 将这个点所有相连的边解锁，加入优先级队列</span></span><br><span class="line">            <span class="keyword">for</span> (Edge edge : node.edges) &#123;</span><br><span class="line">                priorityQueue.add(edge);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 弹出解锁的边中，权重最小的边</span></span><br><span class="line">                Edge edge = priorityQueue.poll();</span><br><span class="line">                <span class="comment">// 获取这个边的to结点</span></span><br><span class="line">                Node toNode = edge.to;</span><br><span class="line">                <span class="comment">// 不含有的时候，就是新的点</span></span><br><span class="line">                <span class="keyword">if</span> (!set.contains(toNode)) &#123;</span><br><span class="line">                    <span class="comment">// 记录已经遍历</span></span><br><span class="line">                    set.add(toNode);</span><br><span class="line">                    <span class="comment">// 含有新的结点的且是权重小的边则加入结果集</span></span><br><span class="line">                    result.add(edge);</span><br><span class="line">                    <span class="comment">// 将to结点的全部边加入优先级队列中</span></span><br><span class="line">                    <span class="keyword">for</span> (Edge nextEdge : toNode.edges) &#123;</span><br><span class="line">                        priorityQueue.add(nextEdge);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// break;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 Prim 算法获取最小生成树的路径之和。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请保证graph是连通图</span></span><br><span class="line"><span class="comment">// graph[i][j]表示点i到点j的距离，如果是系统最大值代表无路</span></span><br><span class="line"><span class="comment">// 返回值是最小连通图的路径之和</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = graph.length;</span><br><span class="line">    <span class="keyword">int</span>[] distances = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];</span><br><span class="line">    visit[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        distances[i] = graph[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minPath = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> minIndex = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[j] &amp;&amp; distances[j] &lt; minPath) &#123;</span><br><span class="line">                minPath = distances[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (minIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[minIndex] = <span class="keyword">true</span>;</span><br><span class="line">        sum += minPath;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visit[j] &amp;&amp; distances[j] &gt; graph[minIndex][j]) &#123;</span><br><span class="line">                distances[j] = graph[minIndex][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-Kruskal算法"><a href="#5-Kruskal算法" class="headerlink" title="5. Kruskal算法"></a>5. Kruskal算法</h5><p>Prim 算法是从<strong>一个顶点开始</strong>不断地生长，Kruskal 算法却不是这样，其基本想法是，<strong>对所有边的权重进行排序，然后从小到大，不断地将最小的边加入优先队列</strong>，这里又用到了优先队列。到最后所有的边连在一起形成一整棵树的时候，算法就可以停止。但是要注意的是，<strong>即使我们得到了一个权重最小的边，也不一定能加入到树中，新加入的边不能让已有的边形成环</strong>，因为生成树肯定是没有环的。</p>
<p>《算法4》中又使用了一种数据结构 <strong>UnionFind</strong>，可以用来<strong>快速查找节点之间是否连通</strong>，本质上还是树，查找的时候从叶结点不断上溯到根节点，以根节点为<strong>连通分量的区分标志</strong>。具体的结构不再详述，感兴趣的可查找其他资料。</p>
<p>Kruskal 算法构造最小生成树的时候也是一条边一条边的构造，<strong>不同的是它寻找的边会连接一片森林中的两棵树</strong>。我们从一片由 V 颗单节点的树构成的森林开始，不断将两棵树合并（用可以找到的最短边）直到只剩下一棵树，这就是最小生成树。</p>
<p><img src="assets/1577434860390.png" alt="1577434860390"></p>
<p>看着上面的图就会发现过程很好理解，<strong>右边是按照权重排序好的边</strong>，黑色的是插入树的边，灰色的是插入时会形成环的，所以没有插入的边，这样的边直接<strong>略过</strong>，最后只要总的<strong>边数达到 V-1</strong> 就行了。</p>
<p>基于自定义数据结构实现的代码如下：基于并查集和优先队列实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Union-Find Set</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">    <span class="comment">// key 某一个节点， value key节点往上的节点</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line">    <span class="comment">// key 某一个集合的代表节点, value key所在集合的节点个数</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fatherMap = <span class="keyword">new</span> HashMap&lt;Node, Node&gt;();</span><br><span class="line">        sizeMap = <span class="keyword">new</span> HashMap&lt;Node, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeSets</span><span class="params">(Collection&lt;Node&gt; nodes)</span> </span>&#123;</span><br><span class="line">        fatherMap.clear();</span><br><span class="line">        sizeMap.clear();</span><br><span class="line">        <span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">            fatherMap.put(node, node);</span><br><span class="line">            sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">findFather</span><span class="params">(Node n)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Node&gt; path = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n != fatherMap.get(n)) &#123;</span><br><span class="line">            path.add(n);</span><br><span class="line">            n = fatherMap.get(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!path.isEmpty()) &#123;</span><br><span class="line">            fatherMap.put(path.pop(), n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameSet</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findFather(a) == findFather(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(Node a, Node b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node aDai = findFather(a);</span><br><span class="line">        Node bDai = findFather(b);</span><br><span class="line">        <span class="keyword">if</span> (aDai != bDai) &#123;</span><br><span class="line">            <span class="keyword">int</span> aSetSize = sizeMap.get(aDai);</span><br><span class="line">            <span class="keyword">int</span> bSetSize = sizeMap.get(bDai);</span><br><span class="line">            <span class="keyword">if</span> (aSetSize &lt;= bSetSize) &#123;</span><br><span class="line">                fatherMap.put(aDai, bDai);</span><br><span class="line">                sizeMap.put(bDai, aSetSize + bSetSize);</span><br><span class="line">                sizeMap.remove(aDai);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fatherMap.put(bDai, aDai);</span><br><span class="line">                sizeMap.put(aDai, aSetSize + bSetSize);</span><br><span class="line">                sizeMap.remove(bDai);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权重比较器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Edge</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge o1, Edge o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// K算法生成最小生成树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title">kruskalMST</span><span class="params">(Graph graph)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 并查集</span></span><br><span class="line">    UnionFind unionFind = <span class="keyword">new</span> UnionFind();</span><br><span class="line">    unionFind.makeSets(graph.nodes.values());</span><br><span class="line">    <span class="comment">// 优先级队列</span></span><br><span class="line">    PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> EdgeComparator());</span><br><span class="line">    <span class="keyword">for</span> (Edge edge : graph.edges) &#123; <span class="comment">// M 条边</span></span><br><span class="line">        priorityQueue.add(edge);    <span class="comment">// O(logM)</span></span><br><span class="line">    &#125;</span><br><span class="line">    Set&lt;Edge&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;    <span class="comment">// M 条边</span></span><br><span class="line">        Edge edge = priorityQueue.poll(); <span class="comment">// O(logM)</span></span><br><span class="line">        <span class="keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) &#123; <span class="comment">// O(1)</span></span><br><span class="line">            result.add(edge);</span><br><span class="line">            unionFind.union(edge.from, edge.to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>面试一般讲讲算法原理就行了。</p>
<h5 id="6-算法对比"><a href="#6-算法对比" class="headerlink" title="6. 算法对比"></a>6. 算法对比</h5><p>对于时间成本上面介绍的即使 Prim 算法的速度最坏情况下可以达到 <strong>ElogV</strong>，因为它维护的是一个<strong>关于顶点的优先队列</strong>，所以一次最坏速度为 logV，算法进行过程中需要 V 次插入，V 次删除最小值，以及最坏情况下 E 次改变权重，而每次改变权重都需要重新使堆有序，也就是又一次logV，所以总共的最坏速度为ElogV。<br>对于 Kruskal 算法就要慢一些对于最坏情况下速度为 ElogE，主要是因为它维护了一个所有边的优先队列，那每次对优先队列操作成本为 logV，而最坏情况下需要遍历所有边才能够得到我们需要的 V-1 条，其他的 UnionFound 的操作因为是对顶点进行的，所以乘的是 logV，量级上比较小，所以忽略。</p>
<p><strong>Kruskal 算法一般还是要比 Prim 算法慢</strong>，因为在处理每条边时除了两种算法都需要完成的优先队列操作之外，Kruskal 算法还需要进行一次 <strong>union</strong>() 操作。</p>
<p><strong>Kruskal 算法和 Prim 算法==都不能处理有向图==</strong>。</p>
<h4 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h4><h5 id="1-最短路径树SPT"><a href="#1-最短路径树SPT" class="headerlink" title="1. 最短路径树SPT"></a>1. 最短路径树SPT</h5><p>最短路径：在一幅<strong>加权有向图</strong>中,从顶点 s 到顶点 t 的<strong>最短路径</strong>是所有从 s 到 t 的路径中的<strong>权重最小</strong>者。</p>
<p>重点是<strong>单点最短路径</strong>，<strong>最短路径树(SPT)</strong>包含了顶点 s 到所有可达的顶点的最短路径。</p>
<p>给定一幅加权有向图和一个起点 s，以 s 为起点的<strong>一颗最短路径树</strong>是图的一幅子图。</p>
<p>从一个顶点 s 到其他所有顶点的最短路径的集合其实本质是<strong>一颗树（无环）</strong>。因为如果最短路径中存在环的话，那么从 s 到环中任意一个顶点的距离就不是唯一的，也就不存在最短的定义了。</p>
<p>因此我们<strong>本质是要得到一颗最短路径树</strong>。</p>
<p>1）最短路径的<strong>边</strong>。使用一个父链接数组 edgeTo[]。edgeTo[v] 的<strong>值</strong>为树中连接 v 和它的<strong>父节点</strong>的边（也是从 s 到 v 的最短路径上的最后一条边）</p>
<p>2）到达起点的<strong>距离</strong>。用一个 distTo[] 数组来保存距离。distTo[v] 表示从 s 到 v 的<strong>最短路径的长度</strong>。</p>
<img src="assets/1577438382052.png" alt="1577438382052" style="zoom:50%;" />

<p> 上图表示的是从 0 出发的<strong>最短路径树</strong>。</p>
<h5 id="2-最短路径基本原理"><a href="#2-最短路径基本原理" class="headerlink" title="2. 最短路径基本原理"></a>2. 最短路径基本原理</h5><p>对于一幅加权有向图，从<strong>源点</strong>开始到所有顶点的所有最短路径构成了一个<strong>最短路径树</strong>。我们在算法中维护了两个关键的数据结构, <strong>edgeTo[]</strong> 代表在最短路径树中指向每个顶点的边， <strong>distTo[]</strong> 代表从源到某个顶点的“距离”也就是所经过的最短路径边的<strong>权重之和</strong>。</p>
<p>下面介绍一种关键的技术：“<strong>松弛</strong>”，可以参考下图：<br><img src="assets/1577437155880.png" alt="1577437155880"></p>
<p><strong>松弛</strong>就相当于放松一条边时将橡皮筋转移到一条更短的路径上，从而<strong>缓解了橡皮筋的压力</strong>。</p>
<p>所谓<strong>松弛</strong>就是对于一条边 <strong>v-&gt;w</strong>，此时 w 到源点的最短路径为 distTo[w]，这个值不管是不是真的，目前来看是最优值，然后现在如果 <strong>distTo[v] + e.weight() &gt; distTo[w]</strong> 那么就证明 v-&gt;w 这条边一定不可能在最短路径树里面，那么这条边就<strong>可以不用管</strong>了。等于的话我们没必要管它。<br>如果相反，<strong>dist[w] &gt; distTo[v] + e.weoght()</strong>, 那么就证明我们<strong>找到了从源点到达 w 顶点的一条更短路径</strong>，那么就可以<strong>更新</strong> edgeTo[w] 和 distTo[w]，以上两种情况分别对应于上图左右两种情况。</p>
<p><strong>最短路径的最优性条件</strong>：当且仅当对于从 v 到 w 的任意一条边 e，这些值*<em>都满足 *</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distTo[w] &lt;= distTo[v]+e.weight()</span><br></pre></td></tr></table></figure>

<p>时，他们是最短路径。具体的证明在此处略过，证明它并不难。</p>
<h5 id="3-Dijkstra算法"><a href="#3-Dijkstra算法" class="headerlink" title="3. Dijkstra算法"></a>3. Dijkstra算法</h5><p>其实 Dijkstra 算法和 Prim 算法很相似，Prim 算法是在<strong>横切边中找到权重最小的边加入最小生成树</strong>，Dijkstra 算法也可以说是在横切边中找权重最小的边。两个算法也都维护了一个<strong>索引优先队列</strong>，不过一个是<strong>存储边的权值</strong>，一个<strong>存储从源点到该点的路径长度</strong>。 所以两个算法完全可以类比，同时加深理解。<br>对于 <strong>Dijkstra 索引优先队列</strong> pq 代表<strong>在最小路径树之外的还需要进行放松</strong>（这里用的为 relax() 函数）<strong>的边</strong>，每次从 pq 中删除路径长度最小的顶点，其实<strong>删除就意味着顶点加入最小路径树</strong>，因为它<strong>不参与</strong>之后的比较了。然后将该顶点相连的所有边进行放松，这一步可能会改变某些已经放松过的顶点的路径值，但是这没有关系，首先对于这样的顶点和它相邻的顶点，以前的放松让它满足 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distTo[w] &lt;= distTo[v] + e.weight()</span><br></pre></td></tr></table></figure>

<p>这一次的放松只会让 distTo[w] 更小，那么不等式还是满足的。就这样不断 delMin()，<strong>当索引优先队列为空的时候，所有的边都松弛过了，同时是所有顶点都在最小路径树中了</strong>。<br>下面是代码实现（基于自定义结构）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title">dijkstra1</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从head出发到所有点的最小距离</span></span><br><span class="line">    <span class="comment">// key : 从head出发到达key</span></span><br><span class="line">    <span class="comment">// value : 从head出发到达key的最小距离</span></span><br><span class="line">    <span class="comment">// 如果在表中，没有T的记录，含义是从head出发到T这个点的距离为正无穷</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; distanceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    distanceMap.put(head, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 已经求过距离的节点，存在selectedNodes中，以后再也不碰</span></span><br><span class="line">    HashSet&lt;Node&gt; selectedNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    Node minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">    <span class="keyword">while</span> (minNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> distance = distanceMap.get(minNode);</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : minNode.edges) &#123;</span><br><span class="line">            Node toNode = edge.to;</span><br><span class="line">            <span class="keyword">if</span> (!distanceMap.containsKey(toNode)) &#123;</span><br><span class="line">                distanceMap.put(toNode, distance + edge.weight);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                distanceMap.put(edge.to, Math.min(distanceMap.get(toNode), distance + edge.weight));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        selectedNodes.add(minNode);</span><br><span class="line">        minNode = getMinDistanceAndUnselectedNode(distanceMap, selectedNodes);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distanceMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">getMinDistanceAndUnselectedNode</span><span class="params">(HashMap&lt;Node, Integer&gt; distanceMap, HashSet&lt;Node&gt; touchedNodes)</span> </span>&#123;</span><br><span class="line">    Node minNode = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> minDistance = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;Node, Integer&gt; entry : distanceMap.entrySet()) &#123;</span><br><span class="line">        Node node = entry.getKey();</span><br><span class="line">        <span class="keyword">int</span> distance = entry.getValue();</span><br><span class="line">        <span class="keyword">if</span> (!touchedNodes.contains(node) &amp;&amp; distance &lt; minDistance) &#123;</span><br><span class="line">            minNode = node;</span><br><span class="line">            minDistance = distance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于自定义结构的另一种实现方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改进后的dijkstra算法</span></span><br><span class="line"><span class="comment">// 从head出发，所有head能到达的节点，生成到达每个节点的最小路径记录并返回</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Node, Integer&gt; <span class="title">dijkstra2</span><span class="params">(Node head, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    NodeHeap nodeHeap = <span class="keyword">new</span> NodeHeap(size);</span><br><span class="line">    nodeHeap.addOrUpdateOrIgnore(head, <span class="number">0</span>);</span><br><span class="line">    HashMap&lt;Node, Integer&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!nodeHeap.isEmpty()) &#123;</span><br><span class="line">        NodeRecord record = nodeHeap.pop();</span><br><span class="line">        Node cur = record.node;</span><br><span class="line">        <span class="keyword">int</span> distance = record.distance;</span><br><span class="line">        <span class="keyword">for</span> (Edge edge : cur.edges) &#123;</span><br><span class="line">            nodeHeap.addOrUpdateOrIgnore(edge.to, edge.weight + distance);</span><br><span class="line">        &#125;</span><br><span class="line">        result.put(cur, distance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeHeap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node[] nodes; <span class="comment">// 实际的堆结构</span></span><br><span class="line">    <span class="comment">// key 某一个node， value 上面数组中的位置</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; heapIndexMap;</span><br><span class="line">    <span class="comment">// key 某一个节点， value 从源节点出发到该节点的目前最小距离</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Node, Integer&gt; distanceMap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size; <span class="comment">// 堆上有多少个点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeHeap</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        nodes = <span class="keyword">new</span> Node[size];</span><br><span class="line">        heapIndexMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        distanceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有一个点叫node，现在发现了一个从源节点出发到达node的距离为distance</span></span><br><span class="line">    <span class="comment">// 判断要不要更新，如果需要的话，就更新</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addOrUpdateOrIgnore</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inHeap(node)) &#123;</span><br><span class="line">            distanceMap.put(node, Math.min(distanceMap.get(node), distance));</span><br><span class="line">            insertHeapify(node, heapIndexMap.get(node));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isEntered(node)) &#123;</span><br><span class="line">            nodes[size] = node;</span><br><span class="line">            heapIndexMap.put(node, size);</span><br><span class="line">            distanceMap.put(node, distance);</span><br><span class="line">            insertHeapify(node, size++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NodeRecord <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NodeRecord nodeRecord = <span class="keyword">new</span> NodeRecord(nodes[<span class="number">0</span>], distanceMap.get(nodes[<span class="number">0</span>]));</span><br><span class="line">        swap(<span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        heapIndexMap.put(nodes[size - <span class="number">1</span>], -<span class="number">1</span>);</span><br><span class="line">        distanceMap.remove(nodes[size - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// free C++同学还要把原本堆顶节点析构，对java同学不必</span></span><br><span class="line">        nodes[size - <span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        heapify(<span class="number">0</span>, --size);</span><br><span class="line">        <span class="keyword">return</span> nodeRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertHeapify</span><span class="params">(Node node, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (distanceMap.get(nodes[index]) &lt; distanceMap.get(nodes[(index - <span class="number">1</span>) / <span class="number">2</span>])) &#123;</span><br><span class="line">            swap(index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">            <span class="keyword">int</span> smallest = left + <span class="number">1</span> &lt; size &amp;&amp; distanceMap.get(nodes[left + <span class="number">1</span>]) &lt; distanceMap.get(nodes[left])</span><br><span class="line">                ? left + <span class="number">1</span></span><br><span class="line">                : left;</span><br><span class="line">            smallest = distanceMap.get(nodes[smallest]) &lt; distanceMap.get(nodes[index]) ? smallest : index;</span><br><span class="line">            <span class="keyword">if</span> (smallest == index) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(smallest, index);</span><br><span class="line">            index = smallest;</span><br><span class="line">            left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEntered</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> heapIndexMap.containsKey(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inHeap</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isEntered(node) &amp;&amp; heapIndexMap.get(node) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123;</span><br><span class="line">        heapIndexMap.put(nodes[index1], index2);</span><br><span class="line">        heapIndexMap.put(nodes[index2], index1);</span><br><span class="line">        Node tmp = nodes[index1];</span><br><span class="line">        nodes[index1] = nodes[index2];</span><br><span class="line">        nodes[index2] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NodeRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node node;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NodeRecord</span><span class="params">(Node node, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">        <span class="keyword">this</span>.distance = distance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到代码都和 Prim 很像，时间成本也是相同的都是 ElogV。</p>
<p>Prim 算法和 Dijkstra 算法都会用<strong>添加边</strong>的方式构造一棵树：<strong>Prim 算法每次添加的都是==离树最近的非树顶点==，Dijkstra 算法每次添加的都是==离起点最近的非树顶点==。</strong></p>
<p><strong>Dijkstra 算法能够解决==边权重非负==的==加权有向图==的==单起点最短路径==问题。</strong></p>
<p>但是 Dijkstra 算法<strong>默认边的权重非负</strong>，对于<strong>有负权重</strong>的边，他是<strong>不能</strong>给出合理的最短路径的，这时候就要用上另一个算法 Bellman-Ford 算法。</p>
<h5 id="4-无环加权有向图中的最短路径算法"><a href="#4-无环加权有向图中的最短路径算法" class="headerlink" title="4. 无环加权有向图中的最短路径算法"></a>4. 无环加权有向图中的最短路径算法</h5><h6 id="1-最短路径"><a href="#1-最短路径" class="headerlink" title="(1) 最短路径"></a>(1) 最短路径</h6><p>如果加权有向图是<strong>无环</strong>的，那么可以使用一种比 Dijkstra 算法更快的算法来找最短路径。</p>
<p>无环加权有向图的算法的核心在于<strong>依照有向图的拓扑排序来松弛每条边</strong>。而拓扑排序又保证了每条边只会被放松一次，因此这是一种最优的最短路径搜索方法。</p>
<p>算法思想：</p>
<p><strong>首先将 distTo[s] 初始化为 0，其他的 distTo[] 元素初始化为无穷大，然后一个一个按照==拓扑顺序==放松所有顶点。</strong></p>
<p><strong>按照==拓扑顺序放松顶点==，就能在与 E+V 成正比的时间内解决无环加权有向图的单点最短路径问题。</strong></p>
<p>无环加权有向图的最短路径算法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无环加权有向图的最短路径算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcyclicSP</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcyclicSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v =<span class="number">0</span> ;v&lt;G.V(); v++)</span><br><span class="line">            distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line"></span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="comment">// 实现拓扑排序</span></span><br><span class="line">        Topological top = <span class="keyword">new</span> Topological(G); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v:top.order())</span><br><span class="line">            relax(G, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 放松顶点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(DirectedEdge e: G.adj(v))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = e.to();</span><br><span class="line">            <span class="keyword">if</span>(distTo[w] &gt; distTo[v] + e.weight())</span><br><span class="line">            &#123;</span><br><span class="line">                distTo[w] = distTo[v] + e.weight();</span><br><span class="line">                edgeTo[w] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function">        </span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> Iterable&lt;DirecedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span>   </span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在<strong>已知加权图是无环</strong>的情况下，这是找出最短路径的<strong>最好的方法</strong>。</p>
<h6 id="2-最长路径"><a href="#2-最长路径" class="headerlink" title="(2) 最长路径"></a>(2) 最长路径</h6><p><strong>任务调度问题</strong>的<strong>关键路径</strong>方法可将问题规约为寻找无环加权有向图的<strong>最长路径问题</strong>。</p>
<p>相对最后期限限制下的并行任务调度问题是一个加权有向图中的<strong>最短路径问题</strong>（可能存在环和负权重边）。</p>
<h5 id="5-Bellman-Ford算法"><a href="#5-Bellman-Ford算法" class="headerlink" title="5.  Bellman-Ford算法"></a>5.  Bellman-Ford算法</h5><h6 id="1-理解负权重"><a href="#1-理解负权重" class="headerlink" title="(1) 理解负权重"></a>(1) 理解负权重</h6><p>负权重的出现其实不只体现在数学上，在实际应用中其实非常实用。以任务调度为例。</p>
<img src="assets/1577444989131.png" alt="1577444989131" style="zoom:50%;" />

<p>以上图为例。边的权重指的是任务需要的<strong>时间</strong>。例如任务 0 需要 41 个时间单位才能完成，任务 0 完成后才能开始任务 1，任务 1 需要 82 个时间单位，然后才能开始任务 2…</p>
<p>而 6 指向 3 的路径权重为 -20，这是指 6 号任务需要在 3 号任务开始后的 20 个时间单位内开始，或者说 3 号任务不能早于 6 号任务的 20 个时间单位。</p>
<h6 id="2-Bellman-Ford算法"><a href="#2-Bellman-Ford算法" class="headerlink" title="(2) Bellman-Ford算法"></a>(2) Bellman-Ford算法</h6><p>Bellman-Ford算法：<strong>在任意含有 V 个顶点的加权有向图中给定起点 s，从 s 无法到达任何负权重环，然后将 distTo[s] 初始化为 0，其他初始化为无穷大，以==任意顺序==放松所有边，重复 V 轮</strong>。</p>
<p>这种算法<strong>比较慢</strong>，所需<strong>时间与 EV</strong> 成正比，<strong>空间与 V</strong> 成正比，实际中很浪费。因为每一轮算法都会<strong>放松</strong> E 条边，重复 V 轮。</p>
<p>还有一个重要的问题是如果存在负权重环（就是环的所有边的权重加起来为负），那么经过该环的所有顶点的最短路径都是无意义的，所以算法还需要能够<strong>检测负权重环</strong>，不过这里的算法和检测无环图部分的思想是一样的，这里就不再赘述。<br>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BellmanFordSP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onQ;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cost;</span><br><span class="line">    <span class="keyword">private</span> Iterable&lt;DirectedEdge&gt; cycle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BellmanFordSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</span><br><span class="line">        onQ = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        queue = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v=<span class="number">0</span>;v&lt;G.V();v++)</span><br><span class="line">            distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        queue.enqueue(s);</span><br><span class="line">        onQ[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; !hasNegativeCycle())&#123;</span><br><span class="line">            <span class="keyword">int</span> v = queue.dequeue();</span><br><span class="line">            onQ [v] =<span class="keyword">false</span>;</span><br><span class="line">            relax(G, v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e:G.adj(v))&#123;</span><br><span class="line">            <span class="keyword">int</span> w = e.to();</span><br><span class="line">            <span class="keyword">if</span>(distTo[w] &gt; distTo[v]+e.weight())&#123;</span><br><span class="line">                distTo[w] = distTo[v]+e.weight();</span><br><span class="line">                edgeTo[w] = e;</span><br><span class="line">                <span class="keyword">if</span>(!onQ[w])&#123;</span><br><span class="line">                    queue.enqueue(w);</span><br><span class="line">                    onQ[w] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cost++ % G.V() ==<span class="number">0</span>)&#123;</span><br><span class="line">                findNegativeCycle();</span><br><span class="line">                <span class="keyword">if</span> (hasNegativeCycle()) <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v]&lt;Double.POSITIVE_INFINITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;DirectedEdge&gt; path =<span class="keyword">new</span>  Stack&lt;DirectedEdge&gt;();</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge edge = edgeTo[v];edge !=<span class="keyword">null</span>;edge  =edgeTo[edge.from()])</span><br><span class="line">            path.push(edge);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">findNegativeCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = edgeTo.length;</span><br><span class="line">        EdgeWeightedDigraph spt=<span class="keyword">new</span> EdgeWeightedDigraph(V);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>;v&lt;V; v++)</span><br><span class="line">            <span class="keyword">if</span> (edgeTo[v] !=<span class="keyword">null</span>)</span><br><span class="line">                spt.addEdge(edgeTo[v]);</span><br><span class="line">        EdgeWeightedDirectedCycle finderCycle = <span class="keyword">new</span> EdgeWeightedDirectedCycle(spt);</span><br><span class="line">        cycle =finderCycle.cycle(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNegativeCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">nagativeCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是<strong>基于队列</strong>的，从其中关键的循环部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; !hasNegativeCycle())</span><br></pre></td></tr></table></figure>

<p> 可以看出，首先要<strong>一直运行到队列为空</strong>，队列什么时候会有顶点入队？当有顶点的 distTo[] 值被改变的时候，所以当算法运行结束的时候，<strong>所有顶点的路径长都已经是最小值</strong>，不能再改了。另一种情况是，我们的算法运行了 <strong>V 轮</strong>之后，如果<strong>有负权重环</strong>的话，<strong>队列一定是非空</strong>的，所以我们<strong>每隔 V 轮检测一下是不是遇到了负权重环，如果遇到了就退出</strong>。</p>
<p>可以看出 Bellman-Ford 其实和 Dijstra 也有一些相似之处。</p>
<p>下面的代码就是在加权有向图中检测环的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedDirectedCycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;DirectedEdge&gt; cycle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedDirectedCycle</span><span class="params">(EdgeWeightedDigraph G)</span></span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>;v&lt;G.V();v++)</span><br><span class="line">            <span class="keyword">if</span> (!marked[v]) dfs(G, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        onStack[v] = <span class="keyword">true</span>;</span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e:G.adj(v))&#123;</span><br><span class="line">            <span class="keyword">int</span> w = e.to();</span><br><span class="line">            <span class="keyword">if</span>(cycle !=<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!marked[w])&#123;</span><br><span class="line">                edgeTo[w] = e;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(onStack[w])&#123;</span><br><span class="line">                cycle = <span class="keyword">new</span> Stack&lt;DirectedEdge&gt;();</span><br><span class="line">                DirectedEdge f = e;</span><br><span class="line">                <span class="keyword">while</span>(f.from() !=w)&#123;</span><br><span class="line">                    cycle.push(f);</span><br><span class="line">                    f = edgeTo[f.from()];</span><br><span class="line">                &#125;</span><br><span class="line">                cycle.push(f);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        onStack[v] =<span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle!= <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">cycle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上，<strong>基于队列</strong>的 Bellman-Ford 算法要比原始版快得多基本是  O(V+E) 的，但是最坏情况也有O(VE)，可是它的适用范围要大得多，<strong>可以存在负权重环，还可以检测出负权重环</strong>。</p>
<p><strong>套汇问题</strong>等价于加权有向图中的负权重环的检测问题。</p>
<h5 id="6-最短路径算法总结"><a href="#6-最短路径算法总结" class="headerlink" title="6. 最短路径算法总结"></a>6. 最短路径算法总结</h5><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">局限</th>
<th align="center">一般情况</th>
<th align="center">最坏情况</th>
<th align="center">所需空间</th>
<th align="center">优势</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Dijkstra 算法（即时版本）</td>
<td align="center">边的权重必须为正</td>
<td align="center">ElogV</td>
<td align="center">ElogV</td>
<td align="center">V</td>
<td align="center">最坏情况下性能依然可以</td>
</tr>
<tr>
<td align="center">拓扑排序</td>
<td align="center"><strong>只适用于无环加权有向图</strong></td>
<td align="center">E + V</td>
<td align="center">E + V</td>
<td align="center">V</td>
<td align="center">是<strong>无环图</strong>中的<strong>最优</strong>算法</td>
</tr>
<tr>
<td align="center">Bellman-Ford 算法</td>
<td align="center">不能存在负权重环</td>
<td align="center">E + V</td>
<td align="center">EV</td>
<td align="center">V</td>
<td align="center">适用领域广泛</td>
</tr>
</tbody></table>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h4><ul>
<li><a href="https://www.cnblogs.com/mcomco/p/10298021.html" target="_blank" rel="noopener">https://www.cnblogs.com/mcomco/p/10298021.html</a></li>
<li><a href="https://blog.csdn.net/leonliu1995/article/details/78509599" target="_blank" rel="noopener">https://blog.csdn.net/leonliu1995/article/details/78509599</a></li>
<li><a href="https://blog.csdn.net/leonliu1995/article/details/78634015" target="_blank" rel="noopener">https://blog.csdn.net/leonliu1995/article/details/78634015</a></li>
<li><a href="https://blog.csdn.net/leonliu1995/article/details/78701997" target="_blank" rel="noopener">https://blog.csdn.net/leonliu1995/article/details/78701997</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/J%20%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/" rel="next" title="ShiftJava/B 数据结构与算法/J 题目汇总">
                <i class="fa fa-chevron-left"></i> ShiftJava/B 数据结构与算法/J 题目汇总
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/F%20%E6%A0%91/" rel="prev" title="ShiftJava/B 数据结构与算法/F 树">
                ShiftJava/B 数据结构与算法/F 树 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#图"><span class="nav-number">1.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-基本术语"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 基本术语</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-图的表示"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 图的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-邻接矩阵"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">(1) 邻接矩阵</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-邻接表"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">(2) 邻接表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无向图"><span class="nav-number">1.2.</span> <span class="nav-text">无向图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-无向图的表示"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 无向图的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-邻接矩阵-1"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">(1) 邻接矩阵</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-邻接表数组"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">(2) 邻接表数组</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-基础结构代码实现"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 基础结构代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-深度优先搜索（DFS）"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. 深度优先搜索（DFS）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-广度优先搜索（BFS）"><span class="nav-number">1.2.5.</span> <span class="nav-text">5. 广度优先搜索（BFS）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-连通分量"><span class="nav-number">1.2.6.</span> <span class="nav-text">6. 连通分量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-检测是否为无环图"><span class="nav-number">1.2.7.</span> <span class="nav-text">7. 检测是否为无环图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有向图"><span class="nav-number">1.3.</span> <span class="nav-text">有向图</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-可达性"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 可达性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-有向无环图DAG"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 有向无环图DAG</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-拓扑排序"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 拓扑排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Kosaraju算法"><span class="nav-number">1.3.5.</span> <span class="nav-text">5. Kosaraju算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最小生成树"><span class="nav-number">1.4.</span> <span class="nav-text">最小生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-切分定理"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 切分定理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-最小生成树的贪心算法"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 最小生成树的贪心算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Prim算法"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. Prim算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Kruskal算法"><span class="nav-number">1.4.5.</span> <span class="nav-text">5. Kruskal算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-算法对比"><span class="nav-number">1.4.6.</span> <span class="nav-text">6. 算法对比</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最短路径算法"><span class="nav-number">1.5.</span> <span class="nav-text">最短路径算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-最短路径树SPT"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. 最短路径树SPT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-最短路径基本原理"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. 最短路径基本原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Dijkstra算法"><span class="nav-number">1.5.3.</span> <span class="nav-text">3. Dijkstra算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-无环加权有向图中的最短路径算法"><span class="nav-number">1.5.4.</span> <span class="nav-text">4. 无环加权有向图中的最短路径算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-最短路径"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">(1) 最短路径</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-最长路径"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">(2) 最长路径</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Bellman-Ford算法"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.  Bellman-Ford算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-理解负权重"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">(1) 理解负权重</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-Bellman-Ford算法"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">(2) Bellman-Ford算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-最短路径算法总结"><span class="nav-number">1.5.6.</span> <span class="nav-text">6. 最短路径算法总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.6.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
