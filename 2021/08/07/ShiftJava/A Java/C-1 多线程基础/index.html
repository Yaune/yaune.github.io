<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] 线程基础使用多线程不是因为其能提升程序的执行速度，而是为了更好地利用 CPU 资源！ 基本概念1. 线程概述现代操作系统在运行一个程序时，会为其创建一个进程。例如启动一个 Java 程序，操作系统就会创建一个 Java 进程。现代操作系统调度 CPU 的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;A Java&#x2F;C-1 多线程基础">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] 线程基础使用多线程不是因为其能提升程序的执行速度，而是为了更好地利用 CPU 资源！ 基本概念1. 线程概述现代操作系统在运行一个程序时，会为其创建一个进程。例如启动一个 Java 程序，操作系统就会创建一个 Java 进程。现代操作系统调度 CPU 的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80&#x2F;assets&#x2F;image-20200609123352367.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80&#x2F;assets&#x2F;image-20200609123454524.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80&#x2F;assets&#x2F;image-20200609124146883.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80&#x2F;assets&#x2F;concurrent_and_parallel.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80&#x2F;assets&#x2F;image-20200609123929997.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80&#x2F;assets&#x2F;image-20200531144719675.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80&#x2F;assets&#x2F;image-20200609123352367.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/A Java/C-1 多线程基础/"/>





  <title>ShiftJava/A Java/C-1 多线程基础 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/A%20Java/C-1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/A Java/C-1 多线程基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><p>使用多线程不是因为其能提升程序的执行速度，而是为了<strong>更好地利用 CPU 资源</strong>！</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><h5 id="1-线程概述"><a href="#1-线程概述" class="headerlink" title="1. 线程概述"></a>1. 线程概述</h5><p>现代操作系统在运行一个程序时，会为其创建一个<strong>进程</strong>。例如启动一个 Java 程序，操作系统就会创建一个 <strong>Java 进程</strong>。现代操作系统调度 <strong>CPU</strong> 的最小单元是<strong>线程</strong>，也叫<strong>轻量级进程</strong>（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有<strong>各自的计数器、堆栈和局部变量</strong>等属性，并且能够访问<strong>共享的内存变量</strong>。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</p>
<p>线程的实现可以分为两类：</p>
<ul>
<li><strong>用户级</strong>线程(User-Level Thread)</li>
<li><strong>内核线</strong>线程(Kernel-Level Thread)</li>
</ul>
<p>在理解线程分类之前需要先了解系统的<strong>用户空间与内核空间</strong>两个概念，以 4G 大小的<strong>内存空间</strong>为例。Linux 为内核代码和数据结构预留了几个<strong>页框</strong>，这些页永远不会被交换到磁盘上。从 0x00000000 到 0xc0000000（PAGE_OFFSET） 的线性地址可由用户代码 和 内核代码进行引用（即用户空间）。从0xc0000000（PAGE_OFFSET）到 0xFFFFFFFFF 的线性地址<strong>只能由内核代码进行访问</strong>（即内核空间）。内核代码及其数据结构都必须位于这 1GB 的地址空间中，但是对于此地址空间而言，更大的消费者是物理地址的<strong>虚拟映射</strong>。</p>
<p>这意味着在 4GB 的内存空间中，只有 3GB 可以用于<strong>用户</strong>应用程序。一个<strong>进程只能运行在用户方式</strong>（usermode）或内核方式（kernelmode）下。用户程序运行在用户方式下，而系统调用运行在内核方式下。在这两种方式下所用的<strong>堆栈不一样</strong>：用户方式下用的是<strong>一般的堆栈</strong>，而内核方式下用的是<strong>固定大小的堆栈</strong>（一般为一个内存页的大小）每个进程都有自己的 3G 用户空间，它们<strong>共享 1GB 的内核空间</strong>。当一个进程从用户空间进入内核空间时，它<strong>就不再有自己的进程空间</strong>了。这也就是为什么经常说<strong>线程上下文切换会涉及到用户态到内核态的切换原因</strong>所在。</p>
<p><strong>用户线程</strong>：指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，<strong>应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程</strong>。另外，用户线程是由应用进程利用线程库创建和管理，不依赖于操作系统核心。不需要用户态/核心态切换，速度快。操作系统内核<strong>不知道</strong>多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。</p>
<p><strong>内核线程</strong>： 线程的所有管理操作都是由<strong>操作系统内核</strong>完成的。内核保存线程的状态和上下文信息，当一个线程执行了引起阻塞的系统调用时，内核可以调度该进程的其他线程执行。在多处理器系统上，内核可以分派属于同一进程的多个线程在多个处理器上运行，提高进程执行的并行度。由于需要内核完成线程的创建、调度和管理，所以和用户级线程相比这些操作要慢得多，但是仍然比进程的创建和管理操作要快。大多数市场上的操作系统，如 Windows，Linux 等都支持内核级线程。</p>
<p><strong>用户线程与内核线程</strong>的原理区别如下图所示（图 a 用户线程，图 b 内核线程）：</p>
<p><img src="assets/image-20200609123352367.png" alt="image-20200609123352367"></p>
<p>Java 线程与系统内核线程的关系。</p>
<p><img src="assets/image-20200609123454524.png" alt="image-20200609123454524"></p>
<h5 id="2-并发"><a href="#2-并发" class="headerlink" title="2. 并发"></a>2. 并发</h5><p><strong>为什么用到并发？</strong>并发编程的本质其实就是<strong>利用多线程技术</strong>，在现代多核的 CPU 下，通过并发编程可以将多核 CPU 的计算能力发挥到极致，性能得到提升。除此之外，面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。<br>即使是<strong>单核处理器也支持多线程</strong>执行代码，CPU 通过给每个线程分配 <strong>CPU 时间片</strong>来实现这个机制。时间片是 CPU 分配给各个线程的时间，因为时间片非常短，所以 CPU 通过<strong>不停地切换线程</strong>执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。<strong>并发不等于并行</strong>：并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。实际上，如果系统内只有一个 CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个 CPU 的系统中。</p>
<p><strong>并发的优点</strong>：</p>
<ul>
<li>充分利用多核 CPU 的计算能力；</li>
<li>方便进行业务拆分，提升应用性能；</li>
</ul>
<p><strong>并发产生的问题</strong>：高并发场景下，<strong>导致频繁的上下文切换临界区线程安全问题</strong>，容易出现死锁的，产生死锁就会造成系统功能不可用其它 CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。</p>
<h5 id="3-什么是上下文切换"><a href="#3-什么是上下文切换" class="headerlink" title="3. 什么是上下文切换?"></a>3. 什么是上下文切换?</h5><p>多线程编程中一般<strong>线程的个数</strong>都多于 CPU 核数，而一个 CPU 核在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 可以采取的一种策略是为<strong>每个线程分配时间片并轮转的形式</strong>。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于<strong>一次上下文切换</strong>。</p>
<p><strong>实现方式</strong>：当前任务在执行完 CPU 时间片切换到另一个任务之前会先<strong>保存自己的状态</strong>，以便下次再切换回这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>如果上下文切换过多，对系统来说就意味着消耗大量的 CPU 时间，可能造成较大的<strong>开销</strong>。Linux 相比其他操作系统而言其上下文切换和模式切换的时间消耗通常比较少。</p>
<p><strong>线程上下文切换</strong>过程：  </p>
<p><img src="assets/image-20200609124146883.png" alt="image-20200609124146883"></p>
<blockquote>
<p><strong>如何减少线程上下文切换</strong>？</p>
</blockquote>
<p>线程<strong>不是越多就越好</strong>的，因为线程上下文切换是有<strong>性能损耗</strong>的，在使用多线程的同时需要考虑如何减少上下文切换。一般来说有以下几条经验：</p>
<ul>
<li><p><strong>无锁并发编程</strong>。多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来<strong>避免使用锁</strong>，如将数据的 ID 按照 Hash 取模分段，不同的线程处理不同段的数据。</p>
</li>
<li><p><strong>CAS 算法</strong>。Java 的 Atomic 包使用 CAS 算法来更新数据，<strong>而不需要加锁</strong>。</p>
</li>
<li><p><strong>控制线程数量</strong>。避免创建不需要的线程，线程别创建太多。</p>
</li>
<li><p><strong>协程</strong>。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。协程可以看成是<strong>用户态自管理的“线程”</strong>。<strong>不会参与</strong> CPU 时间调度，没有均衡分配到时间。</p>
</li>
<li><p>还可以考虑应用是 <strong>IO 密集型的还是 CPU 密集型</strong>的。如果是 IO 密集型的话，线程可以多一些；如果是 CPU 密集型的话，线程不宜太多。</p>
</li>
</ul>
<h5 id="4-并发与并行"><a href="#4-并发与并行" class="headerlink" title="4. 并发与并行"></a>4. 并发与并行</h5><p><strong>并发：</strong> 在<strong>同一时间段</strong>来看，多个任务都在执行，但是<strong>单位时间内不一定同时</strong>执行。指多个任务都请求运行，而单核处理器只能按受一个任务，就把这多个任务安排<strong>轮流</strong>进行，由于时间间隔较短让人感觉这些任务在同时运行。</p>
<p><strong>并行：</strong> <strong>单位时间内</strong>，<strong>多个任务同时执行</strong>。有多个 CPU 时，<strong>不同的 CPU</strong> 同时执行不同的任务，并行就是多个任务同时运行，就是甲任务进行的同时，乙任务也在进行。</p>
<img src="assets/concurrent_and_parallel.png" style="zoom:67%;" />

<h5 id="5-任务类型"><a href="#5-任务类型" class="headerlink" title="5. 任务类型"></a>5. 任务类型</h5><blockquote>
<p>问题：如何设置线程数量？</p>
</blockquote>
<p>需要看<strong>任务类型</strong>是 <strong>CPU 密集型或者是 IO 密集型</strong>。这个也是线程池需要考虑的配置点。</p>
<h6 id="1-CPU密集型"><a href="#1-CPU密集型" class="headerlink" title="(1) CPU密集型"></a>(1) CPU密集型</h6><p><strong>CPU 密集型</strong>也叫<strong>计算密集型</strong>，CPU 需要进行大量<strong>计算、逻辑判断</strong>等操作，此时系统运作大部分的状况是 <strong>CPU 负载较高</strong>。相反，读写 I/O(硬盘/内存) 的任务可以在很短的时间就可以完成，或者任务本身就不太需要访问 I/O 设备。也就是 <strong>CPU 负载高，IO 负载低</strong>。对于 CPU 密集型任务，代码运行效率至关重要。Python 这样的脚本语言运行效率很低，不适合计算密集型任务。对于计算密集型任务，最好用 C 语言编写。</p>
<p>CPU 密集型任务的线程数一般设置为：</p>
<p><strong>==线程数 = CPU 核数 + 1== (现代 CPU 支持超线程)  。</strong>计算密集型<strong>别创建太多线程</strong>，只需要让<strong>各个核</strong>都运行起来就像，线程多了反而造成<strong>任务切换</strong>频繁反而会影响性能。</p>
<h6 id="2-IO密集型"><a href="#2-IO密集型" class="headerlink" title="(2) IO密集型"></a>(2) IO密集型</h6><p><strong>IO 密集型</strong>指的是涉及到<strong>网络、磁盘 IO</strong> 相关的任务，这类任务的特点是 <strong>CPU 消耗很少</strong>，任务的大部分时间都在<strong>等待 IO 操作完成</strong>（因为 IO 的速度远远低于 CPU 和内存的速度）。也就是 <strong>CPU 负载低，IO 负载高</strong>。对于 IO 密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，用运行速度极快的 C 语言对于运行效率也没什么提高。</p>
<p>IO 密集型常见场景有：访问网页、Socket 连接通信、读磁盘、一般 <strong>Web 应用</strong>等。</p>
<p>IO 密集型任务线程数一般设置为：</p>
<p><strong>线程数 = （（线程等待时间+线程 CPU 时间）/ 线程 CPU 时间 ）* CPU 数目。</strong></p>
<h4 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h4><p>线程存在几种不同的<strong>状态</strong>，如下图所示。</p>
<p><img src="assets/image-20200609123929997.png" alt="image-20200609123929997"></p>
<h5 id="1-新建（New）"><a href="#1-新建（New）" class="headerlink" title="1. 新建（New）"></a>1. 新建（New）</h5><p><strong>创建</strong>后<strong>尚未</strong>启动。即通过 <strong>new</strong> 关键字创建一个线程实例之后，线程就进入了这个状态。</p>
<h5 id="2-可运行（Runnable）"><a href="#2-可运行（Runnable）" class="headerlink" title="2. 可运行（Runnable）"></a>2. 可运行（Runnable）</h5><p>包含了操作系统线程状态中的 <strong>Running</strong> 和 <strong>Ready</strong>。调用了 <strong>start</strong>() 方法之后变为 <strong>Ready</strong>，可能<strong>马上执行</strong>，也可能在<strong>等待 CPU 调度</strong>。Running 状态，可能<strong>正在</strong>运行，也可能正在<strong>等待 CPU 时间片</strong>。</p>
<h5 id="3-阻塞（Blocked）"><a href="#3-阻塞（Blocked）" class="headerlink" title="3. 阻塞（Blocked）"></a>3. 阻塞（Blocked）</h5><p>阻塞：就是<strong>等待锁</strong>的状态。当一个线程试图<strong>获取对象锁</strong>（不是 java.util.concurrent 库中的锁，而是 <strong>synchronized</strong>），而该锁被其他线程持有，则该线程进入阻塞状态。使用简单，由 JVM 调度器来决定唤醒自己，而不需要由另一个线程来显式唤醒自己，不响应中断。</p>
<h5 id="4-无限期等待（Waiting）"><a href="#4-无限期等待（Waiting）" class="headerlink" title="4. 无限期等待（Waiting）"></a>4. 无限期等待（Waiting）</h5><p>等待：当<strong>一个线程</strong>等待<strong>另一个线程</strong>通知调度器一个条件时，该线程进入<strong>等待状态</strong>。它的特点是<strong>需要等待另一个线程显式地唤醒自己，实现灵活，语义更丰富，可响应中断</strong>。例如调用：Object.wait()、Thread.join() 以及等待 Lock 或 Condition。</p>
<p>等待<strong>其它</strong>线程<strong>显式地==唤醒==</strong>，否则<strong>不会</strong>被分配 CPU 时间片。</p>
<table>
<thead>
<tr>
<th align="center">进入方法</th>
<th align="center">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>没有设置</strong> Timeout 参数的 Object.<strong>wait</strong>() 方法</td>
<td align="center">Object.<strong>notify</strong>() / Object.<strong>notifyAll</strong>()</td>
</tr>
<tr>
<td align="center">没有设置 Timeout 参数的 Thread.<strong>join</strong>() 方法</td>
<td align="center">被调用的线程<strong>执行完毕</strong></td>
</tr>
<tr>
<td align="center">LockSupport.<strong>park</strong>() 方法</td>
<td align="center">LockSupport.<strong>unpark</strong>(Thread)</td>
</tr>
</tbody></table>
<h5 id="5-限期等待（Timed-Waiting）"><a href="#5-限期等待（Timed-Waiting）" class="headerlink" title="5. 限期等待（Timed Waiting）"></a>5. 限期等待（Timed Waiting）</h5><p><strong>无需等待</strong>其它<strong>线程显式</strong>地唤醒，在一定<strong>时间</strong>之后会被<strong>系统自动唤醒</strong>。</p>
<table>
<thead>
<tr>
<th align="center">进入方法</th>
<th align="center">退出方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Thread.<strong>sleep</strong>() 方法</td>
<td align="center">时间结束</td>
</tr>
<tr>
<td align="center"><strong>设置</strong>了 <strong>Timeout</strong> 参数的 Object.<strong>wait</strong>() 方法</td>
<td align="center">时间<strong>结束</strong> / Object.<strong>notify</strong>() / Object.<strong>notifyAll</strong>()</td>
</tr>
<tr>
<td align="center"><strong>设置</strong>了 <strong>Timeout</strong> 参数的 Thread.<strong>join</strong>() 方法</td>
<td align="center">时间结束 / 被调用的线程<strong>执行完毕</strong></td>
</tr>
<tr>
<td align="center">LockSupport.<strong>parkNanos</strong>() 方法</td>
<td align="center">LockSupport.<strong>unpark</strong>(Thread)</td>
</tr>
<tr>
<td align="center">LockSupport.<strong>parkUntil</strong>() 方法</td>
<td align="center">LockSupport.<strong>unpark</strong>(Thread)</td>
</tr>
</tbody></table>
<h5 id="6-终结（Terminated）"><a href="#6-终结（Terminated）" class="headerlink" title="6. 终结（Terminated）"></a>6. 终结（Terminated）</h5><p>可以是线程结束任务之后<strong>自己结束</strong>，或者产生了<strong>异常</strong>而结束。</p>
<h5 id="7-问题总结"><a href="#7-问题总结" class="headerlink" title="7. 问题总结"></a>7. 问题总结</h5><p><strong>睡眠和挂起</strong>是用来描述<strong>行为</strong>，而<strong>阻塞和等待</strong>用来描述<strong>状态</strong>。</p>
<blockquote>
<p><strong>sleep与wait的区别？</strong></p>
</blockquote>
<ul>
<li><p>两者<strong>最主要</strong>的区别在于：<strong>sleep 方法没有释放锁，而 wait 方法释放了锁</strong>（释放了别的线程才能拿到锁）。</p>
</li>
<li><p><strong>所属对象</strong>：sleep 是 <strong>Thread 类</strong>的一个方法，而 wait 是属于 <strong>Object 类</strong>的方法。</p>
</li>
<li><p><strong>功能</strong>：两者都可以<strong>暂停</strong>线程的执行。wait 通常用于<strong>线程间交互/通信</strong>，sleep 通常用于<strong>暂停执行</strong>。</p>
</li>
<li><p><strong>特点</strong>：wait() 方法被调用后，线程<strong>不会自动苏醒</strong>，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程<strong>会自动苏醒</strong>。或者可以使用 wait(long timeout)超时后线程会自己唤醒。调用 Thread.<strong>sleep</strong>() 方法使线程进入限期等待状态时，常常用“<strong>使一个线程睡眠</strong>”进行描述。调用 Object.<strong>wait</strong>() 方法使线程进入限期等待或者无限期等待时，常常用“<strong>挂起一个线程”</strong>进行描述。</p>
</li>
</ul>
<blockquote>
<p><strong>阻塞与等待的区别？</strong></p>
</blockquote>
<p><strong>阻塞</strong>状态是<strong>等待锁</strong>。<strong>等待</strong>状态是等待<strong>被唤醒</strong>，或者等<strong>时间到。</strong></p>
<p><strong>阻塞和等待</strong>的区别在于，<strong>==阻塞是被动==</strong>的，它是在等待获取一个<strong>排它锁</strong>。而<strong>==等待是主动==</strong>的，通过调用 Thread.<strong>sleep</strong>() 和 Object.wait() 等方法进入。注意调用 <strong>sleep 方法是不会进入阻塞</strong>的，因为阻塞是等待获取锁，而 sleep 已经有锁了，所以 sleep 是进入等待状态。</p>
<blockquote>
<p><strong>锁与阻塞和等待的联系</strong>？</p>
</blockquote>
<p>虽然 synchronized 和 JUC 里的 Lock 都有锁的功能，但线程进入的<strong>状态</strong>是<strong>不一样</strong>的。<strong>synchronized 会让线程进入==阻塞==态，而 JUC 里的 Lock 是用 LockSupport.park()/unpark() 来实现阻塞/唤醒的，会让线程进入==等待态==</strong>。虽然等锁时进入的状态不一样，但被唤醒后又都进入 runnable 态，从行为效果来看又是一样的。</p>
<h4 id="创建与开启线程"><a href="#创建与开启线程" class="headerlink" title="创建与开启线程"></a>创建与开启线程</h4><p>创建与使用线程的方法：</p>
<ul>
<li>继承 <strong>Thread</strong> 类。</li>
<li>实现 <strong>Runnable</strong> 接口。</li>
<li>实现 <strong>Callable</strong> 接口。</li>
<li>使用<strong>线程池</strong>。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的<strong>任务</strong>，不是真正意义上的线程，因此最后还需要<strong>通过 Thread 来调用</strong>。可以说任务是通过线程驱动从而执行的。</p>
<h5 id="1-继承Thread类"><a href="#1-继承Thread类" class="headerlink" title="1. 继承Thread类"></a>1. 继承Thread类</h5><p>新的类需要<strong>继承</strong> Thread 类，并实现 <strong>run</strong>() 方法，因为 Thread 类<strong>实现了 Runable 接口</strong>。当调用 start() 方法启动一个线程时，虚拟机会将该线程放入<strong>就绪队列</strong>中等待<strong>被调度</strong>，当一个线程被调度时会执行该线程的 run() 方法。但是就<strong>不能再继承</strong>其他类了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-实现Runnable接口"><a href="#2-实现Runnable接口" class="headerlink" title="2. 实现Runnable接口"></a>2. 实现Runnable接口</h5><p>需要实现 <strong>run</strong>() 方法。<strong>没有返回值</strong>。Runnable 接口是函数式接口，多用 Lambda。需要通过 Thread 调用 <strong>start</strong>() 方法来启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    <span class="comment">// 传入接口方法</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-实现Callable接口"><a href="#3-实现Callable接口" class="headerlink" title="3. 实现Callable接口"></a>3. 实现Callable接口</h5><p>与 Runnable 相比，Callable <strong>可以有==返回值==</strong>，返回值通过 <strong>FutureTask</strong> 进行封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;	</span><br><span class="line">	<span class="comment">// 构造任务</span></span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    <span class="comment">// 通过FutureTask封装</span></span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="keyword">new</span> Thread(ft).start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-使用线程池"><a href="#4-使用线程池" class="headerlink" title="4. 使用线程池"></a>4. 使用线程池</h5><p>阿里推荐创建线程用自定义线程池，可以便于资源控制，详见线程池部分。</p>
<h5 id="5-方法对比"><a href="#5-方法对比" class="headerlink" title="5. 方法对比"></a>5. 方法对比</h5><p>对于继承类和实现接口而言，实现<strong>接口</strong>会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<p>如果需要有<strong>返回结果</strong>，则使用 Callable。</p>
<p>当然创建线程还是鼓励<strong>自定义线程池</strong>（阿里规范）。</p>
<h5 id="6-JVM线程创建"><a href="#6-JVM线程创建" class="headerlink" title="6. JVM线程创建"></a>6. JVM线程创建</h5><p>JVM 中创建线程有 2 种方式：</p>
<ul>
<li>new java.lang.<strong>Thread</strong>().start()。</li>
<li>使用 <strong>JNI</strong> 将一个 <strong>native thread</strong> attach 到 JVM 中。</li>
</ul>
<p><strong>针对 new java.lang.Thread().start()这种方式</strong>，只有<strong>调用 start() 方法</strong>的时候，才会真正的在 JVM 中去创建线程，主要的生命周期步骤有：</p>
<ul>
<li>创建对应的 JavaThread 的 instance。</li>
<li>创建对应的 OSThread 的 instance。</li>
<li>创建实际的底层操作系统的 native thread。</li>
<li>准备相应的 JVM 状态，比如 ThreadLocal 存储空间分配等。</li>
<li>底层的 native thread 开始运行，调用 java.lang.Thread 生成的 Object 的 run() 方法。</li>
<li>当 java.lang.Thread 生成的 Object 的 run() 方法执行完毕返回后,或者抛出异常终止后，终止 native thread。</li>
<li>释放 JVM 相关的 thread 的资源，清除对应的 JavaThread 和 OSThread。</li>
</ul>
<p><strong>针对 JNI 将一个 native thread attach 到 JVM 中</strong>，主要的步骤有：</p>
<ul>
<li>通过 JNI call AttachCurrentThread 申请连接到执行的 JVM 实例。</li>
<li>JVM 创建相应的 JavaThread 和 OSThread 对象。</li>
<li>创建相应的 java.lang.Thread 的对象。</li>
<li>一旦 java.lang.Thread 的 Object 创建之后，JNI 就可以调用 Java 代码了。</li>
<li>当通过 JNI call DetachCurrentThread 之后，JNI 就从 JVM 实例中断开连接。</li>
<li>JVM 除相应的 JavaThread, OSThread, java.lang.Thread 对象。</li>
</ul>
<h4 id="线程基本属性与方法"><a href="#线程基本属性与方法" class="headerlink" title="线程基本属性与方法"></a>线程基本属性与方法</h4><h5 id="1-优先级"><a href="#1-优先级" class="headerlink" title="1. 优先级"></a>1. 优先级</h5><p>每个线程都具有各自的<strong>优先级</strong>，如果有多个线程处于就绪状态，系统会根据优先级来决定首先使哪个线程进入运行状态。但这并不意味着低优先级的线程就一定在后面运行，而只是它运行的<strong>几率</strong>比较小，比如垃圾回收线程的优先级就较低。</p>
<p>Thread 类定义了一些线程的<strong>优先级</strong>属性，比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最低优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 默认优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 最高优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>其中每个线程的优先级都在<strong>Thread.MIN_PRIORITY~Thread.MAX_PRIORITY</strong> 之间，在默认情况下其优先级都是Thread.NORM_PRIORITY。每个新产生的线程都继承了父线程的优先级，优先级不会超过线程组的优先级。线程的优先级可以使用 <strong>setPriority</strong>() 方法进行设置。</p>
<h5 id="2-start"><a href="#2-start" class="headerlink" title="2. start()"></a>2. start()</h5><p>新开启一个线程执行其 <strong>run</strong>() 方法，一个线程<strong>只能 start 一次</strong>。主要是通过调用 <strong>native start0()</strong> 来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否首次启动</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">	<span class="comment">// 加入线程组</span></span><br><span class="line">    group.add(<span class="keyword">this</span>);</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Native方法启动线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用 <strong>start 方法方可启动线程并使线程进入就绪状态</strong>，而如果<strong>直接调用 run</strong> 方法则只是当做一个<strong>普通方法</strong>调用，还是在<strong>主线程</strong>里执行。</p>
<h5 id="3-run"><a href="#3-run" class="headerlink" title="3. run()"></a>3. run()</h5><p>run() 方法是<strong>不需要用户来调用</strong>的，当通过 start 方法启动一个线程之后，当该线程获得了 CPU 执行时间，便进入 run 方法体去执行具体的任务。注意，继承 Thread 类必须<strong>覆写</strong> run 方法，在 run 方法中定义具体要执行的任务。</p>
<p>有的<strong>题目</strong>套了个线程的壳子，但是<strong>调用的是 run 方法</strong>，而不是 start 方法，这样 run 方法只会在<strong>主线程</strong>执行而不是开一个线程。</p>
<h5 id="4-daemon"><a href="#4-daemon" class="headerlink" title="4. daemon()"></a>4. daemon()</h5><p><strong>守护线程</strong>是程序运行时在后台提供<strong>服务</strong>的线程，不属于程序中不可或缺的部分。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。使用 <strong>setDaemon</strong>() 方法将一个线程设置为<strong>守护线程</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);	<span class="comment">// 设置为守护线程</span></span><br><span class="line">    <span class="comment">// 必须在线程启动之前设置为守护线程</span></span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main() 属于非守护线程。</p>
<h5 id="5-sleep"><a href="#5-sleep" class="headerlink" title="5. sleep()"></a>5. sleep()</h5><p>Thread.<strong>sleep</strong>(millisec) 方法会<strong>休眠</strong>当前正在执行的线程，millisec 单位为<strong>毫秒</strong>。</p>
<p>sleep() 可能会抛出 <strong>InterruptedException</strong>，因为异常不能跨线程传播回 main() 中，因此必须在<strong>本地</strong>进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一点要非常注意，<strong>==sleep 方法不会释放锁==</strong>，也就是说如果当前线程持有对某个对象的锁，则即使调用 sleep 方法，其他线程也无法得到这个对象锁。</p>
<h5 id="6-yield"><a href="#6-yield" class="headerlink" title="6. yield()"></a>6. yield()</h5><p>对静态方法 Thread.<strong>yield</strong>() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以<strong>切换</strong>给其它线程来执行。该方法只是对线程调度器的一个<strong>建议</strong>，而且也只是建议其它线程可以运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 yield 方法会让当前线程<strong>交出 CPU 权限</strong>，让 CPU 去执行其他的线程。<strong>它跟 sleep 方法类似，同样==不会释放锁==</strong>。但是 yield 不能控制具体的交出 CPU 的时间，另外，yield 方法只能让拥有<strong>相同优先级</strong>的线程有获取 CPU 执行时间的机会。</p>
<p>注意，调用 yield 方法并<strong>不会让线程进入阻塞状态</strong>，而是让线程<strong>重回就绪状态</strong>，它只需要等待重新获取 CPU 执行时间。</p>
<h5 id="7-join"><a href="#7-join" class="headerlink" title="7. join()"></a>7. join()</h5><p>thread.join 的含义是<strong>当前线程</strong>需要等待 previousThread 线程终止之后才从 thread.join 返回。简单来说就是线程没有执行完之前，会一直阻塞在 join 方法处。所以可以用来保证线程的<strong>顺序性</strong>的。</p>
<p>join 方法有三个重载版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;	<span class="comment">// 参数为毫秒</span></span><br><span class="line"><span class="comment">// 第一参数为毫秒，第二个参数为纳秒</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis, <span class="keyword">int</span> nanos)</span></span>;</span><br></pre></td></tr></table></figure>

<p>第一个方法很简单，就是调用了第二个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    join(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>join</strong>() 实际是调用了 Object类的 <strong>wait</strong>()，只不过它<strong>不用等待 notify()/notifyAll()</strong>（因为 join 方法在调用 wait 方法时都设置了超时参数）。它结束的条件是：1）等待<strong>时间到</strong>；2）目标线程已经 <strong>run 完</strong>（通过 isAlive() 来判断）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0则需要一直等到目标线程run完</span></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="comment">// wait超时参数为0</span></span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果目标线程未run完且阻塞时间未到，那么调用线程会一直等待</span></span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// wait超时参数为delay</span></span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-suspend-resume"><a href="#8-suspend-resume" class="headerlink" title="8. suspend()/resume()"></a>8. suspend()/resume()</h5><p><strong>挂起</strong>线程，直到被 <strong>resume</strong>，才会<strong>苏醒</strong>。但调用 suspend( )的线程和调用 resume() 的线程，可能会因为<strong>争锁的问题而发生死锁</strong>，所以 JDK7 开始已经<strong>不推荐</strong>使用了。</p>
<h5 id="9-stop"><a href="#9-stop" class="headerlink" title="9. stop()"></a>9. stop()</h5><p>stop 方法<strong>已经废弃</strong>。不要用了。用 Thread.stop 来终止线程将<strong>释放它已经锁定的所有监视器</strong>（作为沿堆栈向上传播的未检查 ThreadDeath 异常的一个自然后果）。如果以前受这些监视器保护的任何对象都处于一种不一致的状态，则损坏的对象将对其他线程可见，这有可能<strong>导致线程不安全</strong>。</p>
<h4 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h4><p>线程中断即线程运行过程中被其他线程给打断了，它与 stop 最大的区别是：stop 是由<strong>系统强制</strong>终止线程，而线程中断则是给<strong>目标线程发送一个中断信号</strong>，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑<strong>由目标线程</strong>决定。</p>
<p>一个线程<strong>执行完毕</strong>之后会自动结束，如果在运行过程中<strong>发生异常</strong>也会提前结束。</p>
<p>来看下线程中断最重要的 3 个方法，它们都属于 <strong>Thread</strong> 类！</p>
<h5 id="1-interrupt"><a href="#1-interrupt" class="headerlink" title="1. interrupt()"></a>1. interrupt()</h5><p>中断目标线程，给目标线程发一个<strong>中断信号</strong>，线程被打上<strong>中断标记</strong>。源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">        checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">        Interruptible b = blocker;</span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            interrupt0();           <span class="comment">// 仅仅设置一下中断标志位</span></span><br><span class="line">            b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用native方法</span></span><br><span class="line">    interrupt0();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此操作会将线程的<strong>中断标志位置位</strong>，至于线程作何动作那得<strong>线程自己决定</strong>了。</p>
<ul>
<li>如果线程因为 sleep()、wait()、join() 等处于<strong>阻塞</strong>状态，那么线程会<strong>定时检查中断状态位</strong>如果发现中断状态位为 true，则会在这些阻塞方法调用处抛出 <strong>InterruptedException</strong> 异常，并且在抛出异常后<strong>立即将线程的中断状态位清除</strong>，即重新设置为 <strong>false</strong>。抛出异常是为了线程<strong>从阻塞状态醒过来</strong>，并在结束线程前让程序员有足够的时间来<strong>处理中断请求</strong>。</li>
<li>如果线程正在<strong>运行、争用</strong> synchronized、lock() 等，那么是<strong>不可中断</strong>的，它们会忽略。</li>
</ul>
<p>可以通过以下三种方式来<strong>判断中断</strong>：</p>
<ul>
<li><p>isInterrupted()：此方法只会读取线程的中断标志位，<strong>并不会重置</strong>。</p>
</li>
<li><p><strong>interrupted</strong>()：此方法读取线程的<strong>中断标志位</strong>，<strong>并会重置</strong>。</p>
</li>
<li><p>throw InterruptException：抛出该异常的同时，会重置中断标志位。</p>
</li>
</ul>
<h5 id="2-interrupted"><a href="#2-interrupted" class="headerlink" title="2. interrupted()"></a>2. interrupted()</h5><p>判断目标线程<strong>是否被中断，会清除中断标记</strong>。调用的是 native 方法并传入 true，<strong>会清除</strong>中断标记。注意这是一个静态方法。</p>
<p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个线程的 run() 方法执行一个<strong>无限循环</strong>，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就<strong>无法</strong>使线程提前结束。</p>
<p>但是调用 interrupt() 方法会<strong>设置</strong>线程的<strong>中断标记</strong>，此时调用 <strong>interrupted</strong>() 方法会<strong>返回 true</strong>。因此可以在<strong>循环体</strong>中使用 <strong>interrupted()</strong> 方法来判断线程<strong>是否处于中断状态</strong>，从而提前结束线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 判断中断标志来决定是否退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    <span class="comment">// 设置中断标志位，此时循环中判断中断标志位进而退出</span></span><br><span class="line">    thread2.interrupt();	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread end</span><br></pre></td></tr></table></figure>

<h5 id="3-isInterrupted"><a href="#3-isInterrupted" class="headerlink" title="3. isInterrupted()"></a>3. isInterrupted()</h5><p>isInterrupted() 是<strong>实例方法</strong>，是<strong>调用该方法的对象所表示的那个线程的 isInterrupted()</strong>，不会重置当前线程的中断状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接传入false</span></span><br><span class="line">    <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="4-InterruptedException"><a href="#4-InterruptedException" class="headerlink" title="4. InterruptedException"></a>4. InterruptedException</h5><p>调用一个线程的 <strong>interrupt()</strong> 来<strong>中断</strong>该线程，如果该线程处于<strong>阻塞、限期等待或者无限期等待</strong>状态，那么就会抛出 <strong>InterruptedException</strong>，从而提前结束该线程。但是<strong>==不能==中断 I/O 阻塞和 synchronized 锁阻塞</strong>。</p>
<p><strong>interrupt() 方法不会抛出 InterruptedException异常</strong>！InterruptedException 异常是由一些<strong>引起阻塞的方法</strong>抛出的！！并且，这些方法抛出异常后会重新<strong>清除中断标志</strong>！！！</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public final void <strong>join</strong>()</td>
<td align="center">如果任何线程<strong>中断</strong>了当前线程。当抛出该异常时，当前线程的中断状态<strong>被清除</strong></td>
</tr>
<tr>
<td align="center">public static void <strong>sleep</strong>()</td>
<td align="center">如果任何线程中断了当前线程。当抛出该异常时，当前线程的中断状态<strong>被清除</strong></td>
</tr>
<tr>
<td align="center">public final void <strong>wait</strong>()</td>
<td align="center">如果在当前线程等待通知之前或者正在等待通知时，任何线程<strong>中断</strong>了当前线程。在抛出此异常时，当前线程的中断<strong>状态被清除</strong></td>
</tr>
</tbody></table>
<p>以下代码在 main() 中启动一个线程之后再<strong>中断</strong>它，由于线程中调用了 Thread.<strong>sleep</strong>() 方法，因此会抛出一个 <strong>InterruptedException</strong>，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$0(InterruptExample.java:5)</span><br><span class="line">    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<h5 id="5-中断使用场景"><a href="#5-中断使用场景" class="headerlink" title="5. 中断使用场景"></a>5. 中断使用场景</h5><p>中断常见的使用场景有以下几个：</p>
<ul>
<li>点击某个桌面应用中的<strong>取消</strong>按钮时；</li>
<li>某个操作超过了一定的执行<strong>时间限制需要中止</strong>时；</li>
<li>多个线程做<strong>相同的</strong>事情，只要一个线程<strong>成功</strong>其它线程<strong>都可以取消</strong>时；</li>
<li>一组线程中的一个或多个出现错误<strong>导致整组都无法继续</strong>时；</li>
<li>当一个<strong>应用或服务需要停止</strong>时。</li>
</ul>
<h5 id="6-中断使用demo"><a href="#6-中断使用demo" class="headerlink" title="6. 中断使用demo"></a>6. 中断使用demo</h5><h6 id="1-demo1"><a href="#1-demo1" class="headerlink" title="(1) demo1"></a>(1) demo1</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Thread.yield();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	thread.start();</span><br><span class="line">    <span class="comment">// 发送中断信号</span></span><br><span class="line">	thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个线程<strong>不会被中断</strong>，因为虽然给线程发出了<strong>中断信号</strong>，但程序中<strong>并没有响应中断信号的逻辑</strong>，所以程序不会有任何反应。</p>
<h6 id="2-demo2"><a href="#2-demo2" class="headerlink" title="(2) demo2"></a>(2) demo2</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Thread.yield();</span><br><span class="line">			<span class="comment">// 加入中断标志位判断</span></span><br><span class="line">			<span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">"Java技术栈线程被中断，程序退出。"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	thread.start();</span><br><span class="line">    <span class="comment">// 发送中断信号</span></span><br><span class="line">	thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时线程中加上了<strong>响应中断的逻辑</strong>，程序接收到<strong>中断信号</strong>打印出信息后返回退出。</p>
<h6 id="3-demo3"><a href="#3-demo3" class="headerlink" title="(3) demo3"></a>(3) demo3</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 响应中断</span></span><br><span class="line">			<span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">"线程被中断程序退出"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				System.out.println(<span class="string">"线程休眠被中断程序退出"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	thread.start();</span><br><span class="line">	Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">	thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sleep() 方法<strong>被中断</strong>，并输出了<strong>线程休眠被中断程序退出</strong>。 程序<strong>继续运行</strong>……为什么？为 <strong>sleep</strong>() 方法被<strong>中断后会清除中断标记</strong>，所以循环会继续运行。</p>
<h6 id="4-demo4"><a href="#4-demo4" class="headerlink" title="(4) demo4"></a>(4) demo4</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 响应中断</span></span><br><span class="line">			<span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">"线程被中断程序退出"</span>);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				System.out.println(<span class="string">"线程休眠被中断程序退出"</span>);</span><br><span class="line">                <span class="comment">// 手动中断线程</span></span><br><span class="line">				Thread.currentThread().interrupt();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	thread.start();</span><br><span class="line">	Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">	thread.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>全部</strong>信息输出并<strong>正常退出</strong>，只是在 sleep() 方法被中断并清除标记后<strong>手动重新中断当前线程并设置中断标志位</strong>，然后程序接收中断信号返回退出。</p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在<strong>等待</strong>某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>产生死锁必须具备以下<strong>四个条件</strong>：</p>
<ol>
<li><strong>互斥条件</strong>：该资源任意一个时刻<strong>只由一个线程占用</strong>。</li>
<li><strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对<strong>已获得的资源保持不放</strong>。</li>
<li><strong>不剥夺条件</strong>：线程已获得的资源在末使用完之前<strong>不能被其他线程强行剥夺</strong>，只有自己使用完毕后才释放资源。</li>
<li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的<strong>循环等待资源关系</strong>。</li>
</ol>
<p>下图所示，线程 A 持有资源 2，线程 B 持有资源 1，它们<strong>同时都想申请对方的资源</strong>，所以这两个线程就会<strong>互相等待</strong>而进入死锁状态。</p>
<img src="assets/image-20200531144719675.png" alt="image-20200531144719675" style="zoom:67%;" />

<p>下面的例子模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource1 = <span class="keyword">new</span> Object(); <span class="comment">// 资源 1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resource2 = <span class="keyword">new</span> Object(); <span class="comment">// 资源 2</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 持有资源1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">                <span class="comment">// 等待1秒后才申请资源2</span></span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 持有资源2</span></span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"waiting get resource1"</span>);</span><br><span class="line">                <span class="comment">// 等待1秒后才申请资源1</span></span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"线程 2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]get resource1</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]get resource2</span><br><span class="line">Thread[线程 <span class="number">1</span>,<span class="number">5</span>,main]waiting get resource2</span><br><span class="line">Thread[线程 <span class="number">2</span>,<span class="number">5</span>,main]waiting get resource1</span><br></pre></td></tr></table></figure>

<p>线程 A 通过 synchronized (resource1) 获得 resource1 的<strong>监视器锁</strong>，然后通过<code>Thread.sleep(1000);</code>让线程 A 休眠 1s 为的是让线程 B 得到执行然后来得及获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始<strong>企图请求获取对方的资源</strong>，然后这两个线程就会陷入<strong>互相等待</strong>的状态，这也就产生了死锁。</p>
<h5 id="2-如何避免线程死锁"><a href="#2-如何避免线程死锁" class="headerlink" title="2. 如何避免线程死锁?"></a>2. 如何避免线程死锁?</h5><p>避免死锁只要破坏产生死锁的四个条件中的其中一个就可以了。</p>
<ol>
<li><strong>破坏互斥条件</strong> ：这个条件<strong>没有办法破坏</strong>，因为用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</li>
<li><strong>破坏请求与保持条件</strong>  ：一次性申请所有的资源。</li>
<li><strong>破坏不剥夺条件</strong> ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</li>
<li><strong>破坏循环等待条件</strong> ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</li>
</ol>
<p>这里对线程 2 的代码进行修改，这样就不会产生死锁了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"get resource1"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">"waiting get resource2"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">"get resource2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"线程 2"</span>).start();</span><br></pre></td></tr></table></figure>

<p>Output</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread[线程 1,5,main]get resource1</span><br><span class="line">Thread[线程 1,5,main]waiting get resource2</span><br><span class="line">Thread[线程 1,5,main]get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource1</span><br><span class="line">Thread[线程 2,5,main]waiting get resource2</span><br><span class="line">Thread[线程 2,5,main]get resource2</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure>

<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获<strong>取不到</strong>了而进行等待。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就<strong>破坏了破坏循环等待</strong>条件，因此避免了死锁。可见循环等待条件是非常容易打破的，只需要注意一下<strong>对资源的申请顺序</strong>就行。</p>
<h4 id="多线程开发良好的实践"><a href="#多线程开发良好的实践" class="headerlink" title="多线程开发良好的实践"></a>多线程开发良好的实践</h4><ul>
<li>给线程起个有意义的<strong>名字</strong>，这样可以方便找 Bug。</li>
<li>缩小<strong>同步范围</strong>，从而减少锁争用。例如对于 synchronized，应该<strong>尽量使用同步块</strong>而不是同步方法。</li>
<li>多用<strong>同步工具</strong>少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li>
<li>使用 BlockingQueue 实现<strong>生产者消费者</strong>问题。</li>
<li>多用<strong>并发容器</strong>少用同步容器，例如应该使用 ConcurrentHashMap 而不是 Hashtable。同步容器开销太大。</li>
<li>使用<strong>本地变量和不可变类</strong>来保证线程安全。</li>
<li>使用<strong>线程池</strong>而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/C-2%20JMM%E4%B8%8EVolatile/" rel="next" title="ShiftJava/A Java/C-2 JMM与Volatile">
                <i class="fa fa-chevron-left"></i> ShiftJava/A Java/C-2 JMM与Volatile
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/B-5%20%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="ShiftJava/A Java/B-5 集合面试题">
                ShiftJava/A Java/B-5 集合面试题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程基础"><span class="nav-number">1.</span> <span class="nav-text">线程基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本概念"><span class="nav-number">1.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-线程概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 线程概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-并发"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 并发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-什么是上下文切换"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 什么是上下文切换?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-并发与并行"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. 并发与并行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-任务类型"><span class="nav-number">1.1.5.</span> <span class="nav-text">5. 任务类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-CPU密集型"><span class="nav-number">1.1.5.1.</span> <span class="nav-text">(1) CPU密集型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-IO密集型"><span class="nav-number">1.1.5.2.</span> <span class="nav-text">(2) IO密集型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程状态转换"><span class="nav-number">1.2.</span> <span class="nav-text">线程状态转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-新建（New）"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 新建（New）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-可运行（Runnable）"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 可运行（Runnable）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-阻塞（Blocked）"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 阻塞（Blocked）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-无限期等待（Waiting）"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. 无限期等待（Waiting）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-限期等待（Timed-Waiting）"><span class="nav-number">1.2.5.</span> <span class="nav-text">5. 限期等待（Timed Waiting）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-终结（Terminated）"><span class="nav-number">1.2.6.</span> <span class="nav-text">6. 终结（Terminated）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-问题总结"><span class="nav-number">1.2.7.</span> <span class="nav-text">7. 问题总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#创建与开启线程"><span class="nav-number">1.3.</span> <span class="nav-text">创建与开启线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-继承Thread类"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 继承Thread类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-实现Runnable接口"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 实现Runnable接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-实现Callable接口"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 实现Callable接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-使用线程池"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 使用线程池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-方法对比"><span class="nav-number">1.3.5.</span> <span class="nav-text">5. 方法对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-JVM线程创建"><span class="nav-number">1.3.6.</span> <span class="nav-text">6. JVM线程创建</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程基本属性与方法"><span class="nav-number">1.4.</span> <span class="nav-text">线程基本属性与方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-优先级"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 优先级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-start"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. start()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-run"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. run()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-daemon"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. daemon()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-sleep"><span class="nav-number">1.4.5.</span> <span class="nav-text">5. sleep()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-yield"><span class="nav-number">1.4.6.</span> <span class="nav-text">6. yield()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-join"><span class="nav-number">1.4.7.</span> <span class="nav-text">7. join()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-suspend-resume"><span class="nav-number">1.4.8.</span> <span class="nav-text">8. suspend()/resume()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-stop"><span class="nav-number">1.4.9.</span> <span class="nav-text">9. stop()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程中断"><span class="nav-number">1.5.</span> <span class="nav-text">线程中断</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-interrupt"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. interrupt()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-interrupted"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. interrupted()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-isInterrupted"><span class="nav-number">1.5.3.</span> <span class="nav-text">3. isInterrupted()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-InterruptedException"><span class="nav-number">1.5.4.</span> <span class="nav-text">4. InterruptedException</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-中断使用场景"><span class="nav-number">1.5.5.</span> <span class="nav-text">5. 中断使用场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-中断使用demo"><span class="nav-number">1.5.6.</span> <span class="nav-text">6. 中断使用demo</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-demo1"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">(1) demo1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-demo2"><span class="nav-number">1.5.6.2.</span> <span class="nav-text">(2) demo2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-demo3"><span class="nav-number">1.5.6.3.</span> <span class="nav-text">(3) demo3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-demo4"><span class="nav-number">1.5.6.4.</span> <span class="nav-text">(4) demo4</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁"><span class="nav-number">1.6.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-如何避免线程死锁"><span class="nav-number">1.6.2.</span> <span class="nav-text">2. 如何避免线程死锁?</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多线程开发良好的实践"><span class="nav-number">1.7.</span> <span class="nav-text">多线程开发良好的实践</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
