<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] 消息队列面试题消息的高可用 如何保证消息队列的高可用？  1. RabbitMQ的高可用性RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。 RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。 (1) 单机模式单机模式，就是 Demo 级别的，没人生产用单机模式。 (2) 普">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;L 消息队列&#x2F;E 消息队列面试题">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;L%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&#x2F;E%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] 消息队列面试题消息的高可用 如何保证消息队列的高可用？  1. RabbitMQ的高可用性RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。 RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。 (1) 单机模式单机模式，就是 Demo 级别的，没人生产用单机模式。 (2) 普">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;L%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&#x2F;E%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;assets&#x2F;mq-7.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;L%20消息队列&#x2F;assets&#x2F;mq-8.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;L%20消息队列&#x2F;assets&#x2F;kafka-before.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;L%20消息队列&#x2F;assets&#x2F;kafka-after.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;L%20消息队列&#x2F;assets&#x2F;mq-10.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;L%20消息队列&#x2F;assets&#x2F;mq-11.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;L%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&#x2F;E%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;assets&#x2F;rabbitmq-message-lose.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;L%20消息队列&#x2F;assets&#x2F;rabbitmq-message-lose-solution.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;L%20消息队列&#x2F;assets&#x2F;rabbitmq-order-01.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;L%20消息队列&#x2F;assets&#x2F;kafka-order-01.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;L%20消息队列&#x2F;assets&#x2F;rabbitmq-order-02.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;L%20消息队列&#x2F;assets&#x2F;kafka-order-02.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;L%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97&#x2F;E%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;assets&#x2F;mq-7.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/L 消息队列/E 消息队列面试题/"/>





  <title>ShiftJava/L 消息队列/E 消息队列面试题 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/L%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/E%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/L 消息队列/E 消息队列面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:17+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="消息队列面试题"><a href="#消息队列面试题" class="headerlink" title="消息队列面试题"></a>消息队列面试题</h3><h4 id="消息的高可用"><a href="#消息的高可用" class="headerlink" title="消息的高可用"></a>消息的高可用</h4><blockquote>
<p><strong>如何保证消息队列的高可用？</strong></p>
</blockquote>
<h5 id="1-RabbitMQ的高可用性"><a href="#1-RabbitMQ的高可用性" class="headerlink" title="1. RabbitMQ的高可用性"></a>1. RabbitMQ的高可用性</h5><p>RabbitMQ 是比较有代表性的，因为是<strong>基于主从</strong>（非分布式）做高可用性的，就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么实现。</p>
<p>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。</p>
<h6 id="1-单机模式"><a href="#1-单机模式" class="headerlink" title="(1) 单机模式"></a>(1) 单机模式</h6><p>单机模式，就是 Demo 级别的，没人生产用单机模式。</p>
<h6 id="2-普通集群模式（无高可用性）"><a href="#2-普通集群模式（无高可用性）" class="headerlink" title="(2) 普通集群模式（无高可用性）"></a>(2) 普通集群模式（无高可用性）</h6><p>普通集群模式，意思就是在<strong>多台机器上启动多个 RabbitMQ 实例</strong>，每个机器启动一个。你<strong>创建的 queue，只会放在一个 RabbitMQ 实例上</strong>，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。</p>
<p><img src="assets/mq-7.png" alt="mq-7"></p>
<p>这种方式确实很麻烦，也不怎么好，<strong>没做到所谓的分布式</strong>，就是个普通集群。因为这导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有<strong>数据拉取的开销</strong>，后者导致<strong>单实例性能瓶颈</strong>。</p>
<p>而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你<strong>开启了消息持久化</strong>，让 RabbitMQ 落地存储消息的话，<strong>消息不一定会丢</strong>，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。</p>
<p>所以这个事儿就比较尴尬了，这就<strong>没有什么所谓的高可用性</strong>，<strong>这方案主要是提高吞吐量的</strong>，就是说让集群中多个节点来服务某个 queue 的读写操作。</p>
<h6 id="3-镜像集群模式（高可用性）"><a href="#3-镜像集群模式（高可用性）" class="headerlink" title="(3) 镜像集群模式（高可用性）"></a>(3) 镜像集群模式（高可用性）</h6><p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会<strong>存在于多个实例上</strong>，就是说，<strong>每个 RabbitMQ 节点都有这个 queue</strong> 的一个<strong>完整镜像</strong>，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把<strong>消息同步</strong>到<strong>多个实例</strong>的 queue 上。</p>
<img src="../../JavaNotes/L 消息队列/assets/mq-8.png" alt="mq-8" style="zoom:80%;" />

<p>那么<strong>如何开启这个镜像集群模式</strong>呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在<strong>后台新增一个策略</strong>，这个策略是<strong>镜像集群模式的策略</strong>，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会<strong>自动将数据同步到其他的节点</strong>上去了。</p>
<p>这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就<strong>没有扩展性可言</strong>了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并<strong>没有办法线性扩展</strong>你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？</p>
<h5 id="2-Kafka的高可用性"><a href="#2-Kafka的高可用性" class="headerlink" title="2. Kafka的高可用性"></a>2. Kafka的高可用性</h5><p>Kafka 一个最基本的架构认识：由<strong>多个 broker 组成</strong>，每个 broker 是<strong>一个节点</strong>；你创建一个 <strong>topic</strong>，这个 topic 可以划分为<strong>多个 partition</strong>，每个 partition 可以存在于<strong>不同的 broker</strong> 上，<strong>每个 partition 就放一部分数据</strong>。</p>
<p>这就是<strong>天然的分布式消息队列</strong>，就是说一个 topic 的数据，是<strong>分散放在多个机器上的，每个机器就放一部分数据</strong>。</p>
<p>实际上 RabbitMQ 之类的，并不是分布式消息队列，它就是<strong>传统的消息队列</strong>，只不过提供了一些集群、<strong>HA(High Availability, 高可用性) 的机制</strong>而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。</p>
<p><strong>Kafka 0.8 以前</strong>，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。</p>
<p>比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1/3 的数据就丢了，因此这个是做不到高可用的。</p>
<img src="../../JavaNotes/L 消息队列/assets/kafka-before.png" alt="kafka-before" style="zoom:80%;" />

<p>Kafka 0.8 以后，<strong>提供了 HA 机制</strong>，就是 <strong>replica（复制品） 副本机制</strong>。每个 partition 的数据都会同步到其它机器上，形成自己的<strong>多个 replica 副本</strong>。所有 replica 会<strong>选举一个 leader 出来</strong>，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把<strong>数据同步到所有 follower</strong> 上去，读的时候就直接读 leader 上的数据即可。<strong>只能读写 leader</strong>？很简单，<strong>要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题</strong>，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p>
<img src="../../JavaNotes/L 消息队列/assets/kafka-after.png" alt="kafka-after" style="zoom:80%;" />

<p>这么搞，就有所谓的<strong>高可用性</strong>了，因为如果某个 broker 宕机了，没事儿，那个 broker上面的 partition 在其他机器上都有<strong>副本</strong>的。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 <strong>follower</strong> 中<strong>重新选举</strong>一个新的 leader 出来，大家<strong>继续读写那个新的 leader 即可</strong>。这就有所谓的高可用性了。</p>
<p><strong>写数据</strong>的时候，生产者<strong>就写 leader</strong>，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己<strong>主动从 leader 来 pull 数据</strong>。一旦所有 follower 同步好数据了，就会<strong>发送 ack 给 leader</strong>，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p>
<p><strong>消费</strong>的时候，<strong>只会从 leader 去读</strong>，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p>
<p>看到这里，相信你大致明白了 Kafka 是如何保证高可用机制的了，对吧？不至于一无所知，现场还能给面试官画画图。要是遇上面试官确实是 Kafka 高手，深挖了问，那你只能说不好意思，太深入的你没研究过。</p>
<h4 id="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"><a href="#如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？" class="headerlink" title="如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"></a>如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</h4><p>其实这是很常见的一个问题，这俩问题基本可以连起来问。既然是消费消息，那肯定要考虑会不会重复消费？能不能避免重复消费？或者重复消费了也别造成系统异常可以吗？这个是 MQ 领域的基本问题，其实本质上还是问你<strong>使用消息队列如何保证幂等性</strong>，这个是你架构里要考虑的一个问题。</p>
<p>回答这个问题，首先你别听到重复消息这个事儿，就一无所知吧，你<strong>先大概说一说可能会有哪些重复消费的问题</strong>。</p>
<p>首先，比如 RabbitMQ、RocketMQ、Kafka，<strong>都有可能会出现消息重复消费</strong>的问题，正常。因为这问题通常不是 MQ 自己保证的，是由我们<strong>开发来保证</strong>的。挑一个 Kafka 来举个例子，说说怎么重复消费吧。</p>
<p>Kafka 实际上有个 <strong>offset</strong> 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，<strong>每隔一段时间</strong>（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p>
<p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p>
<p>举个栗子。</p>
<p>有这么个场景。数据 1/2/3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152/153/154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 <code>offset=153</code> 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1/2 的 offset 并没有提交，kafka 也就不知道你已经消费了 <code>offset=153</code> 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1/2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p>
<img src="../../JavaNotes/L 消息队列/assets/mq-10.png" alt="mq-10" style="zoom:80%;" />

<p>如果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1/2 在数据库里插入了 2 次，那么数据就错啦。</p>
<p>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，<strong>怎么保证幂等性</strong>。</p>
<p>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p>
<p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</p>
<p>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，<strong>不能出错</strong>。</p>
<p>所以第二个问题来了，怎么保证消息队列消费的幂等性？</p>
<p>其实还是得结合业务来思考，我这里给几个思路：</p>
<ul>
<li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li>
<li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li>
<li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
<li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li>
</ul>
<img src="../../JavaNotes/L 消息队列/assets/mq-11.png" alt="mq-11" style="zoom:80%;" />

<p>当然，如何保证 MQ 的消费是幂等性的，需要结合具体的业务来看。</p>
<h4 id="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"><a href="#如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？" class="headerlink" title="如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"></a>如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？</h4><p>这个是肯定的，用 MQ 有个基本原则，就是<strong>数据不能多一条，也不能少一条</strong>，<strong>不能多</strong>，就是前面说的<strong>重复消费和幂等性</strong>问题。<strong>不能少</strong>，就是说这数据别搞丢了。那这个问题你必须得考虑一下。</p>
<p>如果说你这个是用 MQ 来传递非常核心的消息，比如说<strong>计费、扣费</strong>的一些消息，那必须确保这个 MQ 传递过程中<strong>绝对不会把计费消息给弄丢</strong>。</p>
<p>数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下吧。</p>
<h5 id="1-RabbitMQ"><a href="#1-RabbitMQ" class="headerlink" title="1. RabbitMQ"></a>1. RabbitMQ</h5><p><img src="assets/rabbitmq-message-lose.png" alt="rabbitmq-message-lose"></p>
<h6 id="生产者弄丢了数据"><a href="#生产者弄丢了数据" class="headerlink" title="生产者弄丢了数据"></a>生产者弄丢了数据</h6><p>生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。</p>
<p>此时可以选择用 RabbitMQ 提供的事务功能，就是生产者<strong>发送数据之前</strong>开启 RabbitMQ 事务 <code>channel.txSelect</code> ，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 <code>channel.txRollback</code> ，然后重试发送消息；如果收到了消息，那么可以提交事务 <code>channel.txCommit</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">channel.txSelect</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 这里发送消息</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        channel.txRollback</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里再次重发这条消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">channel.txCommit</span><br></pre></td></tr></table></figure>

<p>但是问题是，RabbitMQ 事务机制（同步）一搞，基本上<strong>吞吐量会下来，因为太耗性能</strong>。</p>
<p>所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 <code>confirm</code> 模式，在生产者那里设置开启 <code>confirm</code> 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 <code>ack</code> 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 <code>nack</code> 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p>
<p>事务机制和 <code>confirm</code> 机制最大的不同在于，<strong>事务机制是同步的</strong>，你提交一个事务之后会<strong>阻塞</strong>在那儿，但是 <code>confirm</code> 机制是<strong>异步</strong>的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p>
<p>所以一般在生产者这块<strong>避免数据丢失</strong>，都是用 <code>confirm</code> 机制的。</p>
<h6 id="RabbitMQ弄丢了数据"><a href="#RabbitMQ弄丢了数据" class="headerlink" title="RabbitMQ弄丢了数据"></a>RabbitMQ弄丢了数据</h6><p>就是 RabbitMQ 自己弄丢了数据，这个你必须<strong>开启 RabbitMQ 的持久化</strong>，就是消息写入之后会持久化到<strong>磁盘</strong>，哪怕是 RabbitMQ 自己挂了，<strong>恢复之后会自动读取之前存储的数据</strong>，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，<strong>可能导致少量数据丢失</strong>，但是这个概率较小。</p>
<p>设置持久化有<strong>两个步骤</strong>：</p>
<ul>
<li>创建 queue 的时候将其设置为持久化。<br></li>
</ul>
<p>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</p>
<ul>
<li>第二个是发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2。<br></li>
</ul>
<p>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</p>
<p>必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p>
<p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p>
<p>所以，持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code> ，你也是可以自己重发的。</p>
<h6 id="消费端弄丢了数据"><a href="#消费端弄丢了数据" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h6><p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，<strong>刚消费到，还没处理，结果进程挂了</strong>，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p>
<p>这个时候得用 RabbitMQ 提供的 <strong><code>ack</code> 机制</strong>，简单来说，就是你必须关闭 RabbitMQ 的自动 <code>ack</code> ，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 <code>ack</code> 一把。这样的话，如果你还没处理完，不就没有 <code>ack</code> 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p>
<img src="../../JavaNotes/L 消息队列/assets/rabbitmq-message-lose-solution.png" alt="rabbitmq-message-lose-solution" style="zoom:80%;" />

<h5 id="2-Kafka"><a href="#2-Kafka" class="headerlink" title="2. Kafka"></a>2. Kafka</h5><h6 id="消费端弄丢了数据-1"><a href="#消费端弄丢了数据-1" class="headerlink" title="消费端弄丢了数据"></a>消费端弄丢了数据</h6><p>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边<strong>自动提交了 offset</strong>，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p>
<p>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要<strong>关闭自动提交</strong> offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是<strong>可能会有重复消费</strong>，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p>
<p>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p>
<h6 id="Kafka弄丢了数据"><a href="#Kafka弄丢了数据" class="headerlink" title="Kafka弄丢了数据"></a>Kafka弄丢了数据</h6><p>这块比较<strong>常见</strong>的一个场景，就是 Kafka <strong>某个 broker 宕机</strong>，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p>
<p>生产环境也遇到过，我们也是，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。</p>
<p>所以此时一般是<strong>要求起码设置如下 4 个参数</strong>：</p>
<ul>
<li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有<strong>至少 2 个副本</strong>。</li>
<li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li>
<li>在 producer 端设置 <code>acks=all</code> ：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li>
<li>在 producer 端设置 <code>retries=MAX</code> （很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li>
</ul>
<p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，<strong>进行 leader 切换</strong>时，数据不会丢失。</p>
<h6 id="生产者会不会弄丢数据？"><a href="#生产者会不会弄丢数据？" class="headerlink" title="生产者会不会弄丢数据？"></a>生产者会不会弄丢数据？</h6><p>如果按照上述的思路设置了 <code>acks=all</code> ，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，<strong>生产者会自动不断的重试，重试无限次</strong>。</p>
<h4 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h4><p>其实这个也是用 MQ 的时候必问的话题，第一看看你了不了解<strong>顺序</strong>这个事儿？第二看看你有没有办法保证消息是有顺序的？这是生产系统中常见的问题。</p>
<p>我举个例子，我们以前做过一个 mysql <code>binlog</code> 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p>
<p>你在 mysql 里增删改一条数据，对应出来了增删改 <strong>3 条 <code>binlog</code> 日志</strong>，接着这三条 <code>binlog</code> 发送到 MQ 里面，再消费出来依次执行，起码得<strong>保证人家是按照顺序</strong>来的吧？不然本来是：增加、修改、删除；你愣是换了顺序给执行成删除、修改、增加，不全错了么。本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p>
<h5 id="1-错乱场景"><a href="#1-错乱场景" class="headerlink" title="1. 错乱场景"></a>1. 错乱场景</h5><p>先看看顺序会错乱的俩场景：</p>
<ul>
<li><strong>RabbitMQ</strong>：一个 <strong>queue</strong>，<strong>多个 consumer</strong>。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个<strong>内存队列</strong>。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者 2 先执行完操作，把 data2 存入数据库，然后是 data1/data3。这不明显乱了。</li>
</ul>
<img src="../../JavaNotes/L 消息队列/assets/rabbitmq-order-01.png" alt="rabbitmq-order-01" style="zoom:80%;" />

<ul>
<li><strong>Kafka</strong>：比如说我们建了一个 <strong>topic</strong>，有三个 <strong>partition</strong>。生产者在写的时候，其实可以<strong>指定一个 key</strong>，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 <strong>partition</strong> 中去，而且这个 partition 中的数据一定是有顺序的。<br>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞<strong>多个线程来并发处理消息</strong>。因为如果<strong>消费者是单线程消费处理</strong>，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而<strong>多个线程并发跑的话，顺序可能就乱掉了</strong>。</li>
</ul>
<img src="../../JavaNotes/L 消息队列/assets/kafka-order-01.png" alt="kafka-order-01" style="zoom: 80%;" />

<h5 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h5><h6 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h6><p><strong>拆分多个 queue，每个 queue 一个 consumer</strong>，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p>
<img src="../../JavaNotes/L 消息队列/assets/rabbitmq-order-02.png" alt="rabbitmq-order-02" style="zoom:80%;" />

<h6 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h6><ul>
<li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li>
<li><strong>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</strong></li>
</ul>
<img src="../../JavaNotes/L 消息队列/assets/kafka-order-02.png" alt="kafka-order-02" style="zoom:80%;" />



<h4 id="消息队列的延时以及过期失效"><a href="#消息队列的延时以及过期失效" class="headerlink" title="消息队列的延时以及过期失效"></a>消息队列的延时以及过期失效</h4><blockquote>
<p><strong>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</strong></p>
</blockquote>
<p>你看这问法，其实本质针对的场景，都是说，可能你的消费端出了问题，不消费了；或者消费的速度极其慢。接着就坑爹了，可能你的消息队列集群的磁盘都快写满了，都没人消费，这个时候怎么办？或者是这整个就积压了几个小时，你这个时候怎么办？或者是你积压的时间太长了，导致比如 RabbitMQ 设置了消息过期时间后就没了怎么办？</p>
<p>所以就这事儿，其实线上挺常见的，一般不出，一出就是大 case。一般常见于，举个例子，消费端每次消费之后要写 mysql，结果 mysql 挂了，消费端 hang 那儿了，不动了；或者是消费端出了个什么岔子，导致消费速度极其慢。</p>
<p>关于这个事儿，我们一个一个来梳理吧，先假设一个场景，我们现在消费端出故障了，然后大量消息在 mq 里积压，现在出事故了，慌了。</p>
<h5 id="1-大量消息在MQ里积压了几个小时了还没解决"><a href="#1-大量消息在MQ里积压了几个小时了还没解决" class="headerlink" title="1. 大量消息在MQ里积压了几个小时了还没解决"></a>1. 大量消息在MQ里积压了几个小时了还没解决</h5><p>几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上 11 点多。这个时候要不然就是修复 consumer 的问题，让它恢复消费速度。</p>
<p>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。</p>
<p>一般这个时候，只能<strong>临时紧急扩容</strong>了，具体操作步骤和思路如下：</p>
<ul>
<li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li>
<li>新建一个 topic，<strong>partition 是原来的 10 倍</strong>，临时建立好原先 10 倍的 queue 数量。</li>
<li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li>
<li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li>
<li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li>
</ul>
<h5 id="2-MQ中的消息过期失效了"><a href="#2-MQ中的消息过期失效了" class="headerlink" title="2. MQ中的消息过期失效了"></a>2. MQ中的消息过期失效了</h5><p>假设用的是 RabbitMQ，RabbtiMQ 是<strong>可以设置过期时间</strong>的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个<strong>数据就没</strong>了。那这就是第二个坑了。这就不是说数据会大量积压在 MQ 里，而是<strong>大量的数据会直接搞丢</strong>。</p>
<p>这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。可以采取一个方案，就是<strong>批量重导</strong>。就是大量积压的时候，当时就直接丢弃数据了，然后等过了高峰期以后。这个时候就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</p>
<p>假设 <strong>1 万个订单积压在 mq 里面</strong>，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p>
<h5 id="3-MQ都快写满了"><a href="#3-MQ都快写满了" class="headerlink" title="3. MQ都快写满了"></a>3. MQ都快写满了</h5><p>如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，<strong>消费一个丢弃一个，都不要了</strong>，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p>
<h4 id="如何设计一个消息队列"><a href="#如何设计一个消息队列" class="headerlink" title="如何设计一个消息队列"></a>如何设计一个消息队列</h4><blockquote>
<p>如果让你写一个消息队列，该如何进行架构设计？说一下你的思路。</p>
</blockquote>
<p>其实聊到这个问题，一般面试官要考察两块：</p>
<ul>
<li>你有没有对某一个消息队列做过较为深入的原理的了解，或者从整体了解把握住一个消息队列的<strong>架构原理</strong>。</li>
<li>看看你的设计能力，给你一个常见的系统，就是消息队列系统，看看你能不能从全局把握一下整体架构设计，给出一些关键点出来。</li>
</ul>
<p>说实话，问类似问题的时候，大部分人基本都会蒙，因为平时从来没有思考过类似的问题，<strong>大多数人就是平时埋头用，从来不去思考背后的一些东西</strong>。类似的问题，比如，如果让你来设计一个 Spring 框架你会怎么做？如果让你来设计一个 Dubbo 框架你会怎么做？如果让你来设计一个 MyBatis 框架你会怎么做？</p>
<p>其实回答这类问题，说白了，不求你看过那技术的源码，起码你要大概知道那个技术的基本原理、核心组成部分、基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好。</p>
<p>比如说这个消息队列系统，我们从以下<strong>几个角度</strong>来考虑一下：</p>
<ul>
<li><p>首先这个 mq 得支持<strong>可伸缩性</strong>吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个<strong>分布式的系统</strong>呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</p>
</li>
<li><p>其次你得考虑一下这个 mq 的<strong>数据要不要落地磁盘</strong>吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</p>
</li>
<li><p>其次你考虑一下你的 <strong>mq 的可用性</strong>啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</p>
</li>
<li><p><strong>能不能支持数据 0 丢失</strong>啊？可以的，参考我们之前说的那个 kafka 数据<strong>零丢失方案</strong>。</p>
</li>
</ul>
<p>mq 肯定是很复杂的，面试官问你这个问题，其实是个开放题，他就是看看你有没有从架构角度整体构思和设计的思维以及能力。确实这个问题可以刷掉一大批人，因为大部分人平时不思考这些东西。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/L%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/A%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/" rel="next" title="ShiftJava/L 消息队列/A 消息队列概述">
                <i class="fa fa-chevron-left"></i> ShiftJava/L 消息队列/A 消息队列概述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/M%20RPC/A%20RPC/" rel="prev" title="ShiftJava/M RPC/A RPC">
                ShiftJava/M RPC/A RPC <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#消息队列面试题"><span class="nav-number">1.</span> <span class="nav-text">消息队列面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#消息的高可用"><span class="nav-number">1.1.</span> <span class="nav-text">消息的高可用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-RabbitMQ的高可用性"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. RabbitMQ的高可用性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-单机模式"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">(1) 单机模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-普通集群模式（无高可用性）"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">(2) 普通集群模式（无高可用性）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-镜像集群模式（高可用性）"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">(3) 镜像集群模式（高可用性）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Kafka的高可用性"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. Kafka的高可用性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？"><span class="nav-number">1.2.</span> <span class="nav-text">如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？"><span class="nav-number">1.3.</span> <span class="nav-text">如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-RabbitMQ"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#生产者弄丢了数据"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">生产者弄丢了数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#RabbitMQ弄丢了数据"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">RabbitMQ弄丢了数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#消费端弄丢了数据"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">消费端弄丢了数据</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Kafka"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. Kafka</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#消费端弄丢了数据-1"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">消费端弄丢了数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Kafka弄丢了数据"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">Kafka弄丢了数据</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#生产者会不会弄丢数据？"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">生产者会不会弄丢数据？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何保证消息的顺序性？"><span class="nav-number">1.4.</span> <span class="nav-text">如何保证消息的顺序性？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-错乱场景"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 错乱场景</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-解决方案"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#RabbitMQ"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">RabbitMQ</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Kafka"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">Kafka</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息队列的延时以及过期失效"><span class="nav-number">1.5.</span> <span class="nav-text">消息队列的延时以及过期失效</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-大量消息在MQ里积压了几个小时了还没解决"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. 大量消息在MQ里积压了几个小时了还没解决</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-MQ中的消息过期失效了"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. MQ中的消息过期失效了</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-MQ都快写满了"><span class="nav-number">1.5.3.</span> <span class="nav-text">3. MQ都快写满了</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何设计一个消息队列"><span class="nav-number">1.6.</span> <span class="nav-text">如何设计一个消息队列</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
