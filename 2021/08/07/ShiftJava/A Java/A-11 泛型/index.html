<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] 泛型基础1. 杂记 泛型可有泛型类、泛型方法、泛型接口。 泛型方法的返回类型之前是==类型参数==，可以对类型参数进行限定。如 &amp;lt;T extends Comparable&amp;gt;。 通配符 ？ 代表的就是类型未知，所以限制更多。 编译期进行泛型类型擦除会把类型变量替换为相应的限定类型。 泛型的诸多限制多半是由类型擦除造成的。  2. 泛型概述泛型的本质是参数实例化，解决不确定具体">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;A Java&#x2F;A-11 泛型">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;A-11%20%E6%B3%9B%E5%9E%8B&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] 泛型基础1. 杂记 泛型可有泛型类、泛型方法、泛型接口。 泛型方法的返回类型之前是==类型参数==，可以对类型参数进行限定。如 &amp;lt;T extends Comparable&amp;gt;。 通配符 ？ 代表的就是类型未知，所以限制更多。 编译期进行泛型类型擦除会把类型变量替换为相应的限定类型。 泛型的诸多限制多半是由类型擦除造成的。  2. 泛型概述泛型的本质是参数实例化，解决不确定具体">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/A Java/A-11 泛型/"/>





  <title>ShiftJava/A Java/A-11 泛型 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/A%20Java/A-11%20%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/A Java/A-11 泛型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="1-杂记"><a href="#1-杂记" class="headerlink" title="1. 杂记"></a>1. 杂记</h5><ul>
<li>泛型可有泛型<strong>类</strong>、泛型<strong>方法</strong>、泛型<strong>接口</strong>。</li>
<li>泛型方法的返回类型之前是==<strong>类型参数</strong>==，可以对类型参数进行<strong>限定</strong>。如 <strong>&lt;T extends Comparable&gt;</strong>。</li>
<li>通配符 ？ 代表的就是类型未知，所以限制更多。</li>
<li>编译期进行泛型<strong>类型擦除</strong>会把<strong>类型变量</strong>替换为相应的<strong>限定类型</strong>。</li>
<li>泛型的诸多限制多半是由<strong>类型擦除</strong>造成的。</li>
</ul>
<h5 id="2-泛型概述"><a href="#2-泛型概述" class="headerlink" title="2. 泛型概述"></a>2. 泛型概述</h5><p><strong>泛型的本质是参数实例化，解决不确定具体对象类型的问题。</strong>泛型只是一种编写代码时的语法检查。</p>
<p>使用泛型可以让编译器对<strong>类型进行检查</strong>，避免<strong>插入错误类型</strong>的对象。它提供了<strong>编译期的类型安全</strong>，确保你只能把<strong>正确类型</strong>的对象放入集合中，避免了在运行时出现 <strong>ClassCastException</strong>。</p>
<p>泛型只在<strong>编译阶段</strong>有效而不会进入到运行时阶段。在<strong>编译过程</strong>中，正确<strong>检验泛型结果</strong>后，会将泛型的相关信息<strong>擦除</strong>，并且在对象进入和离开方法的边界处<strong>添加类型检查和类型转换</strong>的方法。</p>
<p><strong>使用泛型的好处</strong>：<strong>安全性、可读性、代码重用</strong>。安全性是指编译器会帮检测类型错误，使类型安全；可读是指编码的时候直接就知道集合里面是什么类型；代码重用是指泛型合并了同类型的处理代码。</p>
<p><strong>泛型的本质是==类型参数化==</strong>，也就是所操作的<strong>数据类型被指定为一个参数</strong>。</p>
<h5 id="3-泛型基本用法"><a href="#3-泛型基本用法" class="headerlink" title="3. 泛型基本用法"></a>3. 泛型基本用法</h5><h6 id="1-泛型类"><a href="#1-泛型类" class="headerlink" title="(1) 泛型类"></a>(1) 泛型类</h6><p>一个泛型类就是具有一个或多个<strong>类型变量</strong>的类。泛型的类型参数只能是<strong>引用类型</strong>，不能是基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 泛型类</span></span><br><span class="line"><span class="comment"> * Java库中E表示集合的元素类型，K和V分别表示表的关键字与值的类型</span></span><br><span class="line"><span class="comment"> * T（需要时还可以用临近的字母U和S）表示“任意类型”</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T first;</span><br><span class="line">    <span class="keyword">private</span> T second;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123;first = <span class="keyword">null</span>; second = <span class="keyword">null</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.first = first;  <span class="keyword">this</span>.second = second; </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getFirst</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> first;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getSecond</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> second;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirst</span><span class="params">(T newValue)</span> </span>&#123;first = newValue;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSecond</span><span class="params">(T newValue)</span> </span>&#123;second = newValue;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个类型变量的泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;</span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>用<strong>具体的类型替换类型变量</strong>就可以<strong>实例化</strong>泛型类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairTest1</span> </span>&#123;        <span class="comment">// 测试类</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>   </span>&#123;</span><br><span class="line">      String[] words = &#123; <span class="string">"Mary"</span>, <span class="string">"had"</span>, <span class="string">"a"</span>, <span class="string">"little"</span>, <span class="string">"lamb"</span> &#125;;</span><br><span class="line">      Pair&lt;String&gt; mm = ArrayAlg.minmax(words);</span><br><span class="line">      System.out.println(<span class="string">"min = "</span> + mm.getFirst());</span><br><span class="line">      System.out.println(<span class="string">"max = "</span> + mm.getSecond());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span></span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Gets the minimum and maximum of an array of strings.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a an array of strings</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a pair with the min and max value, or null if a is null or empty</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Pair&lt;String&gt; <span class="title">minmax</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      String min = a[<span class="number">0</span>];</span><br><span class="line">      String max = a[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)      &#123;</span><br><span class="line">         <span class="keyword">if</span> (min.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i];</span><br><span class="line">         <span class="keyword">if</span> (max.compareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(min, max);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义的泛型类，就<strong>一定要传入泛型类型实参么</strong>？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做<strong>相应的限制</strong>，此时泛型才会起到本应起到的<strong>限制作用</strong>。如果<strong>不传入泛型类型实参</strong>的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为<strong>任何的类型</strong>。</p>
<h6 id="2-泛型方法"><a href="#2-泛型方法" class="headerlink" title="(2) 泛型方法"></a>(2) 泛型方法</h6><p>一个方法是不是泛型的，与其所在的<strong>类</strong>是不是泛型的<strong>没有</strong>关系。泛型方法也可以定义在<strong>普通类</strong>里面。</p>
<p>可以定义带有==<strong>类型参数</strong>==的方法。调用泛型方法时，在<strong>方法名前的尖括号</strong>中放人具体的类型。</p>
<p><strong>重要★</strong>：==<strong>&lt;T&gt;</strong>是<strong>类型参数</strong>，<strong>T 是返回类型</strong>==，类型参数放在<strong>返回值之前</strong>。<strong>&lt;T extends Comparable&gt;</strong> 也是<strong>类型参数</strong>，限定<strong>传入的类型</strong>。</p>
<p>与泛型类不同，调用方法时一般不需要特意指定类型参数的实际类型， 一般 Java 编译器可以<strong>自动推断</strong>出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不是泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayAlg</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &lt;T&gt;是类型参数，T 是返回类型，参数为类型T的不定数目参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getMiddle</span><span class="params">(T... a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[a.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// &lt;T extends Comparable&gt;是类型参数，控制传入的参数类型，T是返回类型</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>&#123;...&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// &lt;T&gt;是类型参数，返回类型为int</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(T[] arr, T elm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i].equals(elm)) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用泛型方法 注意下面的写法</span></span><br><span class="line">String middle = ArrayAlg.&lt;String&gt;getMiddle(<span class="string">"]ohnM"</span>, <span class="string">"Test"</span>, <span class="string">"Public"</span>);</span><br><span class="line"><span class="comment">// 省略类型参数</span></span><br><span class="line">String middle = ArrayAlg.getMiddle(<span class="string">"]ohnM"</span>, <span class="string">"Test"</span>, <span class="string">"Public"</span>);</span><br></pre></td></tr></table></figure>

<h6 id="3-泛型接口"><a href="#3-泛型接口" class="headerlink" title="(3) 泛型接口"></a>(3) 泛型接口</h6><p><strong>接口</strong>也可以是泛型的，如下。使用时需要指定<strong>具体的类型</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Integer bookPage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compare(<span class="keyword">this</span>.bookpage, anotherBook.bookPage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-类型参数"><a href="#4-类型参数" class="headerlink" title="4. 类型参数"></a>4. 类型参数</h5><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="(1) 概述"></a>(1) 概述</h6><p>泛型方法声明方式：<strong>访问修饰符 &lt;T,K,S…&gt; 返回类型 方法名(方法参数) {方法体}</strong>。访问修饰符与返回类型中间的 <strong>&lt;T,K,S…&gt;</strong> 等就是属于<strong>类型参数</strong>。</p>
<p>在泛型中，如果不对类型参数加以限制，它就可以<strong>接受任意的</strong>数据类型，只要它是被定义过的。但很多时候我们只需要一部分数据类型就够了，用户传递其他数据类型可能会引起错误。<strong>类型参数</strong>能够限定类型<strong>必须实现某些接口或者继承某个类</strong>。</p>
<h6 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="(2) 基本使用"></a>(2) 基本使用</h6><p>类型参数上界可以是<strong>类或接口</strong>，此时 <strong>T</strong> 必须<strong>实现</strong>这个接口或者继承这个类。如果有多个类型变量和多个限定类型，限定类型用 <strong>&amp; 分隔</strong>，类型变量用<strong>逗号分隔</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限定min方法只能被实现了Comparab1e接口的类调用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">T <span class="title">min</span><span class="params">(T[] a)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>如果用一个<strong>类作为限定</strong>，它必须是限定列表中的<strong>第一个</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个限定类型，且Students类为第一个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Students &amp; Comparab1e &amp; Serializable&gt; <span class="function">Pair&lt;T&gt; <span class="title">min</span><span class="params">(T[] a)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法 &lt;T extends Comparable&gt; 为类型限定参数  Pair&lt;T&gt; 为返回类型  T[]为入参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; <span class="function">Pair&lt;T&gt; <span class="title">minmax</span><span class="params">(T[] a)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (a == <span class="keyword">null</span> || a.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      T min = a[<span class="number">0</span>];</span><br><span class="line">      T max = a[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (min.compareTo(a[i]) &gt; <span class="number">0</span>) min = a[i];</span><br><span class="line">         <span class="keyword">if</span> (max.compareTo(a[i]) &lt; <span class="number">0</span>) max = a[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(min, max);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>除了用 &lt;T&gt; 表示泛型外，还有 <strong>&lt;?&gt;</strong> 这种形式。<strong>？</strong> 被称为<strong>通配符</strong>。既然已经有了 &lt;T&gt; 的形式了，为什么还要引进 &lt;?&gt; 这样的概念呢？在现实编码中可能希望泛型能够<strong>处理某一范围内的数据类型</strong>，比如<strong>某个类和它的子类</strong>，对此 Java 引入了通配符这个概念。<strong>通配符的出现是为了指定泛型中的类型范围</strong>。</p>
<p>举个栗子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;&#125;	<span class="comment">// 父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;	<span class="comment">// 子类</span></span><br><span class="line"></span><br><span class="line">Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">Base base = sub;</span><br></pre></td></tr></table></figure>

<p>上面代码显示，Base 是 Sub 的<strong>父类</strong>，它们之间是<strong>继承关系</strong>，所以 Sub 的实例可以给一个 Base 引用赋值，但是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Sub&gt; lsub = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Base&gt; lbase = lsub;</span><br></pre></td></tr></table></figure>

<p>上述第二行是不行的，<strong>编译通不过</strong>。Sub 是 Base 的子类，<strong>不代表 List&lt;Sub&gt; 和 List&lt;Base&gt; 有继承关系</strong>。Java 中<strong>集合是==不能协变==</strong>的，也就是说 List&lt;Base&gt; 不是 List&lt;Sub&gt; 的父类，这时候就可以用到<strong>通配符</strong>了。</p>
<h5 id="2-通配符分类"><a href="#2-通配符分类" class="headerlink" title="2. 通配符分类"></a><strong>2. 通配符分类</strong></h5><p>通配符主要有以下三类：</p>
<ul>
<li><strong>无边界的通配符</strong>：就是 ==<strong>&lt;?&gt;</strong>==, 比如 <strong>List&lt;?&gt;</strong>。无边界的通配符的主要作用就是让<strong>泛型能够接受==未知类型==</strong>的数据。</li>
<li><strong>固定上边界</strong>的通配符：使用<strong>固定上边界</strong>的通配符的泛型, 就能够接受<strong>指定类及其子类类型</strong>的数据。要声明使用该类通配符, 采用 ==<strong>&lt;? extends E&gt; *<em>== 的形式，这里的 *</em>E</strong> 就是该泛型的<strong>上边界</strong>。注意：这里虽然用的是 <strong>extends</strong> 关键字, 却不仅限于继承了父类 E 的子类, 也可以代指实现了<strong>接口</strong> E 的<strong>类</strong>。</li>
<li><strong>固定下边界</strong>的通配符：使用<strong>固定下边界</strong>的通配符的泛型, 就能够接受<strong>指定类及其父类类型</strong>的数据。要声明使用该类通配符, 采用 ==<strong>&lt;? super E&gt;</strong>== 的形式, 这里的 <strong>E</strong> 就是该泛型的<strong>下边界</strong>。</li>
</ul>
<p>注意：你可以为一个泛型指定上边界或下边界, 但是<strong>不能同时</strong>指定上下边界。</p>
<h5 id="3-基本使用方法"><a href="#3-基本使用方法" class="headerlink" title="3. 基本使用方法"></a>3. 基本使用方法</h5><h6 id="1-无边界通配符的使用"><a href="#1-无边界通配符的使用" class="headerlink" title="(1) 无边界通配符的使用"></a>(1) 无边界通配符的使用</h6><p>以在集合 List 中使用 <strong>&lt;?&gt;</strong> 为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printList</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">        <span class="comment">// 这里只是读取集合元素</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; l1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    l1.add(<span class="string">"aa"</span>);</span><br><span class="line">    l1.add(<span class="string">"bb"</span>);</span><br><span class="line">    l1.add(<span class="string">"cc"</span>);</span><br><span class="line">    printList(l1);</span><br><span class="line">    List&lt;Integer&gt; l2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    l2.add(<span class="number">11</span>);</span><br><span class="line">    l2.add(<span class="number">22</span>);</span><br><span class="line">    l2.add(<span class="number">33</span>);</span><br><span class="line">    printList(l2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种使用 <strong>List&lt;?&gt;</strong> 的方式就是<strong>父类引用指向子类对象</strong>。注意，这里的 printList 方法<strong>不能写成</strong> public static void printList(List&lt;<strong>Object</strong>&gt; list) 的形式, 虽然 Object 类是所有类的父类，但是 List&lt;Object&gt; 跟其他泛型的 List 如 List&lt;String&gt;，List&lt;Integer&gt; <strong>不存在</strong>继承关系，因此会报错。</p>
<p><strong>问号  ？ 表示类型安全未知，即只能读不能写</strong>。</p>
<p>所以<strong>不能对 List&lt;?&gt; 使用 add 方法（单使用 ？只读，不能修改了）, 仅有一个例外, 就是 add(null)</strong>。因为我们<strong>不确定</strong>该 List 的类型，不知道 add 什么类型的数据才对，只有 null 是所有引用数据类型都<strong>具有</strong>的元素。</p>
<p>请看下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">// list.add(o); // 编译报错</span></span><br><span class="line">    <span class="comment">// list.add(1); // 编译报错</span></span><br><span class="line">    <span class="comment">// list.add("ABC"); // 编译报错</span></span><br><span class="line">    list.add(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有，<strong>List&lt;?&gt; 也不能使用 get 方法, 只有 Object 类型是个例外</strong>。原因也很简单, 因为我们不知道传入的 List 是什么泛型的, 所以无法接受得到的 get, 但是 <strong>Object</strong> 是所有数据类型的父类，所以可以用于接受数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTest</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// String s = list.get(0);  // 编译报错</span></span><br><span class="line">    <span class="comment">// Integer i = list.get(1); // 编译报错</span></span><br><span class="line">    Object o = list.get(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不是有<strong>强制类型转换</strong>么? 但是我们根本<strong>不知道</strong>会传入什么类型，比如我们将其强转为 String，编译是通过了, 但是如果传入个 Integer 泛型的 List，一运行还会出错。那么保证传入的 String 类型的数据不就好了么? 那样是没问题了, 但是那还用 &lt;?&gt; 干嘛? 直接 List&lt;String&gt; 就行了。</p>
<h6 id="2-固定上边界通配符的使用"><a href="#2-固定上边界通配符的使用" class="headerlink" title="(2) 固定上边界通配符的使用"></a>(2) 固定上边界通配符的使用</h6><p> 仍以 List 为例来说明。它失去了<strong>写操作</strong>的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sumOfList</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> s = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Number n : list) &#123;</span><br><span class="line">        <span class="comment">// 注意这里得到的n是其上边界类型的, 也就是Number, 需要将其转换为double.</span></span><br><span class="line">        s += n.doubleValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list1 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(sumOfList(list1));</span><br><span class="line">    List&lt;Double&gt; list2 = Arrays.asList(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>);</span><br><span class="line">    System.out.println(sumOfList(list2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>List&lt;? extends E&gt; 不能使用 add 方法（也就是前面的例子中 extends 只读不能修改！）</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addTest2</span><span class="params">(List&lt;? extends Number&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// l.add(1);   // 编译报错</span></span><br><span class="line">    <span class="comment">// l.add(1.1); // 编译报错</span></span><br><span class="line">    l.add(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因很简单，泛型 <strong>&lt;? extends E&gt;</strong> 指的是 <strong>E 及其子类</strong>，这里传入的可能是 Integer，也可能是 Double，但是在写这个方法时<strong>不能确定传入什么类型的数据</strong>，如果我们调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">addTest(list);</span><br></pre></td></tr></table></figure>

<p>那么我们之前写的 add(1.1) 就会出错，反之亦然，所以<strong>除了 null 之外什么也不能 add</strong>。==但是 <strong>get 的时候是可以得到一个 Number</strong>，也就是<strong>上边界类型</strong>的数据的，因为不管存入什么数据类型都是 Number 的<strong>子类型</strong>==，得到这些就是一个<strong>父类引用指向子类</strong>对象。有点东西，这就是<strong>上边界</strong>的作用。</p>
<h6 id="3-固定下边界通配符的使用"><a href="#3-固定下边界通配符的使用" class="headerlink" title="(3) 固定下边界通配符的使用"></a>(3) 固定下边界通配符的使用</h6><p>这个较前面的两个有点难理解，仍以 List 为例。它拥有<strong>一定程度的写操作</strong>的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addNumbers</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    addNumbers(list1);</span><br><span class="line">    System.out.println(list1);</span><br><span class="line">    List&lt;Number&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    addNumbers(list2);</span><br><span class="line">    System.out.println(list2);</span><br><span class="line">    List&lt;Double&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// addNumbers(list3); // 编译报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>List&lt;? super E&gt;</strong> 是能够调用 <strong>add 方法</strong>的，因为我们在 addNumbers 方法中所 <strong>add 的元素就是 Integer 类型的</strong>，而传入的 list 不管是什么，都一定是 Integer 或其父类泛型的 List，这时 add 一个 Integer 元素是没有任何疑问的。但是<strong>==不能使用 get 方法==</strong>，除非使用 <strong>Object</strong> 类型来接收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getTest2</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Integer i = list.get(0); // 编译报错</span></span><br><span class="line">    Object o = list.get(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为传入的类都是 <strong>Integer 的类或其父类</strong>，所<strong>传入</strong>的数据类型可能是 <strong>Integer 到 Object</strong> 之间的<strong>任何类型</strong>，这是<strong>无法预料</strong>的，也就无法接收。唯一能确定的就是 <strong>Object</strong>, 因为所有类型都是其<strong>子类型</strong>。使用 <strong>&lt;? super E&gt;</strong> 还有个常见的场景就是 <strong>Comparator</strong>。</p>
<h6 id="4-类型参数与通配符的使用条件"><a href="#4-类型参数与通配符的使用条件" class="headerlink" title="(4) 类型参数与通配符的使用条件"></a>(4) 类型参数与通配符的使用条件</h6><p>一般而言，<strong>通配符</strong>能干的事情都可以用<strong>类型参数替换</strong>。 比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWildCards</span><span class="params">(Collection&lt;?&gt; collection)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以换成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Collection&lt;T&gt; collection)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>如果用<strong>泛型方法</strong>来取代通配符，那么上面代码中 collection 是<strong>能够进行写操作</strong>的。只不过要进行<strong>强制转换</strong>。泛型方法中的泛型参数对象是<strong>可修改</strong>的，因为<strong>类型参数 T 是确定</strong>的（在调用方法时确定），因为 T 可以用范围内任意类型指定。但是通配符本身就<strong>代表类型未知</strong>，所以可能出现<strong>无法修改</strong>或者<strong>只读</strong>的情况，限制更多。</p>
<p>此外，<strong>类型参数</strong>适用于<strong>参数之间的类别依赖关系</strong>，举例说明，比如下面 <strong>E T 两个</strong>参数之间是有<strong>依赖关系</strong>的时候。E 类型是 T 类型的子类，显然这种情况<strong>类型参数</strong>更适合。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> &lt;<span class="title">T</span>, <span class="title">E</span> <span class="keyword">extends</span> <span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">   T value1;</span><br><span class="line">   E value2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;D, S extends D&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(D d, S s)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个方法的<strong>返回类型</strong>依赖于<strong>参数的类型</strong>，那么通配符也无能为力。</p>
<h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><h5 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>Java 泛型是通过<strong>类型擦除</strong>实现的。 <strong>类型擦除</strong>指的是<strong>泛型相关的信息在编译后被擦除的情况</strong>，其过程就是<strong>擦除(erased) 类型变量</strong>, 并<strong>替换</strong>为相应的<strong>限定类型</strong>。<strong>类型参数</strong>给类型擦除指定一个<strong>边界</strong>，类型擦除之后所有的类型参数都用它们的<strong>限定类型替换</strong>，无限定类型的变量用 <strong>Object</strong> 替换。所以泛型信息只存在于代码<strong>编译阶段</strong>。</p>
<p>虚拟机<strong>没有</strong>泛型类型对象，虚拟机不知道泛型，所有对象都属于<strong>普通类</strong>，泛型类和普通类在 Java 虚拟机内是没有什么特别的地方。</p>
<h6 id="1-没有限定类型参数"><a href="#1-没有限定类型参数" class="headerlink" title="(1) 没有限定类型参数"></a>(1) 没有限定类型参数</h6><p>自定义一个<strong>泛型类</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Erasure</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过<strong>反射查看它在运行时的状态信息</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Erasure&lt;String&gt; erasure = <span class="keyword">new</span> Erasure&lt;String&gt;(<span class="string">"hello"</span>);</span><br><span class="line">Class erasureClass = erasure.getClass();</span><br><span class="line">System.out.println(<span class="string">"Erasure class is:"</span> + erasureClass.getName());</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Erasure class is:javase.genericity.Erasure</span><br></pre></td></tr></table></figure>

<p>Class 的<strong>类型</strong>是 <strong>Erasure</strong> 而不是 Erasure&lt;T&gt; 的形式，再用反射看看泛型类中 <strong>T 的类型</strong>在 <strong>JVM</strong> 中具体是什么类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Field[] fs = erasureClass.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span> (Field f : fs) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Field name: "</span> + f.getName() + </span><br><span class="line">                       <span class="string">", type:"</span> + f.getType().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field name: object, type:java.lang.Object</span><br></pre></td></tr></table></figure>

<p>由于<strong>没有限定类型</strong>，所以 T 换为 ==<strong>Object</strong>== 类型。</p>
<h6 id="2-有限定类型参数"><a href="#2-有限定类型参数" class="headerlink" title="(2) 有限定类型参数"></a>(2) 有限定类型参数</h6><p>再给<strong>类型参数</strong>加上更多的限定如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erasure</span> &lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    T object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Erasure</span><span class="params">(T object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 T 类型替换成了<strong>类型上限 String</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Field name: object, type:java.lang.String</span><br></pre></td></tr></table></figure>

<p>所以：在泛型类被<strong>类型擦除</strong>的时候，如果类型参数<strong>没有指定上限</strong>，如 &lt;T&gt; 则会被转译成普通的 <strong>Object</strong> 类型，如果指定了类型参数上限如 &lt;T extends String&gt; 则类型参数就被<strong>替换成类型上限</strong>。</p>
<h5 id="2-泛型的约束与局限性"><a href="#2-泛型的约束与局限性" class="headerlink" title="2. 泛型的约束与局限性"></a>2. 泛型的约束与局限性</h5><p>由于<strong>类型擦除</strong>机制的存在，会引起诸多泛型使用的<strong>约束与局限性</strong>。</p>
<p><strong>1. 不能用基本类型实例化类型参数</strong></p>
<p>不能用类型参数代替基本类型。因此没有 Pair&lt;double&gt;, 只有 <strong>Pair&lt;Double&gt;</strong>。其原因是<strong>类型擦除</strong>。擦除之后，Pair 类含有 <strong>Object</strong> 类型的域，而 Object 不能存储 double 值。</p>
<p><strong>2. 运行时类型查询只适用于==原始类型==</strong></p>
<p>虚拟机中的对象总有一个特定的非泛型类型。因此 <strong>getClass</strong> 方法查询得到的是<strong>原始</strong>类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt; stringPair = . .</span><br><span class="line">Pair&lt;Employee&gt; employeePair = . .</span><br><span class="line"><span class="keyword">if</span> (stringPair.getClass() == employeePair.getClass()) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>其比较的结果是 true, 这是因为两次调用 getClass 都将返回其<strong>原始</strong>类型 <strong>Pair.class</strong>。</p>
<p><strong>3. 不能通过类型参数创建对象</strong></p>
<p><strong>不能</strong>使用像 <strong>new T(…)  new T[…]  或  T.class</strong>  这样的表达式中的类型变量。最好的是让调用者提供一个<strong>构造器</strong>表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    first = <span class="keyword">new</span> T(); </span><br><span class="line">    second = <span class="keyword">new</span> T(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String::<span class="keyword">new</span>);    <span class="comment">// 提供构造表达式：合法</span></span><br></pre></td></tr></table></figure>

<p>如果需要<strong>根据类型创建对象</strong>，可以通过<strong>反射</strong>的方式实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非法 T.class非法，会转为Object.class</span></span><br><span class="line">first = T<span class="class">.<span class="keyword">class</span>.<span class="title">newInstance</span>()</span>; </span><br><span class="line"><span class="comment">// 可以通过以下的API得到class对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; cl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(cl.newInstance(), cl.newInstance()); &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用如下方式调用</span></span><br><span class="line">Pair&lt;String&gt; p = Pair.makePair(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>4. 不能创建具体类型的数组</strong></p>
<p>不能实例化参数化类型的<strong>数组</strong>， 例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pair&lt;String&gt;[] table = <span class="keyword">new</span> Pair&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// 错误 传入String已经是参数化了</span></span><br><span class="line">List&lt;Integer&gt;[] li2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;[];</span><br><span class="line">List&lt;Boolean&gt;[] li3 = <span class="keyword">new</span> ArrayList&lt;Boolean&gt;[];</span><br></pre></td></tr></table></figure>

<p>这三行代码是<strong>无法</strong>在编译器中编译通过的。原因还是<strong>类型擦除</strong>带来的影响。擦除之后，table 的<strong>类型是 Pair[]</strong>。 可以把它转换为 Object[]：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] objarray = table;</span><br></pre></td></tr></table></figure>

<p>而 List&lt;Integer&gt; 和 List&lt;Boolean&gt; 在 JVM 中等同于 <strong>List&lt;Object&gt;</strong> ，所有的类型信息<strong>都被擦除</strong>，程序也无法分辨一个数组中的元素<strong>类型具体</strong>是 List&lt;Integer&gt;类型还是 List&lt;Boolean&gt; 类型。</p>
<p>数组会<strong>记住</strong>它的<strong>元素类型</strong>， 如果试图存储其他类型的元素，就会抛出一个 ArrayStoreException 异常。</p>
<p><strong>但是</strong>可以向<strong>参数个数可变的方法</strong>传递一个泛型类型的实例。如下面的参数可变的方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collections coll, T... ts)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (t : ts) coll.add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了调用这个方法，Java 虚拟机必须建立一个 Pair&lt;String&gt; 数组，这就违反了前面的规则。不过这种情况只会得到一个<strong>警告</strong>，而不是错误。</p>
<p><strong>5. 不能创建泛型数组</strong></p>
<p><strong>数组本身也有类型</strong>，用来监控存储在虚拟机中的数组。这个类型会被<strong>擦除</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&gt; T[] minmax(T[] a) &#123; </span><br><span class="line">    <span class="comment">// 非法</span></span><br><span class="line">    T[] mm = <span class="keyword">new</span> T[<span class="number">2</span>]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型擦除会让这个方法<strong>永远构造 Comparable[2] 数组</strong>。如果现实需要能够存放<strong>泛型对象</strong>的容器，可以使用<strong>原始类型</strong>的数组，如。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pair[] options = <span class="keyword">new</span> Pair &#123;</span><br><span class="line">    <span class="keyword">new</span> Pair&lt;String, Integer&gt;(<span class="string">"1"</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">new</span> Pair&lt;String, Integer&gt;(<span class="string">"2"</span>, <span class="number">2</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>泛型容器内部使用 <strong>Object 数组</strong>，如果要转换泛型容器为对应类型的数组，需要使用反射。</p>
<p>最好让用户提供一个<strong>数组构造器表达式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] ss = ArrayAlg.minmax(String[]::<span class="keyword">new</span>, <span class="string">"Tom"</span>, <span class="string">"Dick"</span>, <span class="string">"Harry"</span>);</span><br></pre></td></tr></table></figure>



<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><blockquote>
<p><strong>Java的泛型是如何工作的 ? 什么是类型擦除 ?</strong></p>
</blockquote>
<p>泛型是通过<strong>类型擦除</strong>来实现的，编译器在<strong>编译</strong>时<strong>擦除了所有类型相关的信息</strong>，所以在<strong>运行时不存在任何类型相关的信息</strong>。</p>
<blockquote>
<p> <strong>什么是泛型中的限定通配符和非限定通配符 ?</strong></p>
</blockquote>
<p>这是一个非常流行的面试题。限定通配符对<strong>类型</strong>进行了限制。有两种<strong>限定通配符</strong>，一种是 <strong>&lt;? extends T&gt;</strong> 它通过确保类型必须是 T 的子类来设定类型的<strong>上界</strong>，另一种是 <strong>&lt;? super T&gt;</strong> 它通过确保类型必须是 T 的父类来设定类型的<strong>下界</strong>。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。还有一个 <strong>&lt;?&gt;</strong> 表示了<strong>非限定通配符</strong>，因为 &lt;?&gt; 可以用<strong>任意类型</strong>来替代。</p>
<blockquote>
<p><strong>List&lt;? extends T&gt;和List &lt;? super T&gt;之间有什么区别 ?</strong></p>
</blockquote>
<p>这两个 List 的声明都是使用了<strong>限定通配符</strong>，List&lt;? extends T&gt; 可以<strong>接受任何继承自 T 的类型</strong>的 List，而 List&lt;? super T&gt; 可以<strong>接受任何 T 的父类构成的 List</strong>。例如 List&lt;? extends Number&gt; 可以接受 List&lt;Integer&gt; 或 List&lt;Float&gt;。</p>
<blockquote>
<p><strong>你可以把List&lt;String&gt;传递给一个接受List&lt;Object&gt;参数的方法吗？</strong></p>
</blockquote>
<p>因为乍看起来 String 是一种 Object，所以 List&lt;String&gt; 应当可以用在需要 List&lt;Object&gt;的地方，但是<strong>事实并非如此</strong>。这就是前面提到的集合是<strong>不能协变</strong>的。真这样做的话会导致<strong>编译错误</strong>。　</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; objectList;</span><br><span class="line">List&lt;String&gt; stringList;</span><br><span class="line">objectList = stringList;  <span class="comment">// compilation error incompatible types</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Array中可以用泛型吗?</strong></p>
</blockquote>
<p>Array 事实上<strong>并不支持泛型</strong>，这也是为什么 Effective Java 一书中建议使用 List 来代替 Array，因为 <strong>List 可以提供编译期的类型安全保证，而 Array 却不能</strong>。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><p><a href="https://blog.csdn.net/sinat_27143551/article/details/80985477" target="_blank" rel="noopener">通配符详解</a></p>
</li>
<li><p><a href="https://blog.csdn.net/sinat_32023305/article/details/83215751" target="_blank" rel="noopener">详细分析通配符与类型参数的区别</a></p>
</li>
<li><p><a href="https://blog.csdn.net/sinat_27143551/article/details/80985477" target="_blank" rel="noopener">深入理解泛型</a></p>
</li>
<li><p><a href="https://blog.csdn.net/zl1zl2zl3/article/details/83301799" target="_blank" rel="noopener">从字节码的角度看泛型</a></p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/A-3%20%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="next" title="ShiftJava/A Java/A-3 接口与抽象类">
                <i class="fa fa-chevron-left"></i> ShiftJava/A Java/A-3 接口与抽象类
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/A%20Java%E5%9F%BA%E7%A1%80/" rel="prev" title="ShiftJava/A Java/A Java基础">
                ShiftJava/A Java/A Java基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型"><span class="nav-number">1.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-杂记"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 杂记</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-泛型概述"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 泛型概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-泛型基本用法"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 泛型基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-泛型类"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">(1) 泛型类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-泛型方法"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">(2) 泛型方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-泛型接口"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">(3) 泛型接口</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-类型参数"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. 类型参数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-概述"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">(1) 概述</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-基本使用"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">(2) 基本使用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通配符"><span class="nav-number">1.2.</span> <span class="nav-text">通配符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-通配符分类"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 通配符分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-基本使用方法"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 基本使用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-无边界通配符的使用"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">(1) 无边界通配符的使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-固定上边界通配符的使用"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">(2) 固定上边界通配符的使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-固定下边界通配符的使用"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">(3) 固定下边界通配符的使用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-类型参数与通配符的使用条件"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">(4) 类型参数与通配符的使用条件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型擦除"><span class="nav-number">1.3.</span> <span class="nav-text">类型擦除</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-没有限定类型参数"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">(1) 没有限定类型参数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-有限定类型参数"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">(2) 有限定类型参数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-泛型的约束与局限性"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 泛型的约束与局限性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试题"><span class="nav-number">1.4.</span> <span class="nav-text">面试题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.5.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
