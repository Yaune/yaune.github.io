<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] 锁与互斥同步一、概述基础1. 不安全示例当多个线程访问与操作同一个对象时，最终执行的结果与执行时序有关，可能正确也可能不正确。如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果可能是不一致的。以下代码演示了 1000000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000000。 12345678910111213public class">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;A Java&#x2F;C-4 锁与互斥同步">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] 锁与互斥同步一、概述基础1. 不安全示例当多个线程访问与操作同一个对象时，最终执行的结果与执行时序有关，可能正确也可能不正确。如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果可能是不一致的。以下代码演示了 1000000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000000。 12345678910111213public class">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200609164845793.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200609150444150.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200609150527487.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200508180912113.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200609150804832.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;1568943231089.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;1568943231089.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200801133558041.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;1563602285907.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;1563602307402.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;1563602294897.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;1582715870763.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200509091238115.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;queue.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;condition_queue.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200801141106142.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200511100248505.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200511100816783.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200511100946122.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200511101220609.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200511101546410.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5&#x2F;assets&#x2F;image-20200609164845793.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/A Java/C-4 锁与互斥同步/"/>





  <title>ShiftJava/A Java/C-4 锁与互斥同步 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/A%20Java/C-4%20%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/A Java/C-4 锁与互斥同步</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h2 id="锁与互斥同步"><a href="#锁与互斥同步" class="headerlink" title="锁与互斥同步"></a>锁与互斥同步</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="1-不安全示例"><a href="#1-不安全示例" class="headerlink" title="1. 不安全示例"></a>1. 不安全示例</h5><p>当多<strong>个线程</strong>访问与操作<strong>同一个对象</strong>时，最终执行的结果与执行时序有关，可能正确也可能不正确。如果多个线程对同一个共享数据进行访问而不采取<strong>同步操作</strong>的话，那么操作的结果可能是不一致的。以下代码演示了 1000000 个线程同时对 cnt 执行<strong>自增</strong>操作，操作结束之后它的值有可能小于 1000000。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//  自增操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000000</span>;</span><br><span class="line">    ThreadUnsafeExample example = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    <span class="comment">// 线程池</span></span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">// 多个线程操作cnt变量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待完成</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">998236</span><br></pre></td></tr></table></figure>

<p>远远小于 100000，出大问题。解决的方法：</p>
<ul>
<li>使用 <strong>synchronized</strong> 关键字；</li>
<li>使用<strong>显示锁</strong>；</li>
<li>使用<strong>原子变量</strong>。</li>
</ul>
<h5 id="2-锁概述"><a href="#2-锁概述" class="headerlink" title="2. 锁概述"></a>2. 锁概述</h5><p>每个<strong>线程</strong>有自己的程序计数器和自己的<strong>栈</strong>，但是线程之间可能存在<strong>共享内存</strong>，可以访问与操作<strong>相同的对象</strong>。因此可能存在<strong>竞争</strong>问题。多线程编程中，有可能会出现多个线程同时访问<strong>同一个共享、可变资源</strong>的情况，这个资源称为<strong>临界资源</strong>；这种资源可能是：对象、变量、文件等。</p>
<ul>
<li><strong>共享</strong>：资源可以由多个线程同时访问。</li>
<li><strong>可变</strong>：资源可以在其生命周期内被修改。  </li>
</ul>
<p><strong>引出的问题：</strong>由于线程执行的过程是<strong>不可控</strong>的，所以需要采用<strong>同步机制</strong>来协调<strong>对对象可变状态</strong>的访问。</p>
<p><strong>如何解决线程并发安全问题？</strong></p>
<p>实际上，所有的并发模式在解决线程安全问题时，采用的方案都是 <strong>序列化访问临界资源</strong>。即在同一时刻，只能有一个线程访问临界资源，也称作<strong>同步互斥访问</strong>。  Java 中，提供了两种方式来实现同步互斥访问：<strong>synchronized（隐式锁） 和 Lock（显式锁）</strong>。</p>
<p><strong>同步器的本质就是加锁</strong>。<strong>加锁目的</strong>：序列化访问临界资源，即同一时刻只能有一个线程访问临界资源(<strong>同步互斥访问</strong>)。</p>
<p>不过有一点需要区别的是：当多个线程执行一个方法时，该方法内部的<strong>局部变量并不是临界资源</strong>，因为这些局部变量是在每个线程的私有栈中，因此不具有共享性，不会导致线程安全问题。  </p>
<p>Java 中的锁架构。</p>
<p><img src="assets/image-20200609164845793.png" alt="image-20200609164845793"></p>
<p>Java 提供了<strong>两种锁机制</strong>来控制多个线程对共享资源的<strong>互斥访问</strong>，第一个是 JVM 实现的 <strong>synchronized</strong>，而另一个是 JDK 实现的基于 API 的 <strong>ReentrantLock</strong>。</p>
<h3 id="二、Synchronized锁"><a href="#二、Synchronized锁" class="headerlink" title="二、Synchronized锁"></a>二、Synchronized锁</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><blockquote>
<p><strong>说一说自己对于synchronized关键字的了解？</strong></p>
</blockquote>
<p>synchronized 关键字解决的是多个线程之间访问资源的<strong>同步性</strong>，synchronized 关键字可以保证被它<strong>修饰的方法或者代码块</strong>在任意时刻只能有<strong>一个线程</strong>执行。可以使用 <strong>synchronized</strong> 互斥锁来保证操作的<strong>原子性</strong>，以解决前述的竞态条件问题。</p>
<p>对前面的自增方法<strong>加锁</strong>，保证<strong>只有一个线程</strong>能操作此方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicSynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 方法加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    AtomicSynchronizedExample example = <span class="keyword">new</span> AtomicSynchronizedExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出为：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure>

<h5 id="2-synchronized基本用法"><a href="#2-synchronized基本用法" class="headerlink" title="2. synchronized基本用法"></a>2. synchronized基本用法</h5><p>synchronized <strong>保护的是一个对象</strong>。</p>
<ul>
<li>同步<strong>实例方法</strong>，锁是当前实例对象。</li>
<li>同步<strong>类方法</strong>，锁是当前类对象。</li>
<li>同步<strong>代码块</strong>，锁是括号里面的对象。</li>
</ul>
<h6 id="1-同步代码块和实例方法"><a href="#1-同步代码块和实例方法" class="headerlink" title="(1) 同步代码块和实例方法"></a>(1) 同步代码块和实例方法</h6><p><strong>synchronized</strong> 保护的是==<strong>实例对象</strong>==。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步实例方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它只作用于==<strong>同一个对象</strong>==，如果调用同一个类的<strong>两个</strong>对象实例上的同步代码块，就<strong>不会</strong>进行同步，想一下如果是多个对象各自<strong>独立操作</strong>，其实不会存在竞争。即保护的是<strong>同一个对象的方法调用</strong>。再具体来说，synchronized 实例方法保护的是<strong>当前实例对象</strong>，<strong>即 ==this== 对象</strong>。this 对象有一个<strong>锁</strong>和一个<strong>等待队列</strong>，锁只能被<strong>一个线程持有</strong>，其他线程需要锁时会<strong>尝试获取</strong>，没获取到就进入<strong>等待队列</strong>等待，并进入 <strong>BLOCKED</strong> 状态。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是<strong>同一个对象的同步代码块</strong>，因此这两个线程会进行同步，当一个线程进入<strong>同步语句块</strong>时，另一个线程就必须<strong>等待</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 作用于同一个e1对象，需要获取锁</span></span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时锁住的是 e1 这个对象，两个线程都在<strong>争取</strong> e1 的对象锁。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>对于以下代码，两个线程调用了<strong>不同对象</strong>的同步代码块，两个对象<strong>各自拥有</strong>自己的<strong>锁和等待队列</strong>，因此这两个线程就<strong>不需要同步</strong>。从输出结果可以看出，两个线程<strong>交叉执行</strong>。相当于这里就有<strong>两把锁</strong>，不同的线程获得不同对象的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由于同步的是代码块 所以使用两个不同对象的锁不用同步</span></span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 0 5 6 7 8 9 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p>注意：在 <strong>Spring 容器</strong>中，如果是对<strong>普通实例方法</strong>加锁，那么这个实例在容器中应该是<strong>单例</strong>的。</p>
<h6 id="2-同步静态方法"><a href="#2-同步静态方法" class="headerlink" title="(2) 同步静态方法"></a>(2) 同步静态方法</h6><p>synchronized 保护的是<strong>对象</strong>。对于实例方法，保护的是<strong>当前实例对象 this</strong>，而对于<strong>静态方法</strong>，保护的是==<strong>类对象</strong>==。即 <strong>StaticCounter.class</strong>。每个对象都有一个<strong>锁与等待队列</strong>，<strong>类对象</strong>也不例外。</p>
<p><strong>静态成员</strong>不属于任何一个实例对象，是类成员（static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份）。</p>
<p>synchronized 静态方法和 synchronized 实例方法保护的是<strong>不同</strong>的对象，<strong>不同的两个线程可以一个执行 synchronized 静态方法，另一个执行 synchronized  实例方法。</strong>因为<strong>类对象</strong>和<strong>实例对象</strong>属于<strong>不同的对象</strong>，两者都有其各自的锁与等待队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 静态方法加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">incr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁住<strong>静态方法</strong>保证同时只能有一个线程在使用这个静态方法资源，如果有竞争就会等待。</p>
<p>补充：synchronized <strong>几乎不可能跨方法加锁</strong>（即在一个方法中加锁，在一个方法中解锁）。但是实在要跨方法加锁可以使用 <strong>Unsafe 类</strong>中的加<strong>锁方法 + 一个全局对象</strong>。这是越过虚拟机<strong>直接操作底层</strong>，不推荐。</p>
<p>注意：写成 <strong>synchronized static 和 static synchronized</strong> 都是可以的，因为 synchronized 和 static 是同级别的修饰符，放前放后都一样。</p>
<h6 id="3-同步一个类"><a href="#3-同步一个类" class="headerlink" title="(3) 同步一个类"></a>(3) 同步一个类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用于==<strong>整个类</strong>==，也就是说两个线程调用<strong>同一个类</strong>的<strong>不同对象</strong>上的这种同步语句，<strong>也会进行同步</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由于是锁住整个类 所以同一个类的两个不同对象也需要等待</span></span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于是锁住<strong>整个类</strong>，所以同一个类的<strong>两个不同对象</strong>也需要等待。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong> synchronized 关键字加到 <strong>static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁</strong>。synchronized 关键字加到<strong>实例方法</strong>上或者<strong>普通代码块</strong>是给<strong>对象实例</strong>上锁。尽量<strong>不要</strong>使用 synchronized(String a) 因为 JVM 中，字符串常量池具有<strong>缓存功能</strong>！</p>
<h6 id="4-应用"><a href="#4-应用" class="headerlink" title="(4) 应用"></a>(4) 应用</h6><blockquote>
<p><strong>项目中用过synchronized吗？</strong></p>
</blockquote>
<p>可以回答用在了单例模式上，<strong>双重校验锁实现对象单例（线程安全）</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，需要注意 <strong>uniqueInstance</strong> 采用 <strong>volatile</strong> 关键字修饰也是很有必要，因为 <strong>uniqueInstance = new Singleton();</strong> 这段代码其实是<strong>分为三步</strong>执行：</p>
<ol>
<li>为 uniqueInstance <strong>分配内存空间</strong>。</li>
<li><strong>初始化</strong> uniqueInstance。</li>
<li>将 uniqueInstance 指向分配的<strong>内存地址</strong>。</li>
</ol>
<p>但是由于 JVM 具有<strong>指令重排</strong>的特性，执行<strong>顺序有可能变成 1-&gt;3-&gt;2</strong>。<strong>指令重排</strong>在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance <strong>不为空</strong>，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。使用 volatile 可以<strong>禁止 JVM 的指令重排</strong>，保证在多线程环境下也能正常运行。</p>
<h5 id="3-synchronized的特性"><a href="#3-synchronized的特性" class="headerlink" title="3. synchronized的特性"></a>3. synchronized的特性</h5><h6 id="1-可重入性"><a href="#1-可重入性" class="headerlink" title="(1) 可重入性"></a>(1) 可重入性</h6><p>synchronized 是<strong>可重入</strong>的，即<strong>同一个执行线程</strong>，它获得了<strong>对象锁</strong>之后，可以<strong>直接调用其他需要同样锁的代码</strong>，无需等待。如在一个 synchronized <strong>实例方法</strong>内可以<strong>直接调用</strong>其他 synchronized <strong>实例方法</strong>。可重入是通过记录锁的<strong>持有线程</strong>和持有<strong>数量</strong>来实现的。</p>
<h6 id="2-内存可见性"><a href="#2-内存可见性" class="headerlink" title="(2) 内存可见性"></a>(2) 内存可见性</h6><p>synchronized 可以实现<strong>原子操作</strong>，避免出现<strong>竞态条件</strong>。同时还可以<strong>解决内存可见性</strong>问题，在<strong>释放锁</strong>时，所有的写入都会<strong>写回内存</strong>，获得锁后，都会从<strong>内存</strong>读取最新数据。而<strong>不是利用的缓存</strong>。</p>
<p>如果只是为了<strong>保证内存可见性</strong>，使用 synchronized 成本有点高，可以使用轻量级的 <strong>volatile</strong> 关键字，但是<strong>不能解决竞态条件的问题。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> <span class="keyword">switch</span> = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<h6 id="3-死锁"><a href="#3-死锁" class="headerlink" title="(3) 死锁"></a>(3) 死锁</h6><p>应该避免在<strong>持有一个锁</strong>的同时去<strong>申请另一个锁</strong>，如果确实需要多个锁，所有代码都应该<strong>按照相同的顺序</strong>去申请锁。</p>
<p>可以使用<strong>显示锁 Lock</strong> 的方式来<strong>解决部分死锁</strong>问题，它支持尝试获取锁和<strong>带时间限制</strong>的获取锁方法，使用这些方法可以在获取不到锁的时候放弃已经持有的锁。</p>
<h6 id="4-性能"><a href="#4-性能" class="headerlink" title="(4) 性能"></a>(4) 性能</h6><p>在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为<strong>监视器锁</strong>（monitor）是依赖于底层的操作系统的 MutexLock 来实现的，Java 的线程是映射到操作系统的<strong>原生线程</strong>之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统<strong>实现线程之间的切换时需要从用户态转换到内核态</strong>，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。Java6 之后从 JVM 层面对 synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了<strong>大量的优化</strong>，如<strong>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术来减少锁操作的开销。</p>
<h4 id="synchronized原理解析"><a href="#synchronized原理解析" class="headerlink" title="synchronized原理解析"></a>synchronized原理解析</h4><p>synchronized 对应的<strong>内存间交互</strong>操作为：<strong>lock 和 unlock</strong>，在<strong>虚拟机</strong>实现上对应的<strong>字节码</strong>指令为 <strong>monitorenter 和 monitorexit</strong>。<strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p>
<h5 id="1-编译测试"><a href="#1-编译测试" class="headerlink" title="1. 编译测试"></a>1. 编译测试</h5><h6 id="1-synchronized同步语句块的情况"><a href="#1-synchronized同步语句块的情况" class="headerlink" title="(1) synchronized同步语句块的情况"></a>(1) synchronized同步语句块的情况</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"synchronized 代码块"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <strong>javap</strong> 命令反编译查看 SynchronizedDemo 类的相关<strong>字节码</strong>信息：首先切换到类的对应目录执行 <strong>javac</strong> SynchronizedDemo.java 命令生成<strong>编译后的 .class 文件</strong>，然后执行 <strong>javap -c -s -v -l SynchronizedDemo.clas</strong>s 反编译。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">javase</span>.<span class="title">thread</span>.<span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> javase.thread.SynchronizedDemo();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: dup</span><br><span class="line">       <span class="number">2</span>: astore_1</span><br><span class="line">       <span class="number">3</span>: monitorenter</span><br><span class="line">       4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       7: ldc           #3                  // String synchronized 代码块</span><br><span class="line">       9: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="number">12</span>: aload_1</span><br><span class="line">      <span class="number">13</span>: monitorexit</span><br><span class="line">      <span class="number">14</span>: goto          <span class="number">22</span></span><br><span class="line">      <span class="number">17</span>: astore_2</span><br><span class="line">      <span class="number">18</span>: aload_1</span><br><span class="line">      <span class="number">19</span>: monitorexit</span><br><span class="line">      <span class="number">20</span>: aload_2</span><br><span class="line">      <span class="number">21</span>: athrow</span><br><span class="line">      <span class="number">22</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">4</span>    <span class="number">14</span>    <span class="number">17</span>   any</span><br><span class="line">          <span class="number">17</span>    <span class="number">20</span>    <span class="number">17</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出：<strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图<strong>获取锁</strong>也就是获取 <strong>monitor</strong>(monitor 对象存在于每个 Java 对象的<strong>对象头</strong>中，synchronized 锁便是通过这种方式获取锁的，也是为什么 <strong>Java 中任意对象可以作为锁</strong>的原因) 的持有权。当计数器为 0 则可以<strong>成功获取</strong>，获取后将<strong>锁计数器</strong>设为 1 也就是加 1。相应的在执行 <strong>monitorexit</strong> 指令后，将<strong>锁计数器设为 0</strong>，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。如果有<strong>可重入</strong>的情况，锁计数器会持续<strong>增加</strong>。</p>
<h6 id="2-synchronized修饰方法的情况"><a href="#2-synchronized修饰方法的情况" class="headerlink" title="(2) synchronized修饰方法的情况"></a>(2) synchronized修饰方法的情况</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"synchronized 方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样执行进行<strong>反编译</strong>操作获取字节码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> javase.thread.SynchronizedDemo2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0001</span>) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object."&lt;init&gt;":()V</span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">3</span>: <span class="number">0</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>       <span class="number">5</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ljavase/thread/SynchronizedDemo2;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (<span class="number">0x0029</span>) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String synchronized 方法</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">8</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">6</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">7</span>: <span class="number">8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>synchronized 修饰的方法并<strong>没有</strong> monitorenter 指令和 monitorexit 指令，取得代之的是 <strong>==ACC_SYNCHRONIZED==</strong> 标识，该标识指明了该方法是一个<strong>同步方法</strong>（要看到这个标识，javap 指令必须<strong>加 -v 参数</strong>，不然显示不完全），JVM 通过该 <strong>ACC_SYNCHRONIZED 访问标志</strong>来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>总结：Java 虚拟机中的 synchronized 是基于进入和退出 monitor 对象实现的，同步分为<strong>显式同步和隐式同步</strong>，同步<strong>代码块</strong>代表着<strong>显式同步</strong>，指的是有明确的 monitorenter 和 monitorexit 指令。<strong>同步方法</strong>代表着<strong>隐式同步</strong>，同步方法是由<strong>方法调用指令</strong>读取运行时常量池中方法的 <strong>ACC_SYNCHRONIZED</strong> 标志来隐式实现的。</p>
<h5 id="2-加锁详解与Monitor对象"><a href="#2-加锁详解与Monitor对象" class="headerlink" title="2. 加锁详解与Monitor对象"></a>2. 加锁详解与Monitor对象</h5><p><strong>每个对象</strong>在创建的时候在 JVM 中就会维护有一个<strong>自己的 Monitor (监视器锁)</strong>。</p>
<p>synchronized 是基于 JVM <strong>内置锁</strong>实现，<strong>维护了内部对象 Monitor (监视器锁)</strong>，通过<strong>进入与退出 Monitor 对象实现方法与代码块同步，监视器锁的实现依赖底层操作系统的 Mutex lock（互斥锁）</strong>。synchronized 关键字被编译成<strong>字节码</strong>后会被翻译成 <strong>monitorenter 和 monitorexit 两条指令</strong>分别在<strong>同步块逻辑代码</strong>的<strong>起始位置与结束位置</strong>。  </p>
<img src="assets/image-20200609150444150.png" alt="image-20200609150444150" style="zoom: 45%;" />

<p>monitorenter 与 monitorexit 其实与 <strong>JMM</strong> 中的 <strong>lock 与 unlock 操作是关联</strong>的。</p>
<p>加锁过程如下图所示。</p>
<p><img src="assets/image-20200609150527487.png" alt="image-20200609150527487"></p>
<p>如果有多个线程同时请求对象的 <strong>Monitor 锁</strong>，只有成功获取锁的线程能够得到 <strong>Monitor 锁</strong>，并执行相关的业务代码，其他没用得到锁的线程会进入到这个 <strong>Monitor 对象</strong>的<strong>等待队列</strong>中，当线程获取锁后，会通知各个等待的线程再去<strong>竞争锁</strong>。</p>
<p>JVM 中 monitor 是由 <strong>ObjectMonitor</strong> 实现的，其主要的数据结构为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;    <span class="comment">// 记录加锁次数，锁重入时使用</span></span><br><span class="line">    _waiters      = <span class="number">0</span>,</span><br><span class="line">    _recursions   = <span class="number">0</span>;</span><br><span class="line">    _object       = <span class="literal">NULL</span>;</span><br><span class="line">    _owner        = <span class="literal">NULL</span>; <span class="comment">// 指向持有当前monitor对象的线程：这会反应到虚拟机栈上</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 等待竞争锁线程，会被加入到_WaitSet</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;</span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ; <span class="comment">// 处于等待锁block状态的线程，会被加入到该列表</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>monitor 对象中有内部有<strong>两个队列</strong>，一个用来保存一个 <strong>ObjectWaiter</strong> 对象列表（每个<strong>等待这个锁的线程</strong>都会被封装成为 ObjectWaiter 对象)，owner 指向的是持有<strong>持有 monitor 对象的线程</strong>，当多个线程同时访问一段代码的时候，首先会进入 <strong>_Entry_list 集合</strong>，当线程获取到对象的 Monitor 后，会进入  _owner 区域并把 monitor 中的 owner 设置为<strong>当前持有锁的线程</strong>，同时 monitor 中的<strong>计数器 count 加 1</strong>，如果线程调用 <strong>wait</strong>() 方法，将会<strong>释放</strong>当前持有的 <strong>monitor</strong>，owner 设置为 <strong>null</strong>， count 减 1，同时该线程进入 <strong>WaitSet</strong> 集合中<strong>等待被唤醒</strong>，如果当前线程执行完毕也将会释放 monitor 锁，owner 变为null，count 减 1。</p>
<p>整个过程可以参考下图。 </p>
<img src="assets/image-20200508180912113.png" alt="image-20200508180912113" style="zoom:60%;" />

<p><strong>monitor 对象</strong>存在每个 Java 对象的<strong>对象头</strong>中 (<strong>MarkWord</strong> 结构中存储了指向 <strong>monitor 对象</strong>的指针)，也就是为什么 notify，notifyall，wait 方法都<strong>存在 Object 对象</strong>中的原因。</p>
<p>问题来了，synchronized 加锁是<strong>加在对象</strong>上，那么对象是<strong>如何记录锁状态</strong>的呢？答案是<strong>锁状态是被记录在每个对象的对象头（Mark Word）</strong>中，看看对象的内存布局。</p>
<h5 id="3-对象头"><a href="#3-对象头" class="headerlink" title="3. 对象头"></a>3. 对象头</h5><p>在 HotSpot 虚拟机中，对象在内存中存储布局分为 <strong>3 块区域</strong>：<strong>对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）</strong>，这里主要关注对象头。对象头包含：<strong>hash 码</strong>，对象所属的年代，对象锁，<strong>锁状态标志</strong>，偏向锁（线程）ID，偏向时间，数组长度（数组对象）等内容。</p>
<img src="assets/image-20200609150804832.png" alt="image-20200609150804832" style="zoom:56%;" />

<p><strong>实例对象</strong>与<strong>类对象</strong>的对象头差别不大，所以加锁加在<strong>实例方法</strong>与<strong>静态方法</strong>上原理是类似的。</p>
<p>HotSpot 虚拟机的<strong>对象头</strong>包括<strong>两部分</strong>（非数组对象）信息，如下图所示：</p>
<ul>
<li>第一部分用于存储对象自身的<strong>运行时数据</strong>，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳、对象分代年龄，这部分信息称为<strong>“Mark Word”</strong>；Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据自己的状态<strong>复用</strong>自己的存储空间。</li>
<li>第二部分是<strong>类型指针</strong>，即对象指向它的<strong>类元数据</strong>的指针，虚拟机通过这个指针来确定这个对象是<strong>哪个类</strong>的实例；</li>
<li>如果对象是一个 Java <strong>数组</strong>，那在对象头中还必须有<strong>一块</strong>用于记录<strong>数组长度</strong>的数据。因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中无法确定数组的大小。</li>
</ul>
<p><strong>==Mark Word==</strong> 在不同的<strong>锁状态</strong>下存储的内容不同（<strong>锁升级的过程</strong>会改变 Mark Word的值），在 <strong>32 位 JVM</strong> 中是这么存的：</p>
<p><img src="assets/1568943231089.png" alt="1568943231089"></p>
<p><strong>重量级锁就是 synchronized 锁</strong>，锁的<strong>标记位为 10</strong>，其中指针指向 monitor 对象的<strong>起始地址</strong>。<strong>每一个对象</strong>在 JVM 中都存在一个 <strong>monitor</strong> 对象与之相关联，monitor 对象可以与对象一起创建销毁或者当线程试图获取对象锁的时候<strong>自动生成</strong>，monitor 被<strong>线程持有</strong>之后就处于<strong>锁定的状态</strong>。</p>
<p>总结 synchronized 修饰方法可以看出，JVM 通过判断 <strong>ACC_SYNCHRONIZED</strong> 访问标志来判别一个方法是否是同步方法，进而<strong>获取 monitor 对象</strong>。</p>
<h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><p>在早期 synchronized 是重量锁效率低，因为 monitor 是<strong>依赖底层操作系统</strong>来实现的，而操作系统实现线程之间的转换需要从用户太转换到核心态，这个转换要浪费很多时间，后来从 JVM 层面对 synchronized 有了很大的优化，为了减少获得锁或者是释放锁的性能消耗，引入了<strong>轻量级锁和偏向锁</strong>，所以现在的 synchronized 还可以。</p>
<p>锁优化主要是指 <strong>JVM</strong> 对 <strong>==synchronized==</strong> 的优化。JDK1.6 对锁的实现引入了大量的优化，如<strong>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化</strong>等技术来减少锁操作的开销。</p>
<p>主要有：自旋锁、锁消除、锁粗化、轻量级锁、偏向锁。</p>
<h5 id="1-锁粗化"><a href="#1-锁粗化" class="headerlink" title="1. 锁粗化"></a>1. 锁粗化</h5><p>如果一系列的连续操作都对<strong>同一个对象</strong>反复加锁和解锁，<strong>频繁的加锁操作就会导致性能损耗</strong>。</p>
<p>下面代码中连续的 append() 方法就属于这类情况，这里如果加四次锁就会影响性能，JVM 会进行锁粗化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    StringBuffer stb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 锁的粗化</span></span><br><span class="line">        stb.append(<span class="string">"1"</span>);</span><br><span class="line">        stb.append(<span class="string">"2"</span>);</span><br><span class="line">        stb.append(<span class="string">"3"</span>);</span><br><span class="line">        stb.append(<span class="string">"4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果虚拟机探测到由这样的一串零碎的操作都对<strong>同一个对象</strong>加锁，将会把<strong>==加锁的范围扩展==（粗化）</strong>到<strong>整个操作序列</strong>的<strong>外部</strong>，这样只需要<strong>加锁一次</strong>就可以了。</p>
<h5 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2. 锁消除"></a>2. 锁消除</h5><p>锁消除是指对于被检测出<strong>不可能存在竞争</strong>的<strong>共享数据</strong>的<strong>锁进行消除</strong>。<strong>锁消除</strong>主要是通过<strong>逃逸分析</strong>来决策支持的，如果<strong>堆上</strong>的共享数据<strong>不可能逃逸</strong>出去被其它线程访问到，那么就可以把它们当成<strong>私有数据</strong>对待，也就可以将它们的锁进行消除。</p>
<p>对于一些看起来没有加锁的代码，其实<strong>隐式的加了很多锁</strong>。例如下面的字符串拼接代码就<strong>隐式加了锁</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 是一个<strong>不可变</strong>的类，编译器会对 String 的<strong>拼接</strong>自动优化。在 JDK1.5 <strong>之前</strong>，会转化为 StringBuffer 对象的连续 append() 操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个 append() 方法中都有一个<strong>同步块</strong>。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远<strong>不会逃逸</strong>到 concatString() 方法<strong>之外</strong>，其他线程<strong>无法访问到它</strong>，因此<strong>可以进行消除</strong>。</p>
<h5 id="3-内置锁优化升级过程"><a href="#3-内置锁优化升级过程" class="headerlink" title="3. 内置锁优化升级过程"></a>3. 内置锁优化升级过程</h5><p><strong>重要</strong>！JDK1.6 引入了<strong>偏向锁和轻量级锁</strong>，从而让锁拥有了<strong>四个状态</strong>：<strong>无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）</strong>。</p>
<p>以下是 HotSpot 虚拟机<strong>对象头</strong>的内存布局，这些数据被称为 <strong>Mark Word</strong>。其中 tag bits 对应了<strong>五个状态</strong>，这些状态在右侧的锁标志位中给出。几种锁会随着<strong>竞争的激烈而逐渐升级</strong>，注意锁<strong>可以升级不可降级</strong>，这种策略是为了提高获得锁和释放锁的效率。</p>
<p><strong>==Mark Word==</strong> 在不同的<strong>锁状态</strong>下存储的内容不同，会随着锁升级而变动。在 <strong>32 位 JVM</strong> 中是这么存的：</p>
<p><img src="assets/1568943231089.png" alt="1568943231089"></p>
<p>所以锁有 4 种状态。<strong>无锁、偏向锁、轻量级锁、重量级锁</strong>。</p>
<img src="assets/image-20200801133558041.png" alt="image-20200801133558041" style="zoom:50%;" />

<p>下图<strong>左侧</strong>是一个线程的==<strong>虚拟机栈</strong>==，其中有一部分称为 <strong>==Lock Record==</strong> 的区域，这是在<strong>轻量级锁</strong>运行过程创建的，用于存放<strong>锁对象的 Mark Word</strong>。而右侧就是一个<strong>==锁对象==</strong>，包含了 <strong>Mark Word</strong> 和其它信息。</p>
<img src="assets/1563602285907.png" alt="1563602285907" style="zoom:70%;" />

<h5 id="4-偏向锁"><a href="#4-偏向锁" class="headerlink" title="4. 偏向锁"></a>4. 偏向锁</h5><p>当一个锁对象<strong>才创建</strong>时，是<strong>没有任何线程获得过这个锁</strong>的，这个时候是<strong>==无锁状态==</strong>。偏向锁适用于<strong>只有一个线程</strong>访问的场景。偏向锁不会自动释放。</p>
<p>偏向锁的思想是偏向于让<strong>第一个</strong>获取<strong>锁对象的线程</strong>，这个线程在<strong>之后获取该锁</strong>就<strong>不再需要</strong>进行同步操作，甚至连 CAS 操作也不再需要。此时 Mark Word 的结构也变为<strong>偏向锁结构</strong>，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。  </p>
<p>当锁对象<strong>第一次</strong>被线程获得的时候，进入<strong>偏向状态</strong>，标记为 <strong>1  01</strong>（见上图）。同时使用 CAS 操作将<strong>线程 ID</strong> 记录到 Mark Word 中，如果 CAS 操作成功，<strong>这个线程</strong>以后每次进入这个锁相关的同步块就<strong>不需要再进行任何同步</strong>操作。</p>
<p>注意：当有<strong>==另外一个线程==</strong>去尝试获取这个锁对象时，<strong>偏向状态就宣告结束</strong>，此时<strong>撤销偏向</strong>（Revoke Bias）后恢复到<strong>未锁定</strong>状态或者<strong>轻量级锁</strong>状态。</p>
<img src="assets/1563602307402.png" alt="1563602307402" style="zoom:67%;" />

<p>默认<strong>开启偏向锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=<span class="number">0</span></span><br><span class="line">关闭偏向锁：-XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure>

<h5 id="5-轻量级锁"><a href="#5-轻量级锁" class="headerlink" title="5. 轻量级锁"></a>5. 轻量级锁</h5><p>倘若偏向锁失败，虚拟机并<strong>不会立即升级为重量级锁</strong>，它还会尝试使用一种称为<strong>轻量级锁的优化手段</strong>(1.6 之后加入的)，此时 Mark Word 的结构也变为<strong>轻量级锁的结构</strong>。轻量级锁能够提升程序性能的依据是<strong>“对绝大部分的锁，在整个同步周期内都不存在竞争”</strong>，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是竞争不是很激烈，线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p>
<p><strong>轻量级锁</strong>是相对于传统的重量级锁而言，它<strong>使用 CAS 操作</strong>来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，==可以<strong>先采用 CAS 操作</strong>进行同步，如果 CAS 失败了<strong>再改用互斥量</strong>进行同步==。CAS 则让需要等待的线程<strong>自旋</strong>，不会释放 CPU 执行权，只需要等待小段时间即可获取到锁。</p>
<p>当尝试获取一个锁对象时，如果锁对象标记为 <strong>0 01</strong>（见上面的图），说明锁对象的锁<strong>未锁定</strong>（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 <strong>CAS</strong> 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作<strong>成功</strong>了，那么线程就获取了该对象上的<strong>锁</strong>，并且对象的 <strong>Mark Word 的锁标记</strong>变为 <strong>00</strong>，表示该<strong>对象处于轻量级锁状态</strong>。</p>
<img src="assets/1563602294897.png" alt="1563602294897" style="zoom:67%;" />

<p>如果 <strong>CAS 操作失败</strong>了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以<strong>直接</strong>进入<strong>同步块</strong>继续执行，否则说明这个锁对象已经被其他线程线程<strong>抢占</strong>了。如果有<strong>两条以上的线程争用同一个锁</strong>，那轻量级锁就不再有效，要<strong>膨胀为重量级锁</strong>。</p>
<h5 id="6-自旋锁"><a href="#6-自旋锁" class="headerlink" title="6. 自旋锁"></a>6. 自旋锁</h5><p><strong>轻量级锁失败</strong>后，虚拟机为了避免线程真实地在操作系统层面挂起，<strong>还会</strong>进行一项称为<strong>自旋锁</strong>的优化手段。这是基于在大多数情况下，线程<strong>持有锁的时间都不会太长</strong>，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是 50 个循环或 100 循环，在经过若干次循环后，如果得到锁，就顺利进入<strong>临界区</strong>。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是<strong>自旋锁的优化方式</strong>，这种方式确实也是可以提升效率的。最后没办法也就只能升级为<strong>重量级锁</strong>了。</p>
<p>互斥同步进入阻塞状态的开销都很大，应该<strong>尽量避免</strong>。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时<strong>执行忙循环（自旋）</strong>一段时间，如果在这段时间内能获得锁，就可以<strong>避免</strong>进入阻塞状态。</p>
<p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作<strong>占用 CPU</strong> 时间，它只适用于共享数据的==<strong>锁定状态很短</strong>==的场景。如果太长就太多的忙循环了。</p>
<p>在 JDK1.6 中引入了<strong>自适应的自旋锁</strong>。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p>
<h5 id="7-问题"><a href="#7-问题" class="headerlink" title="7. 问题"></a>7. 问题</h5><p>系统并发高的时候，可能导致<strong>锁膨胀升级</strong>，JVM 规定 synchronized 锁升级之后<strong>无法锁降级</strong>；升级之后，如果系统的并发下来了，无疑降低了处理速度。</p>
<p>因此可以进行一段时间进行统计，<strong>统计并发度已经很低</strong>，如果还是重量级锁，则进行<strong>锁对象的切换</strong>。换一个锁对象，这样又开始偏向锁状态，提升了处理速度；锁对象切换时候，需要注意并发操作。</p>
<p>可以用这个第三方架包可以获取对象的消息头详情，获取当前锁对象是否处于重量级锁状态。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h3 id="三、显式锁"><a href="#三、显式锁" class="headerlink" title="三、显式锁"></a>三、显式锁</h3><p>显式锁是基于 <strong>API</strong> 的。</p>
<h4 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><p><strong>synchronized</strong> 方法或语句的使用提供了对与每个<strong>对象</strong>相关的隐式监视器锁的访问，但却强制所有锁获取和释放均要出现在一个块结构中：当获取了<strong>多个锁</strong>时，它们必须以<strong>相反的顺序释放</strong>，且必须在与所有锁被获取时相同的词法范围内释放所有锁。</p>
<p>这个时候出现了 Lock 接口。它是 java.util.concurrent.<strong>locks</strong> 包中的一个<strong>接口</strong>。Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作，更<strong>灵活</strong>的操作，可以具有差别很大的属性，可以支持多个相关的 Condition 对象。当然更高的自由度也带来更多的责任。</p>
<p>在 <strong>try…catch 模块</strong>之前使用 <strong>lock</strong> 加锁（阿里规范），在 <strong>finally</strong> 模块中<strong>释放锁</strong>（保证锁必须释放）。下面是示范代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock myLock = ...; </span><br><span class="line">myLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// access the resource protected by this lock</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    myLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>锁的锁定和释放如果在<strong>不同的模块</strong>时，需要谨慎编码，确保最后锁一定能够得到<strong>释放</strong>。</p>
<h5 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h5><p>Lock 接口源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁。如果锁不可用，出于线程调度目的，将禁用当前线程，并且在获得锁之前，该线程将一直处于休眠状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前线程未被中断，则获取锁。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回绑定到此Lock实例的新Condition实例。</span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅在调用时锁为空闲状态才获取该锁。如果锁可用，则获取锁，并立即返回值true。如果锁不可用，则此方法将立即返回值false。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果锁在给定的等待时间内空闲，并且当前线程未被中断，则获取锁。</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span>	<span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁。在等待条件前，锁必须由当前线程保持。调用 Condition.await() 将在等待前以原子方式释放锁，并在等待返回前重新获取锁。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>Lock 接口有三个<strong>实现类</strong>分别是 ==<strong>ReentrantLock</strong>,  <strong>ReentrantReadWriteLock.ReadLock, ReentrantReadWriteLock.WriteLock</strong>==。后面两个是<strong>内部类</strong>。<strong>ReentrantReadWriteLock</strong> 实现了 <strong>ReadWriteLock</strong> 接口，同时其内部有两个内部类实现了 Lock 接口。如下图所示。</p>
<img src="assets/1582715870763.png" alt="1582715870763" style="zoom:49%;" />



<h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><h5 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>JDK 中<strong>独占锁</strong>的实现除了使用关键字 synchronized 外，还可以使用 <strong>ReentrantLock</strong>。虽然在性能上 ReentrantLock 和 synchronized 区别已经不大了，但 ReentrantLock 相比 synchronized 而言功能更加<strong>丰富</strong>，使用起来更为灵活，也更适合复杂的并发场景。</p>
<p><strong>ReentrantLock</strong> 是 java.util.concurrent（<strong>JUC</strong>）包中的一个<strong>可重入的互斥锁</strong>。<strong>ReentrantLock *<em>和 *</em>synchronized</strong> 在基本用法，行为语义上都是类似的，同样都具有可重入性。只不过相比原生的 Synchronized，ReentrantLock 增加了一些<strong>高级的扩展功能</strong>，比如它可以实现<strong>公平锁，</strong>同时可以绑定<strong>多个 Conditon</strong>。</p>
<p>使用 <strong>tryLock</strong> 可以<strong>避免死锁</strong>。它会在持有一个锁 A 获取另一个锁 B 而获取不到 B 的时候，可以释放已持有的锁 A ，给其他线程获取锁 A 的机会，然后<strong>重试</strong>获取所有锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义锁</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();	<span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">// 加锁效果与synchronized类似</span></span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>

<h6 id="1-可重入性-1"><a href="#1-可重入性-1" class="headerlink" title="(1) 可重入性"></a>(1) 可重入性</h6><p>所谓的<strong>可重入性</strong>，就是<strong>可以支持一个线程对锁的重复获取</strong>，原生的 synchronized 就具有可重入性，一个用 synchronized 修饰的递归方法，当线程在执行期间，它是可以<strong>反复</strong>获取到锁的，而不会出现自己把自己锁死的情况。ReentrantLock 也是如此，在调用 lock() 方法时，已经获取到锁的线程，能够<strong>再次调用</strong> lock() 方法获取锁而不被阻塞。那么有可重入锁，就有不可重入锁，之前自定义的一个 Mutex 锁就是个不可重入锁，不过使用场景极少而已。</p>
<h6 id="2-公平锁-非公平锁"><a href="#2-公平锁-非公平锁" class="headerlink" title="(2) 公平锁/非公平锁"></a>(2) 公平锁/非公平锁</h6><p>所谓公平锁，顾名思义指<strong>锁的获取策略相对公平</strong>，当多个线程在获取同一个锁时，<strong>必须按照锁的申请时间</strong>来依次获得锁，排排队，不能插队；非公平锁则不同，当锁被释放时，等待中的线程<strong>均有机会</strong>获得锁。synchronized 是<strong>非公平锁</strong>， ReentrantLock 默认也是非公平的，但是可以通过带 boolean 参数（<strong>fair</strong> 参数）的构造方法<strong>指定使用公平锁</strong>，但<strong>非公平锁的性能一般要优于公平锁。</strong></p>
<h5 id="2-源码解析"><a href="#2-源码解析" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h5><p>接下来从源码角度来看看 ReentrantLock 的实现原理，它是如何保证<strong>可重入性</strong>，又是如何实现<strong>公平锁</strong>的。</p>
<p>ReentrantLock 是基于 <strong>AQS</strong> 的，AQS 是 Java 并发包中众多同步组件的构建基础，它通过一个 <strong>int 类型的状态变量 state</strong> 和<strong>一个 FIFO 队列</strong>来完成共享资源的获取，线程的排队等待等。AQS 是个底层框架，采用<strong>模板方法</strong>模式，它定义了通用的较为复杂的逻辑骨架，比如<strong>线程的排队，阻塞，唤醒</strong>等，将这些复杂但实质通用的部分抽取出来，这些都是需要构建同步组件的使用者无需关心的，使用者仅需重写一些简单的指定的方法即可（<strong>其实就是对于共享变量 state 的一些简单的获取释放的操作</strong>）。</p>
<h6 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="(1) 构造方法"></a>(1) 构造方法</h6><p>构造方法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造器默认为非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fair为true，公平锁；反之，非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据fair参数决定初始化哪个同步组件</span></span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 的抽象静态内部类 <strong>Sync</strong> 继承了 <strong>AQS</strong>，分为<strong>公平</strong>锁 <strong>FairSync</strong> 和<strong>非公平</strong>锁 <strong>NonfairSync</strong>。此处可以指定是否采用公平锁，<strong>FailSync 和 NonFailSync 亦为 Reentrantlock 的静态内部类，都继承于 Sync</strong>。</p>
<ul>
<li>公平锁：线程获取锁的顺序和调用 lock 的顺序一样，<strong>FIFO</strong>。</li>
<li>非公平锁：线程获取锁的顺序和调用 lock 的<strong>顺序无关</strong>。</li>
</ul>
<p><strong>ReentrantLock</strong> 默认使用<strong>非公平锁</strong>是基于<strong>性能</strong>考虑，公平锁为了保证线程规规矩矩地排队，需要增加阻塞和唤醒的时间开销。如果直接插队获取非公平锁，跳过了对队列的处理，速度会更快。</p>
<p>几个静态内部类的关系如下图所示。</p>
<img src="assets/image-20200509091238115.png" alt="image-20200509091238115" style="zoom:57%;" />

<p>Sync 是 ReentrantLock 内部实现的一个<strong>同步组件</strong>，它是 Reentrantlock 的一个静态内部类，<strong>继承于 AQS</strong>。源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 尝试获取非公平锁</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don't need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Methods relayed from outer class</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>公平锁 <strong>FairSync</strong> 类如下。是实现<strong>公平锁</strong>的 Sync 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 默认acquire1</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁 <strong>NonfairSync</strong> 源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-基本方法"><a href="#2-基本方法" class="headerlink" title="(2) 基本方法"></a>(2) 基本方法</h6><p><strong>lock()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();<span class="comment">// 代理到Sync的lock方法上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sync 的 lock 方法是<strong>抽象</strong>的，实际的 lock 会<strong>代理到 FairSync 或是 NonFairSync 上</strong>（根据用户的选择来决定，公平锁还是非公平锁）。</p>
<p><strong>lockInterruptibly()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 代理到sync的相应方法上，同lock方法的区别是此方法响应中断</span></span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法<strong>响应中断</strong>，当线程在阻塞中的时候，若被中断，会抛出 InterruptedException 异常 。</p>
<p><strong>tryLock()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);<span class="comment">// 代理到sync的相应方法上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryLock，尝试获取锁，成功则直接返回 true，不成功也不耽搁时间，立即返回 false。</p>
<p><strong>unlock()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);<span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放锁，调用 syn c的 <strong>release</strong> 方法，其实是 AQS 的 release 逻辑。</p>
<p><strong>newCondition()</strong></p>
<p>获取一个 <strong>conditon</strong>，ReentrantLock 支持多个 Condition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面这写方法的能大概梳理出 ReentrantLock 的处理逻辑，其内部定义了三个重要的静态内部类：<strong>Sync，NonFairSync，FairSync</strong>。Sync 作为 ReentrantLock 中公用的同步组件，继承了 AQS（要利用 AQS 复杂的顶层逻辑嘛，线程排队，阻塞，唤醒等等）；NonFairSync 和 FairSync 则都<strong>继承 Sync</strong>，调用 Sync 的<strong>公用逻辑</strong>，然后再在各自内部完成自己特定的逻辑（公平或非公平）。</p>
<p>所以接下来关于如何实现重入性，如何实现公平性，就得去看这几个静态内部类了。</p>
<h6 id="3-非公平可重入锁"><a href="#3-非公平可重入锁" class="headerlink" title="(3) 非公平可重入锁"></a>(3) 非公平可重入锁</h6><p>首先看看静态内部类 <strong>NonFairSync（非公平可重入锁）</strong>的实现。NonFairSync 和 FairSync 则都继承 Sync。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;  <span class="comment">// 继承Sync</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line">    <span class="comment">/** 获取锁 */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) <span class="comment">// CAS设置state状态，若原值是0，将其置为1</span></span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//将当前线程标记为已持有锁</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);<span class="comment">// 若设置失败，调用AQS的acquire方法，acquire又会调用我们下面重写的tryAcquire方法。这里说的调用失败有两种情况：1当前没有线程获取到资源，state为0，但是将state由0设置为1的时候，其他线程抢占资源，将state修改了，导致了CAS失败；2 state原本就不为0，也就是已经有线程获取到资源了，有可能是别的线程获取到资源，也有可能是当前线程获取的，这时线程又重复去获取，所以去tryAcquire中的nonfairTryAcquire我们应该就能看到可重入的实现逻辑了。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);<span class="comment">// 调用Sync中的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>nonfairTryAcquire()</strong> 方法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();<span class="comment">// 获取当前state值</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">// 若state为0，意味着没有线程获取到资源，CAS将state设置为1，并将当前线程标记我获取到排他锁的线程，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若state不为0，但是持有锁的线程是当前线程</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// state累加1</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="comment">// int类型溢出了</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 设置state，此时state大于1，代表着一个线程多次获锁，state的值即是线程重入的次数</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="comment">// 返回true，获取锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取锁失败了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单总结下流程：</p>
<p><strong>1. 先获取 state 值，若为 0，意味着此时没有线程获取到资源，CAS 将其设置为 1，设置成功则代表获取到排他锁了。</strong></p>
<p><strong>2. 若 state 大于 0，肯定有线程已经抢占到资源了，此时再去判断是否就是自己抢占的，是的话，state 累加，返回 true，重入成功，state 的值即是线程重入的次数</strong>。</p>
<p><strong>3. 其他情况，则获取锁失败</strong>。</p>
<h6 id="4-公平锁"><a href="#4-公平锁" class="headerlink" title="(4) 公平锁"></a>(4) 公平锁</h6><p><strong>FairSync</strong> 就是公平锁的实现。<strong>lock</strong> 方法很简单的一句话调用 AQS 的 <strong>acquire</strong> 方法。</p>
<h6 id="5-公平锁的实现"><a href="#5-公平锁的实现" class="headerlink" title="(5) 公平锁的实现"></a>(5) 公平锁的实现</h6><p>尝试<strong>获取锁</strong>，先来看<strong>公平锁</strong>的实现，<strong>lock</strong> 方法很简单的一句话调用 <strong>AQS</strong> 的 <strong>acquire</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123; acquire(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;    </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AQS</strong> 的 tryAcquire <strong>未做具体实现</strong>，因为是否获取锁成功是由<strong>子类决定</strong>的，我们直接来看 AQS 的子类 ReentrantLock 中 <strong>tryAcquire</strong> 的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);<span class="comment">// 直接调用AQS的模板方法acquire，acquire会调用下面我们重写的这个tryAcquire</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();<span class="comment">// 获取state值</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;<span class="comment">// 若state为0，意味着当前没有线程获取到资源，那就可以直接获取资源了吗？NO!这不就跟之前的非公平锁的逻辑一样了嘛。看下面的逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<span class="comment">// 判断在时间顺序上，是否有申请锁排在自己之前的线程，若没有，才能去获取，CAS设置state，并标记当前线程为持有排他锁的线程；反之，不能获取！这即是公平的处理方式。</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重入的处理逻辑，与上文一致，不再赘述</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>获取锁成功</strong>分为两种情况，第一个 if 判断 AQS 的 state 是否等于 0，表示锁<strong>没有人占有</strong>。接着，hasQueuedPredecessors 判断队列是否有排在前面的线程<strong>在等待锁</strong>，没有的话调用 compareAndSetState 使用 CAS 的方式修改 state，传入的 acquires 写死是1。最后线程获取锁成功，setExclusiveOwnerThread 将线程记录为独占锁的线程。</p>
<p>第二个 if 判断当前线程是否为<strong>独占锁</strong>的线程，因为 ReentrantLock 是<strong>可重入</strong>的，线程可以不停地 lock 来增加  state 的值，对应地需要 unlock 来解锁，直到 state 为零。</p>
<p><strong>可以看到，公平锁的大致逻辑与非公平锁是一致的，不同的地方在于有了 !hasQueuedPredecessors() 这个判断逻辑，即便 state 为 0，也不能贸然直接去获取，要先去看有没有还在排队的线程，若没有，才能尝试去获取，做后面的处理。反之，返回 false，获取失败。看看这个判断是否有排队中线程的逻辑</strong>。如果最后获取锁失败，下一步需要将线程加入到等待队列。</p>
<p>看看这个判断<strong>是否有排队线程</strong>的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; <span class="comment">// 尾结点</span></span><br><span class="line">    Node h = head; <span class="comment">// 头结点</span></span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 判断是否有排在自己之前的线程</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp; ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这个判断是否有排在自己之前的线程的逻辑稍微有些绕，由代码得知，有两种情况会返回 true，将此逻辑分解一下（注意：返回 true 意味着有其他线程申请锁比自己早，需要放弃抢占）</p>
<p><strong>1. h !=t &amp;&amp; (s = h.next) == null</strong>，这个逻辑成立的一种可能是 head 指向头结点，tail 此时还为 null。考虑这种情况：当其他某个线程去获取锁失败，需构造一个结点加入同步队列中（假设此时同步队列为空），在添加的时候，需要先创建一个无意义傀儡头结点（在 AQS 的 enq 方法中，这是个自旋 CAS 操作），有可能在将 head 指向此傀儡结点完毕之后，还未将 tail 指向此结点。很明显，此线程时间上优于当前线程，所以，返回 true，表示有等待中的线程且比自己来的还早。</p>
<p><strong>2. h != t &amp;&amp; (s = h.next) != null &amp;&amp; s.thread != Thread.currentThread()</strong>。同步队列中已经有若干排队线程且当前线程不是队列的老二结点，此种情况会返 回true。假如没有 s.thread !=Thread.currentThread() 这个判断的话，会怎么样呢？若当前线程已经在同步队列中是老二结点（头结点此时是个无意义的傀儡结点),此时持有锁的线程释放了资源，唤醒老二结点线程，老二结点线程重新 tryAcquire（此逻辑在 AQS 中的 acquireQueued 方法中），又会调用到 hasQueuedPredecessors，不加 s.thread !=Thread.currentThread() 这个判断的话，返回值就为 true，导致 tryAcquire 失败。</p>
<p>最后，来看看 ReentrantLock 的 tryRelease，定义在 <strong>Sync</strong> 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;<span class="comment">// 减去1个资源</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 若state值为0，表示当前线程已完全释放干净，返回true，上层的AQS会意识到资源已空出。若不为0，则表示线程还占有资源，只不过将此次重入的资源的释放了而已，返回false。</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小结：ReentrantLock 是一种可重入的，可实现公平性的互斥锁，它的设计基于 AQS 框架，可重入和公平性的实现逻辑都不难理解，每<strong>重入一次，state 就加 1</strong>，当然在释放的时候，也得一层一层释放。至于公平性，在尝试获取锁的时候多了一个判断：<strong>是否有比自己申请早的线程在同步队列中等待，若有，去等待；若没有，才允许去抢占</strong>。<strong>公平锁会关注队列里排队的情况，老老实实按照 FIFO 的次序；非公平锁只要有机会就抢占，才不管排队的事。</strong></p>
<p>Node 节点形成这样的结构:</p>
<img src="assets/queue.jpg" alt="锁队列" style="zoom:87%;" />

<p>nextWaiter 用于组成 <strong>Condition 等待队列</strong>。众所周知，<strong>Condition 只能用在已经获得锁的情况下</strong>，所以 Condition 等待队列不同于锁队列，Condition 队列结构如下图：</p>
<img src="assets/condition_queue.jpg" alt="Condition队列" style="zoom:87%;" />



<h4 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h4><h5 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>Condition 是在 Java5 中才出现的，它用来<strong>替代</strong>传统的 <strong>Object 类</strong> 的 <strong>wait</strong>()、<strong>notify</strong>() 实现线程间的<strong>协作</strong>，相比使用Object 的 wait()、notify()，使用 Condition 的 <strong>await</strong>()、<strong>signal</strong>() 这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用 Condition。</p>
<p>Condition 类能实现 synchronized 和 wait、notify 搭配的功能，另外比后者更灵活，Condition 可以实现<strong>多路通知</strong>功能，也就是在<strong>一个 Lock 对象</strong>里可以创建<strong>多个 Condition</strong>（即对象监视器）<strong>实例</strong>，线程对象可以注册在指定的 Condition 中，从而<strong>可以有选择的进行线程通知，在调度线程上更加灵活</strong>。而 synchronized 就相当于整个 Lock 对象中只有<strong>一个单一</strong>的 Condition 对象，所有的线程都注册在这个对象上。线程开始 notifyAll 时，需要通知所有的 WAITING 线程，没有选择权，会有相当大的效率问题。</p>
<p>Condition 对象是由 <strong>lock 对象</strong>所创建的，且同一个锁可以<strong>创建多个 Condition</strong> 的对象，即创建<strong>多个对象监视器</strong>，这样的好处就是可以<strong>指定唤醒线程</strong>，而 notify 唤醒的线程是随机唤醒一个。</p>
<p>1、Condition 是个<strong>接口</strong>，基本的方法就是 <strong>await</strong>() 和 <strong>signal</strong>() 方法。</p>
<p>2、Condition <strong>依赖于 Lock 接口</strong>，生成一个 Condition 的基本代码是 <strong>lock.newCondition()</strong>。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁对象</span></span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">// 通过锁对象获取多个Condition对象</span></span><br><span class="line"><span class="keyword">public</span> Condition conditionA = lock.newCondition();</span><br><span class="line"><span class="keyword">public</span> Condition conditionB = lock.newCondition();</span><br></pre></td></tr></table></figure>

<p>3、调用 Condition 的 <strong>await</strong>() 和 <strong>signal</strong>() 方法，都必须在 <strong>lock 保护之内</strong>，就是说<strong>必须</strong>在 lock.<strong>lock</strong>() 和 lock.<strong>unlock</strong>() <strong>之间</strong>才可以使用。</p>
<p>4、<strong>Conditon 中的 await() 对应 Object 的 wait()，Condition 中的 signal() 对应 Object 的 notify()，Condition 中的 signalAll() 对应 Object 的 notifyAll()。</strong></p>
<p>对于<strong>等待/通知</strong>机制，简化而言，就是等待一个条件，当条件不满足时，就进入<strong>等待</strong>，等条件满足时，就通知等待的线程开始执行。为了实现这种功能，需要进行 wait 的代码部分与需要进行通知的代码部分必须放在<strong>同一个对象监视器</strong>里面。执行才能实现多个阻塞的线程同步执行代码，等待与通知的线程也是同步进行。对于 wait/notify 而言，对象监视器与等待条件结合在一起 即 <code>synchronized（对象）</code> 利用该对象去调用 wait 以及 notify。但是对于 Condition 类，是对象监视器与条件分开，Lock 类来实现<strong>对象监视器</strong>，condition 对象来<strong>负责条件</strong>，去调用 await 以及 signal。</p>
<h5 id="2-源码解析-1"><a href="#2-源码解析-1" class="headerlink" title="2. 源码解析"></a>2. 源码解析</h5><p>Condition 接口源码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.concurrent.locks;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是 <strong>await 和 signal</strong> 方法。下面看看源码，先获取锁再获取 Condition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">Condition a = reentrantLock.newCondition();</span><br></pre></td></tr></table></figure>

<p>ReentrantLock 的 newCondition 方法如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见调用的是内部静态类 <strong>Sync 的 newCondition</strong> 方法。可见是直接返回了一个 <strong>ConditionObject</strong> 对象。<strong>ConditionObject</strong> <strong>实现了 Condition 接口</strong>，是 AbstractQueuedSynchronizer 的内部类（具体接口方法参考 AQS 源码）。Reentrantlock 的 newCondition 方法返回与某个 lock 实例相关联的 Condition 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-demo"><a href="#3-demo" class="headerlink" title="3. demo"></a>3. demo</h5><h6 id="1-官方demo"><a href="#1-官方demo" class="headerlink" title="(1) 官方demo"></a>(1) 官方demo</h6><p>下面的代码出自 Condition 接口源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得锁</span></span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 使用锁获得两个Condition</span></span><br><span class="line">    <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 当计数器为100时wait</span></span><br><span class="line">            <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">                <span class="comment">// notFull等待</span></span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将数据放入数组中</span></span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 直到计数器为100</span></span><br><span class="line">            ++count;</span><br><span class="line">            <span class="comment">// 唤醒notEmpty条件</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 消费数据</span></span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 直到计数器为0</span></span><br><span class="line">            --count;</span><br><span class="line">            <span class="comment">// 唤醒notFull条件</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-两个Condition"><a href="#2-两个Condition" class="headerlink" title="(2) 两个Condition"></a>(2) 两个Condition</h6><p><strong>接下来，使用 Condition 来实现等待/唤醒，并且能够唤醒制定线程。</strong></p>
<p>先写业务代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例化一个ReentrantLock对象</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 为线程A注册一个ConditionA</span></span><br><span class="line">    <span class="keyword">public</span> Condition conditionA = lock.newCondition();</span><br><span class="line">    <span class="comment">// 为线程B注册一个ConditionB</span></span><br><span class="line">    <span class="keyword">public</span> Condition conditionB = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"进入了awaitA方法"</span>);</span><br><span class="line">            <span class="keyword">long</span> timeBefore = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 执行conditionA等待</span></span><br><span class="line">            conditionA.await();</span><br><span class="line">            <span class="keyword">long</span> timeAfter = System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"被唤醒"</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"等待了: "</span> + (timeAfter - timeBefore)/<span class="number">1000</span>+<span class="string">"s"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">awaitB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"进入了awaitB方法"</span>);</span><br><span class="line">            <span class="keyword">long</span> timeBefore = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 执行conditionB等待</span></span><br><span class="line">            conditionB.await();</span><br><span class="line">            <span class="keyword">long</span> timeAfter = System.currentTimeMillis();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"被唤醒"</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"等待了: "</span> + (timeAfter - timeBefore)/<span class="number">1000</span> + <span class="string">"s"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signallA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"启动唤醒程序"</span>);</span><br><span class="line">            <span class="comment">// 唤醒所有注册conditionA的线程</span></span><br><span class="line">            conditionA.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">signallB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"启动唤醒程序"</span>);</span><br><span class="line">            <span class="comment">// 唤醒所有注册conditionB的线程</span></span><br><span class="line">            conditionB.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别实例化了<strong>两个</strong> Condition 对象，都是使用<strong>同一个 lock 注册</strong>。注意 <strong>conditionA 对象的等待和唤醒只对使用了conditionA 的线程有用</strong>，同理 conditionB 对象的等待和唤醒只对<strong>使用了</strong> conditionB 的线程有用。对比 Object 的 notifyAll 方法则是<strong>全部唤醒</strong>。这里 Condition 还是有优势的。</p>
<p>继续写两个线程的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyService service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyServiceThread1</span><span class="params">(MyService service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.awaitA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：MyServiceThread1 使用了 <strong>awaitA</strong>() 方法，<strong>持有</strong>的是 <strong>conditionA</strong>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServiceThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MyService service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyServiceThread2</span><span class="params">(MyService service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.awaitB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：MyServiceThread2 使用了 <strong>awaitB</strong>() 方法，<strong>持有</strong>的是 <strong>conditionB</strong>！</p>
<p>最后看启动类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    MyService service = <span class="keyword">new</span> MyService();</span><br><span class="line">    Runnable runnable1 = <span class="keyword">new</span> MyServiceThread1(service);</span><br><span class="line">    Runnable runnable2 = <span class="keyword">new</span> MyServiceThread2(service);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(runnable1, <span class="string">"a"</span>).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(runnable2, <span class="string">"b"</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程sleep2秒钟</span></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 唤醒所有持有conditionA的线程</span></span><br><span class="line">    service.signallA();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 唤醒所有持有conditionB的线程</span></span><br><span class="line">    service.sgnallB();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行 ApplicationCondition，来看控制台输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a进入了awaitA方法</span><br><span class="line">b进入了awaitB方法</span><br><span class="line">启动唤醒程序</span><br><span class="line">a被唤醒</span><br><span class="line">a等待了: 2s</span><br><span class="line">启动唤醒程序</span><br><span class="line">b被唤醒</span><br><span class="line">b等待了: 4s</span><br></pre></td></tr></table></figure>

<p>a 和 b 都进入各自的 await() 方法。首先执行的是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="comment">// 唤醒所有持有conditionA的线程</span></span><br><span class="line">service.signallA();</span><br></pre></td></tr></table></figure>

<p>使用 conditionA 的线程被<strong>唤醒</strong>，而后再唤醒使用 conditionB 的线程。学会使用 Condition，那来用它实现生产者消费者模式。</p>
<h4 id="Synchronized与ReentrantLock比较"><a href="#Synchronized与ReentrantLock比较" class="headerlink" title="Synchronized与ReentrantLock比较"></a>Synchronized与ReentrantLock比较</h4><h5 id="1-使用选择"><a href="#1-使用选择" class="headerlink" title="1. 使用选择"></a>1. 使用选择</h5><p>除非需要使用 ReentrantLock 的高级功能，否则<strong>优先使用 synchronized</strong>。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会<strong>确保锁的释放</strong>。性能已经不是选择的依据了。</p>
<h5 id="2-特点对比"><a href="#2-特点对比" class="headerlink" title="2. 特点对比"></a>2. 特点对比</h5><h6 id="1-锁的实现"><a href="#1-锁的实现" class="headerlink" title="(1) 锁的实现"></a>(1) <strong>锁的实现</strong></h6><p>synchronized 是 <strong>JVM</strong> 实现的，而 ReentrantLock 是 <strong>JDK</strong> 实现的。</p>
<p>synchronized 是 Java 原生的<strong>互斥同步锁</strong>，使用方便，对于 synchronized 修饰的方法或同步块，无需再显式释放锁。synchronized 底层是通过 monitorenter 和 monitorexit 两个字节码指令来实现加锁解锁操作的。</p>
<p>而 ReentrantLock 做为 <strong>API</strong> 层面的互斥锁（也就是在 API 层面需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），需要<strong>显式地去加锁解锁</strong>。ReentrantLock 实现 JUC 下面的 <strong>AQS</strong> 实现，需要显式的加锁与解锁。</p>
<h6 id="2-性能"><a href="#2-性能" class="headerlink" title="(2) 性能"></a>(2) <strong>性能</strong></h6><p>新版本 Java 对 synchronized 进行了很多<strong>优化</strong>（但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们），例如自旋锁等，synchronized 与 ReentrantLock 大致相同。<strong>能用 synchronized 尽量用</strong>。</p>
<h6 id="3-两者都是可重入锁"><a href="#3-两者都是可重入锁" class="headerlink" title="(3) 两者都是可重入锁"></a>(3) 两者都是可重入锁</h6><p>两者<strong>都是可重入锁</strong>。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<h6 id="4-拓展功能"><a href="#4-拓展功能" class="headerlink" title="(4) 拓展功能"></a>(4) 拓展功能</h6><p>ReentrantLock 比 synchronized 增加了一些<strong>高级功能</strong>。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p>
<ul>
<li><strong>ReentrantLock 提供了一种能够中断等待锁的线程的机制</strong>，通过 lock.lockInterruptibly() 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。当持有锁的线程长期<strong>不释放锁</strong>的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock <strong>可中断</strong>，而 synchronized <strong>不行</strong>。</li>
<li><strong>ReentrantLock 可以指定是公平锁还是非公平锁。而 synchronized 只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReentrantLock默认情况是非公平的，可以通过 ReentrantLock 类的 ReentrantLock(boolean fair) <strong>构造方法</strong>来制定是否是公平的。</li>
<li>synchronized 关键字与 wait() 和 notify()/notifyAll() 方法相结合可以实现<strong>等待/通知机制</strong>，ReentrantLock 类当然也可以实现，但是需要借助于 <strong>Condition</strong> 接口与 <strong>newCondition</strong>() 方法。Condition 是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个 Lock 对象中可以创建<strong>多个 Condition</strong> 实例（即对象监视器），<strong>线程对象可以注册在指定的 Condition 中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用 notify()/notifyAll() 方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合 Condition 实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而 synchronized 关键字就相当于整个 Lock 对象中只有<strong>一个</strong> Condition 实例，所有的线程都注册在它一个身上。如果执行 notifyAll() 方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而 Condition 实例的 signalAll() 方法 只会唤醒<strong>注册在</strong>该 Condition 实例中的所有等待线程。</li>
</ul>
<h3 id="四、ReentrantReadWriteLock"><a href="#四、ReentrantReadWriteLock" class="headerlink" title="四、ReentrantReadWriteLock"></a>四、ReentrantReadWriteLock</h3><h4 id="基础-2"><a href="#基础-2" class="headerlink" title="基础"></a>基础</h4><h5 id="1-概述-4"><a href="#1-概述-4" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>synchronized 和显式锁 ReentrantLock，对于<strong>同一受保护对象</strong>的访问，无论是<strong>读还是写</strong>，都要求获得<strong>==同样的锁==</strong>。一些场景中是不需要的，多个线程的<strong>读</strong>操作完全可以并行，在<strong>读多写少</strong>的场景中，让读操作并行可以明显提高性能。所以使用读写锁 ReentrantReadWriteLock 可以让<strong>读操作并行</strong>，又不影响一致性。</p>
<p>JCU 包中读写锁接口 (<strong>ReadWriteLock</strong>) 的重要实现类 <strong>ReentrantReadWriteLock</strong>。主要实现<strong>读共享，写互斥</strong>功能，对比单纯的互斥锁在共享资源使用场景为==<strong>频繁读取及少量修改</strong>==的情况下可以较好的提高性能。<strong>ReentrantReadWriteLock 表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁</strong>。</p>
<p><strong>只有 “读-读” 操作是可以并行的，“读-写” 和 “写-写” 都不可以</strong>。只有一个线程可以进行写操作，在<strong>获取写锁</strong>时，只有没有任何线程持有任何锁才可以获取到，在持有<strong>写锁</strong>时，其他任何线程都<strong>获取不到任何锁</strong>。在没有其他线程持有写锁的情况下，<strong>多个</strong>线程可以获取和持有<strong>读锁</strong>。</p>
<p>读写锁有以下三个重要的<strong>特性</strong>：</p>
<p>（1）<strong>公平选择性</strong>：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。</p>
<p>（2）<strong>可重入</strong>：ReentrantReadWriteLock 的读锁和写锁都是<strong>可重入</strong>的。</p>
<p>（3）<strong>锁降级</strong>：遵循获取写锁、获取读锁再释放写锁的次序，<strong>写锁能够降级成为读锁</strong>。</p>
<p>AQS 支持两种资源共享方式：<strong>独占式和共享式</strong>，这样方便使用者实现不同类型的<strong>同步组件</strong>，<strong>独占式</strong>如 ReentrantLock，<strong>共享式</strong>如 Semaphore，CountDownLatch，<strong>组合式</strong>的如 ReentrantReadWriteLock。这里的 ReentrantReadWriteLock 就是<strong>同时</strong>实现了独占式和共享式的锁。</p>
<h5 id="2-ReadWriteLock接口"><a href="#2-ReadWriteLock接口" class="headerlink" title="2. ReadWriteLock接口"></a>2. ReadWriteLock接口</h5><p><strong>ReadWriteLock</strong> 接口只定义了两个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用相应方法获取读锁或写锁，获取的读锁及写锁都是 <strong>Lock 接口</strong>的实现，可以如同使用 Lock 接口一样使用（其实也有一些特性是不支持的）。</p>
<h5 id="3-基本使用"><a href="#3-基本使用" class="headerlink" title="3. 基本使用"></a>3. 基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; dataMap = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line">    <span class="comment">// 定义读写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="comment">// 从读写锁获取读锁与写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock readLock = rwl.readLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock writeLock = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读方法加读锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="keyword">return</span> dataMap.get(key); &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123; readLock.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="keyword">return</span> dataMap.keySet().toArray(); &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123; readLock.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写方法加写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="keyword">return</span> dataMap.put(key, value); &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123; writeLock.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空加写锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123; dataMap.clear(); &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123; writeLock.unlock(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与普通重入锁使用的主要区别在于需要<strong>使用==不同==的锁对象引用读写锁</strong>，并且在读写时分别调用对应的锁。</p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>整体结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**读锁*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**写锁*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**使用给定的公平策略创建一个新的 ReentrantReadWriteLock*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根据参数选择sync的公平与非公平实现</span></span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">        readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">        writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**返回用于写入操作的锁*/</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">WriteLock <span class="title">writeLock</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> writerLock; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**返回用于读取操作的锁*/</span></span><br><span class="line">    <span class="keyword">public</span> ReentrantReadWriteLock.<span class="function">ReadLock <span class="title">readLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> readerLock; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这三个静态内部类在ReentrantLock中也有</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 读写锁静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-类的继承关系"><a href="#1-类的继承关系" class="headerlink" title="1. 类的继承关系"></a>1. 类的继承关系</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLock</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>ReentrantReadWriteLock 实现了 <strong>ReadWriteLock</strong> 接口，ReadWriteLock 接口定义了获取<strong>读锁和写锁的规范</strong>，具体需要实现类去实现；同时其还实现了 Serializable 接口，表示可以进行序列化，在源码中可以看到 ReentrantReadWriteLock 实现了自己的序列化逻辑。</p>
<h5 id="2-内部类"><a href="#2-内部类" class="headerlink" title="2. 内部类"></a>2. 内部类</h5><p>ReentrantReadWriteLock 有<strong>五个内部类</strong>，五个内部类之间也是相互关联的。内部类的关系如下图所示。</p>
<p><img src="assets/image-20200801141106142.png" alt="image-20200801141106142"></p>
<p>说明：如上图所示，Sync 继承自 AQS、NonfairSync（非公平锁）继承自 Sync类、FairSync（公平锁）继承自 Sync 类（通过构造函数传入的布尔值决定要<strong>构造哪一种 Sync 实例</strong>）；ReadLock 实现了 <strong>Lock</strong> 接口、WriteLock 也实现了 <strong>Lock</strong> 接口。</p>
<h6 id="1-Sync类"><a href="#1-Sync类" class="headerlink" title="(1) Sync类"></a>(1) <strong>Sync类</strong></h6><p>类的继承关系</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>说明：Sync 抽象类继承自 <strong>AQS</strong> 抽象类，Sync 类提供了对 ReentrantReadWriteLock 的支持。</p>
<p>Sync 类内部存在两个内部类，分别为 HoldCounter 和 <strong>ThreadLocalHoldCounter</strong>，其中 HoldCounter 主要与<strong>读锁配套</strong>使用，其中，HoldCounter 源码如下。<strong>HoldCounter</strong> 的作用就是<strong>保存当前线程持有共享锁的数量</strong>，这个数量必须要与线程绑定在一起，否则操作其他线程锁就会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">    <span class="comment">// 获取当前线程的TID属性的值</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：HoldCounter 主要有两个属性，count 和 tid，其中 count 表示某个<strong>读线程重入的次数</strong>，tid 表示该线程的 tid 字段的值，该字段可以用来<strong>唯一标识一个线程</strong>。ThreadLocalHoldCounter 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地线程计数器</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 重写初始化方法，在没有进行set的情况下，获取的都是该HoldCounter值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：ThreadLocalHoldCounter 重写了 <strong>ThreadLocal</strong> 的 <strong>initialValue</strong> 方法，ThreadLocal 类可以将<strong>线程与对象</strong>相关联。在没有进行 set 的情况下，get 到的均是 initialValue 方法里面生成的那个 <strong>HolderCounter</strong> 对象。</p>
<p>由于读锁是可以多个线程共享的，每个线程拥有自己的副本，用来保存自己的<strong>重入数</strong>。</p>
<p>Sync 类的属性如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 版本序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6317671515068378041L</span>;        </span><br><span class="line">    <span class="comment">// 高16位为读锁，低16位为写锁</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 读锁单位</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">    <span class="comment">// 读锁最大数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 写锁最大数量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 本地线程计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line">    <span class="comment">// 缓存的计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line">    <span class="comment">// 第一个读线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 第一个读线程的计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：该属性中包括了读锁、写锁线程的<strong>最大量</strong>。<strong>本地线程计数器</strong>等。</p>
<p>Sync 类的构造函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">Sync() &#123;</span><br><span class="line">    <span class="comment">// 初始化本地线程计数器</span></span><br><span class="line">    readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">    <span class="comment">// 设置AQS的状态</span></span><br><span class="line">    setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：在 Sync 的构造函数中<strong>设置了本地线程计数器和 AQS 的状态 state</strong>。</p>
<h5 id="3-读写状态的设计"><a href="#3-读写状态的设计" class="headerlink" title="3. 读写状态的设计"></a>3. 读写状态的设计</h5><p>AQS 中的 <strong>state</strong> 整数变量用于表示锁的状态，16 位给读锁用，16 位给写锁用，使用一个变量便于进行 CAS 操作，锁的等待队列其实也只有一个。</p>
<p>读写锁对于<strong>同步状态</strong>的实现是在一个<strong>整形变量</strong>上通过“<strong>按位切割使用</strong>”：将变量切割成两部分，<strong>高 16 位表示读，低 16 位表示写。</strong></p>
<img src="assets/image-20200511100248505.png" alt="image-20200511100248505" style="zoom:77%;" />

<p>假设当前同步状态值为 S，get 和 set 的操作如下：</p>
<p>（1）获取写状态：S&amp;0x0000FFFF：将高16位全部抹去。</p>
<p>（2）获取读状态： S&gt;&gt;&gt;16：无符号补0，右移16位。</p>
<p>（3）写状态加 1：S+1。</p>
<p>（4）读状态加 1：S+（1&lt;&lt;16）即 S + 0x00010000。</p>
<p>在代码层的判断中，如果 S 不等于 0，当写状态（S&amp;0x0000FFFF），而读状态（S&gt;&gt;&gt;16）大于 0，则表示该读写锁的读锁已被获取。</p>
<h5 id="4-写锁的获取与释放"><a href="#4-写锁的获取与释放" class="headerlink" title="4. 写锁的获取与释放"></a>4. <strong>写锁的获取与释放</strong></h5><p>看下 WriteLock 类中的 lock 和 unlock 方法： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到写锁的获取与释放就是<strong>调用的==独占式==锁的获取与释放</strong>，因此真实的实现就是 Sync 的 <strong>tryAcquire</strong> 和 <strong>tryRelease</strong>。</p>
<p><strong>写锁的获取，看下 tryAcquire：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前线程</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 写线程数量（即获取独占锁的重入数）</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前同步状态state != 0，说明已经有其他线程获取了读锁或写锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前state不为0，此时：如果写锁状态为0说明读锁此时被占用返回false；</span></span><br><span class="line">        <span class="comment">// 如果写锁状态不为0且写锁没有被当前线程持有返回false</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断同一线程获取写锁是否超过最大次数（65535），支持可重入</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 更新状态</span></span><br><span class="line">        <span class="comment">// 此时当前线程已持有写锁，现在是重入，所以只需要修改锁的数量即可。</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里说明此时c=0,读锁和写锁都没有被获取</span></span><br><span class="line">    <span class="comment">// writerShouldBlock表示是否阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置锁为当前线程所有</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <strong>exclusiveCount</strong> 方法表示<strong>占有写锁的线程数量</strong>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>

<p>说明：直接将状态 state 和（2^16 - 1）做<strong>与运算</strong>，其等效于将 state 模上2^16。写锁数量由 state 的<strong>低十六位</strong>表示。</p>
<p>从源代码可以看出，获取写锁的步骤如下：</p>
<p>（1）首先获取 c、w。c 表示<strong>当前锁</strong>状态；w 表示<strong>写线程数量</strong>。然后判断同步状态 state 是否为 0。如果 state != 0，说明<strong>已经有其他线程获取</strong>了读锁或写锁，执行(2)；否则执行(5)。</p>
<p>（2）如果锁状态不为零（c  !=  0），而写锁的状态为 0（w = 0），说明<strong>读锁此时被其他线程占用</strong>，所以当前线程<strong>不能获取写锁</strong>，自然返回 false。或者锁状态不为零，而写锁的状态也不为 0，但是获取写锁的线程不是当前线程，则当前线程也不能获取写锁。</p>
<p>（3）判断当前线程获取写锁是否超过<strong>最大次数</strong>，若超过，抛异常，反之更新同步状态（此时当前线程已获取写锁，更新是线程安全的），返回 true。</p>
<p>（4）如果 state 为 0，此时<strong>读锁或写锁都没有被获取</strong>，判断是否需要阻塞（公平和非公平方式实现不同），在非公平策略下总是不会被阻塞，在公平策略下会进行判断（判断同步队列中是否有等待时间更长的线程，若存在，则需要被阻塞，否则，无需阻塞），如果不需要阻塞，则 CAS 更新同步状态，若 CAS 成功则返回 true，失败则说明锁被别的线程抢去了，返回 false。如果需要阻塞则也返回 false。</p>
<p>（5）成功获取写锁后，将当前线程设置为<strong>占有写锁</strong>的线程，返回 true。</p>
<p>方法流程图如下：</p>
<img src="assets/image-20200511100816783.png" alt="image-20200511100816783" style="zoom:77%;" />

<p><strong>写锁的释放，tryRelease 方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若锁的持有者不是当前线程，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 写锁的新线程数</span></span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果独占模式重入数为0了，说明独占模式被释放</span></span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        <span class="comment">// 若写锁的新线程数为0，则将锁的持有者设置为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 设置写锁的新线程数</span></span><br><span class="line">    <span class="comment">// 不管独占模式是否被释放，更新独占重入数</span></span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写锁的释放过程还是相对而言比较简单的：首先查看当前线程<strong>是否为写锁的持有者</strong>，如果不是抛出异常。然后检查释放后写锁的线程数是否为 0，如果为 0 则表示<strong>写锁空闲</strong>了，释放锁资源将<strong>锁的持有线程</strong>设置为 null，否则释放仅仅只是一次重入锁而已，并不能将写锁的线程清空。</p>
<p>说明：此方法用于释放写锁资源，首先会判断该线程是否为独占线程，若不为独占线程，则抛出异常，否则，计算释放资源后的写锁的数量，若为 0，表示<strong>成功释放</strong>，资源不将被占用，否则，表示资源<strong>还被占用</strong>。其方法流程图如下。</p>
<img src="assets/image-20200511100946122.png" alt="image-20200511100946122" style="zoom:80%;" />

<h5 id="5-读锁的获取与释放"><a href="#5-读锁的获取与释放" class="headerlink" title="5. 读锁的获取与释放"></a>5. <strong>读锁的获取与释放</strong></h5><p>类似于写锁，读锁的 lock 和 unlock 的实际实现对应 Sync 的 <strong>tryAcquireShared 和 tryReleaseShared</strong> 方法。</p>
<p><strong>读锁的获取，看下 tryAcquireShared 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获取状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果写锁线程数 != 0 ，且独占锁不是当前线程则返回失败，因为存在锁降级</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 读锁数量</span></span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * readerShouldBlock():读锁是否需要等待（公平锁原则）</span></span><br><span class="line"><span class="comment">     * r &lt; MAX_COUNT：持有线程小于最大数（65535）</span></span><br><span class="line"><span class="comment">     * compareAndSetState(c, c + SHARED_UNIT)：设置读取锁状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 读线程是否应该被阻塞、并且小于最大值、并且比较设置成功</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="comment">// r == 0，表示第一个读锁线程，第一个读锁firstRead是不会加入到readHolds中</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123; <span class="comment">// 读锁数量为0</span></span><br><span class="line">            <span class="comment">// 设置第一个读线程</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            <span class="comment">// 读线程占用的资源数为1</span></span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程为第一个读线程，表示第一个读锁线程重入</span></span><br><span class="line">            <span class="comment">// 占用资源数加1</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 读锁数量不为0并且不为当前线程</span></span><br><span class="line">            <span class="comment">// 获取计数器</span></span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span></span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) </span><br><span class="line">                <span class="comment">// 获取当前线程对应的计数器</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>) <span class="comment">// 计数为0</span></span><br><span class="line">                <span class="comment">// 加入到readHolds中</span></span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 计数+1</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 其中 sharedCount 方法表示<strong>占有读锁的线程数量</strong>，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br></pre></td></tr></table></figure>

<p>说明：直接将 <strong>state 右移 16 位</strong>，就可以得到读锁的<strong>线程数量</strong>，因为 state 的高 16 位表示读锁，对应的<strong>低十六位表示写锁数量</strong>。</p>
<p>读锁获取锁的过程比写锁稍微复杂些，首先判断<strong>写锁是否为 0</strong> 并且当前线程不占有独占锁，直接返回；否则，判断读线程是否需要被阻塞并且读锁数量是否小于最大值并且比较设置状态成功，若当前<strong>没有读锁</strong>，则设置第一个读线程 firstReader 和 firstReaderHoldCount；若当前线程线程为第一个读线程，则增加 <strong>firstReaderHoldCount</strong>；否则，将设置当前线程对应的 <strong>HoldCounter</strong> 对象的值。流程图如下。</p>
<img src="assets/image-20200511101220609.png" alt="image-20200511101220609" style="zoom:80%;" />

<p>注意：更新成功后会在 firstReaderHoldCount 中或 readHolds (ThreadLocal类型的)的本线程副本中<strong>记录当前线程重入数</strong>（23行至43行代码），这是为了实现 jdk1.6 中加入的 getReadHoldCount() 方法的，这个方法能获取当前线程重入共享锁的次数(state 中记录的是多<strong>个线程的总重入次数</strong>)，加入了这个方法让代码复杂了不少，但是其原理还是很简单的：如果当前只有一个线程的话，还不需要动用 ThreadLocal，直接往 firstReaderHoldCount 这个成员变量里存重入数，当有第二个线程来的时候，<strong>就要动用 ThreadLocal 变量 readHolds 了，每个线程拥有自己的副本，用来保存自己的重入数</strong>。</p>
<p>fullTryAcquireShared 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123; <span class="comment">// 写线程数量不为0</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current) <span class="comment">// 不为当前线程</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123; <span class="comment">// 写线程数量为0并且读线程被阻塞</span></span><br><span class="line">            <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程为第一个读线程</span></span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前线程不为第一个读线程</span></span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123; <span class="comment">// 计数器不为空</span></span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123; <span class="comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span></span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT) <span class="comment">// 读锁数量为最大值，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123; <span class="comment">// 比较并且设置成功</span></span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123; <span class="comment">// 读线程数量为0</span></span><br><span class="line">                <span class="comment">// 设置第一个读线程</span></span><br><span class="line">                firstReader = current;</span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：在 tryAcquireShared 函数中，如果下列三个条件不满足（读线程是否应该被阻塞、小于最大值、比较设置成功）则会进行 fullTryAcquireShared 函数中，它用来保证相关操作可以成功。其逻辑与 tryAcquireShared 逻辑类似，不再累赘。</p>
<p><strong>读锁的释放，tryReleaseShared方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123; <span class="comment">// 当前线程为第一个读线程</span></span><br><span class="line">        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>) <span class="comment">// 读线程占用的资源数为1</span></span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 减少占用的资源</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 当前线程不为第一个读线程</span></span><br><span class="line">        <span class="comment">// 获取缓存的计数器</span></span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) <span class="comment">// 计数器为空或者计数器的tid不为当前正在运行的线程的tid</span></span><br><span class="line">            <span class="comment">// 获取当前线程对应的计数器</span></span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="comment">// 获取计数</span></span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123; <span class="comment">// 计数小于等于1</span></span><br><span class="line">            <span class="comment">// 移除</span></span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="comment">// 计数小于等于0，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 减少计数</span></span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 比较并进行设置</span></span><br><span class="line">            <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">            <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">            <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：此方法表示<strong>读锁线程释放锁</strong>。首先判断当前线程是否为第一个读线程 firstReader，若是，则判断第一个读线程占有的资源数 firstReaderHoldCount 是否为 1（表示没有重入），若是，则设置第一个读线程 firstReader 为空，否则，将第一个读线程占有的资源数 firstReaderHoldCount 减 1；若当前线程不是第一个读线程，那么首先会获取缓存计数器（上一个读锁线程对应的计数器 ），若计数器为空或者 tid 不等于当前线程的 tid 值，则<strong>获取当前线程的计数器</strong>，如果计数器的计数 count 小于等于 1，则移除当前线程对应的计数器，如果计数器的计数 count 小于等于0，则抛出异常，之后再减少计数即可。无论何种情况，都会进入无限循环，该循环可以确保成功设置状态 state。其流程图如下。</p>
<img src="assets/image-20200511101546410.png" alt="image-20200511101546410" style="zoom:80%;" />

<p>在读锁的获取、释放过程中，总是会有一个对象存在着，同时该对象在获取线程获取<strong>读锁是+1，释放读锁时-1</strong>，该对象就是 <strong>HoldCounter</strong>。</p>
<p>要明白 HoldCounter 就要先明白读锁。前面提<strong>过读锁的内在实现机制就是共享锁</strong>，对于共享锁其实我们可以稍微的认为它不是一个锁的概念，它更加像<strong>一个计数器</strong>的概念。一次共享锁操作就相当于一次计数器的操作，获取<strong>共享锁计数器 + 1</strong>，释放共享锁计数器 -1。只有当线程获取共享锁后才能对共享锁进行释放、重入操作。所以 <strong>HoldCounter</strong> 的作用就是<strong>保存当前线程持有共享锁的数量</strong>，这个数量必须要与线程绑定在一起，否则操作其他线程锁就会抛出异常。</p>
<p>先看读锁获取锁的部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123;<span class="comment">// r == 0，表示第一个读锁线程，第一个读锁firstRead是不会加入到readHolds中</span></span><br><span class="line">    firstReader = current;</span><br><span class="line">    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;<span class="comment">// 第一个读锁线程重入</span></span><br><span class="line">    firstReaderHoldCount++;    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;    <span class="comment">// 非firstReader计数</span></span><br><span class="line">    HoldCounter rh = cachedHoldCounter;<span class="comment">// readHoldCounter缓存</span></span><br><span class="line">    <span class="comment">// rh == null 或者 rh.tid != current.getId()，需要获取rh</span></span><br><span class="line">    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())    </span><br><span class="line">        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">        readHolds.set(rh);  <span class="comment">// 加入到readHolds中</span></span><br><span class="line">    rh.count++; <span class="comment">// 计数+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里为什么要搞一个 firstRead、firstReaderHoldCount 呢？而不是直接使用 else 那段代码？这是为了一个效率问题， firstReader 是不会放入到 readHolds 中的，如果读锁仅有一个的情况下就会避免查找 readHolds。可能就看这个代码还不是很理解 HoldCounter。我们先看 firstReader、firstReaderHoldCount 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure>

<p>这两个变量比较简单，一个表示<strong>线程</strong>，当然该线程是一个特殊的线程，一个是 firstReader 的重入计数。</p>
<p>HoldCounter 的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = Thread.currentThread().getId();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 HoldCounter 中仅有 count 和 tid 两个变量，其中 count 代表着<strong>计数器</strong>，tid 是线程的 id。但是如果要将一个对象和线程绑定起来仅记录 tid 肯定不够的，而且 HoldCounter 根本不能起到绑定对象的作用，只是记录线程 tid 而已。</p>
<p>如果要将<strong>一个线程和对象绑定在一起</strong>可以 <strong>ThreadLocal</strong> 实现。所以如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalHoldCounter 继承 <strong>ThreadLocal</strong>，并且重写了 <strong>initialValue</strong> 方法。</p>
<p>故而，HoldCounter 应该就是<strong>绑定线程上的一个计数器</strong>，而 ThradLocalHoldCounter 则是线程绑定的 ThreadLocal。从上面可以看到 ThreadLocal 将 HoldCounter 绑定到<strong>当前线程</strong>上，同时 HoldCounter 也持有线程 Id，这样在<strong>释放锁</strong>的时候才能知道 ReadWriteLock 里面缓存的上一个读取线程（cachedHoldCounter）<strong>是否是当前线程</strong>。这样做的好处是可以减少 ThreadLocal.get() 的次数，因为这也是一个耗时操作。需要说明的是这样 HoldCounter 绑定线程 id 而不绑定线程对象的原因是避免 HoldCounter 和 ThreadLocal 互相绑定而 GC 难以释放它们（尽管 GC 能够智能的发现这种引用而回收它们，但是这需要一定的代价），所以其实这样做只是为了帮助 GC 快速回收对象而已。</p>
<h5 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h5><p>在线程持有<strong>读锁</strong>的情况下，该线程<strong>不能取得写锁</strong>(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</p>
<p>在线程持有<strong>写锁</strong>的情况下，该线程<strong>可以继续获取读锁</strong>（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</p>
<p>仔细想想，这个设计是合理的：因为当线程获取读锁的时候，可能有其他线程<strong>同时也在持有读锁</strong>，因此不能把获取读锁的线程“升级”为写锁；而对于<strong>获得写锁</strong>的线程，它<strong>一定独占了读写锁</strong>，因此<strong>可以继续让它获取读锁</strong>，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个<strong>写锁就“降级”为了读锁</strong>。</p>
<p>综上：<strong>一个线程要想同时持有写锁和读锁，必须先获取写锁再获取读锁；写锁可以“降级”为读锁；读锁不能“升级”为写锁。</strong></p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>[1] : <a href="https://www.cnblogs.com/xiaoxi/p/7651360.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/7651360.html</a> Condition 详解</li>
<li>[2] : <a href="https://www.cnblogs.com/xiaoxi/p/9140541.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/9140541.html</a> “ReentrantReadWriteLock 源码详解”</li>
<li>[3]：<a href="https://blog.csdn.net/qq_41174684/article/details/90442798" target="_blank" rel="noopener">https://blog.csdn.net/qq_41174684/article/details/90442798</a> “Synchronized底层原理详解”</li>
<li>[4]：<a href="https://www.cnblogs.com/xiaoxi/p/9140541.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaoxi/p/9140541.html</a> “读写锁源码解析”</li>
<li>[5]：《深入理解JVM》</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/C-7%20%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%8E%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" rel="next" title="ShiftJava/A Java/C-7 线程池与定时任务">
                <i class="fa fa-chevron-left"></i> ShiftJava/A Java/C-7 线程池与定时任务
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/F-3%20%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" rel="prev" title="ShiftJava/A Java/F-3 面试题总结">
                ShiftJava/A Java/F-3 面试题总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#锁与互斥同步"><span class="nav-number">1.</span> <span class="nav-text">锁与互斥同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、概述"><span class="nav-number">1.1.</span> <span class="nav-text">一、概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础"><span class="nav-number">1.1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-不安全示例"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1. 不安全示例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-锁概述"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">2. 锁概述</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、Synchronized锁"><span class="nav-number">1.2.</span> <span class="nav-text">二、Synchronized锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-synchronized基本用法"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2. synchronized基本用法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-同步代码块和实例方法"><span class="nav-number">1.2.1.2.1.</span> <span class="nav-text">(1) 同步代码块和实例方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-同步静态方法"><span class="nav-number">1.2.1.2.2.</span> <span class="nav-text">(2) 同步静态方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-同步一个类"><span class="nav-number">1.2.1.2.3.</span> <span class="nav-text">(3) 同步一个类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-应用"><span class="nav-number">1.2.1.2.4.</span> <span class="nav-text">(4) 应用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-synchronized的特性"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">3. synchronized的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-可重入性"><span class="nav-number">1.2.1.3.1.</span> <span class="nav-text">(1) 可重入性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-内存可见性"><span class="nav-number">1.2.1.3.2.</span> <span class="nav-text">(2) 内存可见性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-死锁"><span class="nav-number">1.2.1.3.3.</span> <span class="nav-text">(3) 死锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-性能"><span class="nav-number">1.2.1.3.4.</span> <span class="nav-text">(4) 性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized原理解析"><span class="nav-number">1.2.2.</span> <span class="nav-text">synchronized原理解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-编译测试"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1. 编译测试</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-synchronized同步语句块的情况"><span class="nav-number">1.2.2.1.1.</span> <span class="nav-text">(1) synchronized同步语句块的情况</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-synchronized修饰方法的情况"><span class="nav-number">1.2.2.1.2.</span> <span class="nav-text">(2) synchronized修饰方法的情况</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-加锁详解与Monitor对象"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2. 加锁详解与Monitor对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-对象头"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">3. 对象头</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#锁优化"><span class="nav-number">1.2.3.</span> <span class="nav-text">锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-锁粗化"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">1. 锁粗化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-锁消除"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">2. 锁消除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-内置锁优化升级过程"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">3. 内置锁优化升级过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-偏向锁"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">4. 偏向锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-轻量级锁"><span class="nav-number">1.2.3.5.</span> <span class="nav-text">5. 轻量级锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-自旋锁"><span class="nav-number">1.2.3.6.</span> <span class="nav-text">6. 自旋锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-问题"><span class="nav-number">1.2.3.7.</span> <span class="nav-text">7. 问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、显式锁"><span class="nav-number">1.3.</span> <span class="nav-text">三、显式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Lock接口"><span class="nav-number">1.3.1.</span> <span class="nav-text">Lock接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-1"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-源码分析"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">2. 源码分析</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">1.3.2.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-2"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">1. 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-可重入性-1"><span class="nav-number">1.3.2.1.1.</span> <span class="nav-text">(1) 可重入性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-公平锁-非公平锁"><span class="nav-number">1.3.2.1.2.</span> <span class="nav-text">(2) 公平锁/非公平锁</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-源码解析"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">2. 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-构造方法"><span class="nav-number">1.3.2.2.1.</span> <span class="nav-text">(1) 构造方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-基本方法"><span class="nav-number">1.3.2.2.2.</span> <span class="nav-text">(2) 基本方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-非公平可重入锁"><span class="nav-number">1.3.2.2.3.</span> <span class="nav-text">(3) 非公平可重入锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-公平锁"><span class="nav-number">1.3.2.2.4.</span> <span class="nav-text">(4) 公平锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-公平锁的实现"><span class="nav-number">1.3.2.2.5.</span> <span class="nav-text">(5) 公平锁的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Condition"><span class="nav-number">1.3.3.</span> <span class="nav-text">Condition</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-3"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-源码解析-1"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">2. 源码解析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-demo"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3. demo</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-官方demo"><span class="nav-number">1.3.3.3.1.</span> <span class="nav-text">(1) 官方demo</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-两个Condition"><span class="nav-number">1.3.3.3.2.</span> <span class="nav-text">(2) 两个Condition</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronized与ReentrantLock比较"><span class="nav-number">1.3.4.</span> <span class="nav-text">Synchronized与ReentrantLock比较</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-使用选择"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">1. 使用选择</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-特点对比"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">2. 特点对比</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-锁的实现"><span class="nav-number">1.3.4.2.1.</span> <span class="nav-text">(1) 锁的实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-性能"><span class="nav-number">1.3.4.2.2.</span> <span class="nav-text">(2) 性能</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-两者都是可重入锁"><span class="nav-number">1.3.4.2.3.</span> <span class="nav-text">(3) 两者都是可重入锁</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-拓展功能"><span class="nav-number">1.3.4.2.4.</span> <span class="nav-text">(4) 拓展功能</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、ReentrantReadWriteLock"><span class="nav-number">1.4.</span> <span class="nav-text">四、ReentrantReadWriteLock</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-4"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ReadWriteLock接口"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">2. ReadWriteLock接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-基本使用"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">3. 基本使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码解析"><span class="nav-number">1.4.2.</span> <span class="nav-text">源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-类的继承关系"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">1. 类的继承关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-内部类"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">2. 内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-Sync类"><span class="nav-number">1.4.2.2.1.</span> <span class="nav-text">(1) Sync类</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-读写状态的设计"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">3. 读写状态的设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-写锁的获取与释放"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">4. 写锁的获取与释放</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-读锁的获取与释放"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">5. 读锁的获取与释放</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-总结"><span class="nav-number">1.4.2.6.</span> <span class="nav-text">6. 总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.4.3.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
