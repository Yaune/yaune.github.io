<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] Redis ClusterRedis Cluster 是 Redis 的分布式解决方案。当遇到单机内存、并发、流量等瓶颈时可以采用 cluster 架构的解决方案。 数据分布理论分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。   需要重点关注的是数据分区方案。常见的分区规则有哈希分区和顺序分区两种。  哈">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;I 缓存&#x2F;F Redis Cluster">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] Redis ClusterRedis Cluster 是 Redis 的分布式解决方案。当遇到单机内存、并发、流量等瓶颈时可以采用 cluster 架构的解决方案。 数据分布理论分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。   需要重点关注的是数据分区方案。常见的分区规则有哈希分区和顺序分区两种。  哈">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725160327603.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200527211945450.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725160720936.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725160920319.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200527211351109.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725161459583.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200527211438246.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725161638088.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;7896890-452c3152054c36f1.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;7896890-d5ab644e76e9cc87.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725161813217.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725162120051.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200430131036174.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725162706475.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725162844161.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725163306020.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725164111323.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725164004531.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725164256992.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725164733508.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200430182045402.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;I%20缓存&#x2F;assets&#x2F;image-20200430182110432.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;F%20Redis%20Cluster&#x2F;assets&#x2F;image-20200725160327603.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/I 缓存/F Redis Cluster/"/>





  <title>ShiftJava/I 缓存/F Redis Cluster | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/I%20%E7%BC%93%E5%AD%98/F%20Redis%20Cluster/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/I 缓存/F Redis Cluster</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:17+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p>Redis Cluster 是 Redis 的<strong>分布式</strong>解决方案。当遇到单机<strong>内存、并发、流量等瓶颈</strong>时可以采用 cluster 架构的解决方案。</p>
<h4 id="数据分布理论"><a href="#数据分布理论" class="headerlink" title="数据分布理论"></a>数据分布理论</h4><p>分布式数据库首先要解决把<strong>整个数据集</strong>按照分区规则<strong>映射到多个节点</strong>的问题，即把数据集划分到多个节点上，每个<strong>节点</strong>负责整体数据的一个<strong>子集</strong>。</p>
<img src="assets/image-20200725160327603.png" alt="image-20200725160327603" style="zoom:56%;" />

<p>需要重点关注的是<strong>数据分区方案</strong>。常见的分区规则有<strong>哈希分区和顺序分区</strong>两种。</p>
<ul>
<li><strong>哈希分区</strong>：离散度好，数据分布业务无关，无法顺序访问。代表产品：<strong>Redis Cluster</strong>、Dynamo、Cassandra。</li>
<li><strong>顺序分区</strong>：离散度易倾斜、数据分布业务相关，可顺序访问。代表产品：<strong>HBase</strong>、Bigtable。</li>
</ul>
<h5 id="1-哈希数据分区方案"><a href="#1-哈希数据分区方案" class="headerlink" title="1. 哈希数据分区方案"></a>1. 哈希数据分区方案</h5><p>常见的哈希分区规则有几种。</p>
<h6 id="1-节点取模分区"><a href="#1-节点取模分区" class="headerlink" title="(1) 节点取模分区"></a>(1) 节点取模分区</h6><p>使用特定的数据，如 Redis 的<strong>键或用户 ID</strong>，再根据节点数量 N 使用公式：<strong>hash（key）% N</strong> 计算出哈希值，用来决定数据<strong>映射</strong>到哪一个节点上。</p>
<p>这种方案存在一个问题：当节点数量变化时，如扩容或收缩节点，数据节点映射关系都需要<strong>重新计算再哈希</strong>，会导致数据的大量<strong>重新迁移</strong>。所以扩容时通常采用<strong>翻倍扩容</strong>，避免数据映射全部被打乱导致全量迁移的情况。</p>
<h6 id="2-一致性哈希分区"><a href="#2-一致性哈希分区" class="headerlink" title="(2) 一致性哈希分区"></a>(2) 一致性哈希分区</h6><p>一致性哈希分区<strong>（Distributed Hash Table）</strong>实现思路是为系统中<strong>每个节点分配一个 token</strong>，范围一般在 0~232，这些token 构成一个<strong>哈希环</strong>。数据读写执行节点查找操作时，先根据 key 计算 hash 值，然后<strong>顺时针找到第一个大于等于该哈希值</strong>的 token节点 并存储数据。</p>
<img src="assets/image-20200527211945450.png" alt="image-20200527211945450" style="zoom:67%;" />

<p>与哈希取余分区相比，一致性哈希分区将 <strong>增减节点的影响限制在相邻节点</strong>。以上图为例，如果在 node1 和 node2 之间增加 node5，则只有 node2 中的一部分数据会迁移到 node5；如果去掉 node2，则原 node2 中的数据只会迁移到 node4 中，只有 node4 会受影响。</p>
<p>一致性哈希分区的主要问题在于，当 <strong>节点数量较少</strong> 时，增加或删减节点，对<strong>单个节点</strong>的影响可能很大，<strong>造成数据的严重不平衡</strong>。还是以上图为例，如果去掉 node2，node4 中的数据由总数据的 1/4 左右变为 1/2 左右，与其他节点相比负载过高。</p>
<p>正因为一致性哈希分区的这些缺点，一些分布式系统采用<strong>虚拟槽</strong>对一致性哈希进行改进，比如 Dynamo 系统。</p>
<h6 id="3-虚拟槽分区"><a href="#3-虚拟槽分区" class="headerlink" title="(3) 虚拟槽分区"></a>(3) 虚拟槽分区</h6><p>这种方案在 <strong>一致性哈希分区的基础上</strong>，引入了 <strong>虚拟节点</strong> 的概念。Redis 集群使用的便是该方案，其中的<strong>虚拟节点</strong>称为 <strong>槽（slot）</strong>。槽是介于数据和实际节点之间的虚拟概念，每个实际节点包含一定数量的槽，每个槽包含哈希值在一定范围内的数据。</p>
<p>虚拟槽分区巧妙地使用了<strong>哈希空间</strong>，使用分散度良好的<strong>哈希函数</strong>把所有数据映射到一个<strong>固定范围</strong>的整数集合中，<strong>整数定义为槽（slot）</strong>。这个范围一般<strong>远远大于节点数</strong>，比如 Redis Cluster 槽范围是 <strong>0~16383</strong>。</p>
<p>在使用了槽的一致性哈希分区中，<strong>槽是数据管理和迁移的基本单位</strong>。槽<strong>解耦</strong>了<strong>数据和实际节点</strong> 之间的关系，增加或删除节点对系统的影响很小。仍以上图为例，系统中有 <code>4</code> 个实际节点，假设为其分配 <code>16</code> 个槽(0- 15)，那么 槽 0 - 3 位于 node1；4 - 7 位于 node2；以此类推….</p>
<p>如果此时删除 node2，只需要<strong>将槽 4-7 重新分配</strong>即可，例如槽 4-5 分配给 node1，槽 6 分配给 node3，槽 7 分配给 node4；可以看出删除 node2 后，数据在其他节点的分布<strong>仍然较为均衡</strong>。</p>
<p>采用大范围槽的主要目的是为了方便数据<strong>拆分和集群扩展</strong>。</p>
<h5 id="2-Redis数据分区"><a href="#2-Redis数据分区" class="headerlink" title="2. Redis数据分区"></a>2. Redis数据分区</h5><p><strong>Redis Cluster</strong> 就是<strong>采用虚拟槽分区</strong>。所有的键根据哈希函数映射到 <strong>0~16383</strong> 整数槽内，计算公式：<strong>slot=CRC16（key）&amp;16383</strong>。每一个节点负责维护一部分<strong>槽以及槽所映射的键值数据</strong>。</p>
<img src="assets/image-20200725160720936.png" alt="image-20200725160720936" style="zoom:50%;" />

<p>一个集群中分槽的例子。</p>
<img src="assets/image-20200725160920319.png" alt="image-20200725160920319" style="zoom:60%;" />

<p>当前集群有 <strong>5 个节点</strong>，每个节点平均大约负责 <strong>3276</strong> 个槽。由于采用<strong>高质量的哈希算法</strong>，每个槽所映射的数据通常比较均匀，将数据平均划分到 5 个节点进行<strong>数据分区</strong>。</p>
<p>数据分区是<strong>分布式存储的核心</strong>，理解和灵活运用数据分区规则对于掌握 Redis Cluster 非常有帮助。 </p>
<h4 id="集群的作用与功能限制"><a href="#集群的作用与功能限制" class="headerlink" title="集群的作用与功能限制"></a>集群的作用与功能限制</h4><h5 id="1-集群的作用"><a href="#1-集群的作用" class="headerlink" title="1. 集群的作用"></a>1. 集群的作用</h5><p><strong>数据分区：</strong> 数据分区 (或称数据分片)是集群最核心的功能。集群将数据分散到多个节点，<strong>一方面</strong> 突破了 Redis 单机内存大小的限制，<strong>存储容量大大增加</strong>；<strong>另一方面</strong> 每个主节点都可以对外提供读服务和写服务，<strong>大大提高了集群的响应能力</strong>。Redis 单机<strong>内存</strong>大小受限问题，在介绍持久化和主从复制时都有提及，如果单机内存太大，<code>bgsave</code> 和 <code>bgrewriteaof</code> 的 <code>fork</code> 操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出。</p>
<p><strong>高可用：</strong> 集群支持<strong>主从复制</strong>和主节点的 <strong>自动故障转移</strong> （与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。</p>
<h5 id="2-集群的功能限制"><a href="#2-集群的功能限制" class="headerlink" title="2. 集群的功能限制"></a>2. 集群的功能限制</h5><p>Redis 集群相对单机在功能上存在一些限制。</p>
<ul>
<li><strong>key 批量操作支持有限</strong>。如 mset、mget，目前只支持具有<strong>相同 slot 值</strong>的 key 执行批量操作。对于映射为不同 slot 值的 key 由于执行 mget、mget 等操作可能存在于多个节点上因此不被支持。</li>
<li><strong>key 事务操作支持有限</strong>。同理只支持多 key 在<strong>同一节点</strong>上的事务操作，当多个 key 分布在不同的节点上时无法使用事务功能。</li>
<li>key 作为数据分区的最小粒度，因此<strong>不能将一个大</strong>的键值对象如 hash、lis t等映射到不同的节点。</li>
<li>不支持多数据库空间。单机下的 Redis 可以支持 16 个数据库，集群模式下<strong>只能使用一个</strong>数据库空间，即 db0。</li>
<li>复制结构<strong>只支持一层</strong>，从节点只能复制主节点，不支持嵌套树状复制结构。</li>
</ul>
<h4 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h4><p>集群架构如下。集群中的每一个 Redis 节点都 <strong>互相两两相连</strong>，客户端任意 <strong>直连</strong> 到集群中的 <strong>任意一台</strong>，就可以对其他 Redis 节点进行 <strong>读写</strong> 的操作。</p>
<img src="assets/image-20200527211351109.png" alt="image-20200527211351109" style="zoom:60%;" />

<p>搭建集群的三个步骤：</p>
<ul>
<li>准备节点。</li>
<li>节点握手。</li>
<li>分配槽。</li>
</ul>
<h5 id="1-节点准备"><a href="#1-节点准备" class="headerlink" title="1. 节点准备"></a>1. 节点准备</h5><p>Redis 集群一般由多个节点组成，节点数量<strong>至少</strong>为 <strong>6 个</strong>才能保证组成完整 ，高可用的集群。每个节点需要<strong>开启配置 cluster-enabled yes</strong>，让 Redis 运行在集群模式下。</p>
<p>建议为集群内所有节点<strong>统一目录</strong>，一般划分三个目录：<strong>conf、data、log</strong>，分别存放<strong>配置、数据和日志</strong>相关文件。把 6 个节点<strong>配置</strong>统一放在 conf 目录下，集群相关配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#节点端口</span></span><br><span class="line">port 6379</span><br><span class="line"><span class="comment"># 开启集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="comment"># 节点超时时间，单位毫秒</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line"><span class="comment"># 集群内部配置文件</span></span><br><span class="line">cluster-config-file <span class="string">"nodes-6379.conf"</span></span><br></pre></td></tr></table></figure>

<p>其他配置和<strong>单机模式一致</strong>即可，这里配置文件命名规则 <strong>redis-{port}.conf</strong>，准备好配置后<strong>启动所有节点</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server conf/redis-6379.conf</span><br><span class="line">redis-server conf/redis-6380.conf</span><br><span class="line">redis-server conf/redis-6381.conf</span><br><span class="line">redis-server conf/redis-6382.conf</span><br><span class="line">redis-server conf/redis-6383.conf</span><br><span class="line">redis-server conf/redis-6384.conf</span><br></pre></td></tr></table></figure>

<p>检查<strong>节点日志</strong>是否正确，日志内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="built_in">log</span>/redis-6379.log</span><br><span class="line">* No cluster configuration found, I<span class="string">'m cfb28ef1deee4e0fa78da86abe5d24566744411e</span></span><br><span class="line"><span class="string"># Server started, Redis version 3.0.7</span></span><br><span class="line"><span class="string">* The server is now ready to accept connections on port 6379</span></span><br></pre></td></tr></table></figure>

<p>6379 节点<strong>启动成功</strong>，第一次启动时如果没有集群配置文件，它会<strong>自动创建</strong>一份。</p>
<p>集群模式的 Redis 除了原有的配置文件之外<strong>又加了一份集群配置文件</strong>。当集群内节点信息发生变化，如添加节点、节点下线、故障转移等。节点会<strong>自动保存</strong>集群状态到配置文件中。需要注意的是，Redis <strong>自动维护集群配置文件</strong>，不要手动修改，防止节点重启时产生集群信息错乱。 </p>
<p>节点 6379 首次启动后生成集群配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat data/nodes-6379.conf</span></span><br><span class="line">cfb28ef1deee4e0fa78da86abe5d24566744411e 127.0.0.1:6379 myself,master - 0 0 0 connected</span><br><span class="line">vars currentEpoch 0 lastVoteEpoch 0</span><br></pre></td></tr></table></figure>

<p>文件内容记录了集群<strong>初始状态</strong>，这里最重要的是<strong>节点 ID</strong>，它是一个 40 位 16 进制字符串，用于<strong>唯一标识集群内一个节点</strong>，之后很多集群操作都要借助于节点 ID 来完成。注意：节点 ID <strong>不同于运行 ID</strong>。节点 ID 在集群初始化时<strong>只创建一次</strong>，节点重启时会加载集群配置文件进行<strong>重用</strong>，而 Redis 的<strong>运行 ID 每次重启都会变化</strong>。</p>
<p>在节点 6380 执行 <strong>cluster nodes</strong> 命令获取集群节点状态：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt;cluster nodes</span><br><span class="line">8e41673d59c9568aa9d29fb174ce733345b3e8f1 127.0.0.1:6380 myself,master - 0 0 0 connected</span><br></pre></td></tr></table></figure>

<p>每个节点目前只能识别出<strong>自己</strong>的节点信息。如果启动 6 个节点，但每个节点彼此并不知道对方的存在，需要通过<strong>节点握手</strong>让 6 个节点彼此<strong>建立联系</strong>从而组成一个集群。</p>
<h5 id="2-节点握手"><a href="#2-节点握手" class="headerlink" title="2. 节点握手"></a>2. 节点握手</h5><p>节点握手是指一批运行在集群模式下的节点通过 <strong>Gossip 协议</strong>彼此通信，达到感知对方的过程。节点握手是集群彼此通信的第一步，由<strong>客户端</strong>发起命令：<strong>cluster meet {ip} {port}</strong>。两个结点直接先用 <strong>meet</strong> 消息进行握手（成功后回复 pong 消息），然后使用 <strong>ping/pong</strong> 消息维护<strong>正常通信</strong>。</p>
<img src="assets/image-20200725161459583.png" alt="image-20200725161459583" style="zoom:54%;" />

<p>只需要在集群内<strong>任意节点</strong>上执行 cluster meet 命令<strong>加入新节点</strong>，握手状态会通过<strong>消息</strong>在集群内<strong>传播</strong>，这样其他节点会<strong>自动发现新节点并发起握手流程</strong>。</p>
<p>最后执行 cluster nodes 命令确认 6 个节点都彼此感知并组成集群：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">4fa7eac4080f0b667ffeab9b87841da49b84a6e4 127.0.0.1:6384 master - 0 1468073975551</span><br><span class="line">5 connected</span><br><span class="line">cfb28ef1deee4e0fa78da86abe5d24566744411e 127.0.0.1:6379 myself,master - 0 0 0 connected</span><br><span class="line">be9485a6a729fc98c5151374bc30277e89a461d8 127.0.0.1:6383 master - 0 1468073978579</span><br><span class="line">4 connected</span><br><span class="line">40622f9e7adc8ebd77fca0de9edfe691cb8a74fb 127.0.0.1:6382 master - 0 1468073980598</span><br><span class="line">3 connected</span><br><span class="line">8e41673d59c9568aa9d29fb174ce733345b3e8f1 127.0.0.1:6380 master - 0 1468073974541</span><br><span class="line">1 connected</span><br><span class="line">40b8d09d44294d2e23c7c768efc8fcd153446746 127.0.0.1:6381 master - 0 1468073979589</span><br><span class="line">2 connected</span><br></pre></td></tr></table></figure>

<p>节点建立握手之后集群<strong>还不能正常工作</strong>，这时集群处于<strong>下线状态</strong>，所有的数据读写都被禁止。因为目前所有的<strong>槽</strong>没有分配到节点，因此<strong>集群无法完成槽到节点的映射</strong>。只有当 16384 个槽<strong>全部分配</strong>给节点后，集群才进入<strong>在线状态</strong>。 </p>
<h5 id="3-分配数据槽"><a href="#3-分配数据槽" class="headerlink" title="3. 分配数据槽"></a>3. 分配数据槽</h5><p>Redis 集群把所有的数据映射到 <strong>16384 个槽</strong>中。每个 key 会映射为一个<strong>固定的槽</strong>，只有当节点分配了槽，才能响应和这些槽关联的键命令。</p>
<img src="assets/image-20200527211438246.png" alt="image-20200527211438246" style="zoom: 50%;" />

<p>Redis 集群中内置了 <strong>16384</strong> 个哈希槽。当客户端连接到 Redis 集群之后，会同时得到一份关于这个 <strong>集群的配置信息</strong>，当客户端具体对某一个 <strong>key 值</strong>进行操作时，会计算出它的一个 <strong>Hash 值</strong>，然后把<strong>结果对 16384  求余数</strong>，这样每个 key 都会<strong>对应一个编号在 0-16383 之间的哈希槽</strong>，Redis 会根据节点数量 <strong>大致均等</strong> 的将哈希槽映射到不同的节点。 </p>
<p>通过 <strong>cluster addslots</strong> 命令为节点分配槽。这里利用 bash 特性批量设置槽（slots），命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 cluster addslots &#123;0...5461&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6380 cluster addslots &#123;5462...10922&#125;</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6381 cluster addslots &#123;10923...16383&#125;</span><br></pre></td></tr></table></figure>

<p>把 16384 个 slot 平均分配给 6379、6380、6381 <strong>三个</strong>节点。执行 cluster info 查看集群状态，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster info</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:5</span><br><span class="line">cluster_my_epoch:0</span><br><span class="line">cluster_stats_messages_sent:4874</span><br><span class="line">cluster_stats_messages_received:4726</span><br></pre></td></tr></table></figure>

<p>当前集群状态是 OK，集群进入<strong>在线状态</strong>。所有的槽都已经分配给节点，执行 cluster nodes 命令可以看到<strong>节点和槽的分配关系</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster nodes</span><br><span class="line">4fa7eac4080f0b667ffeab9b87841da49b84a6e4 127.0.0.1:6384 master - 0 1468076240123</span><br><span class="line">5 connected</span><br><span class="line">cfb28ef1deee4e0fa78da86abe5d24566744411e 127.0.0.1:6379 myself,master - 0 0 0 connected</span><br><span class="line">0-5461</span><br><span class="line">be9485a6a729fc98c5151374bc30277e89a461d8 127.0.0.1:6383 master - 0 1468076239622</span><br><span class="line">4 connected</span><br><span class="line">40622f9e7adc8ebd77fca0de9edfe691cb8a74fb 127.0.0.1:6382 master - 0 1468076240628</span><br><span class="line">3 connected</span><br><span class="line">8e41673d59c9568aa9d29fb174ce733345b3e8f1 127.0.0.1:6380 master - 0 1468076237606</span><br><span class="line">1 connected</span><br><span class="line">5462-10922</span><br><span class="line">40b8d09d44294d2e23c7c768efc8fcd153446746 127.0.0.1:6381 master - 0 1468076238612</span><br><span class="line">2 connected</span><br><span class="line">10923-16383</span><br></pre></td></tr></table></figure>

<p>目前还有三个节点<strong>没有使用</strong>，作为一个完整的集群，每个负责<strong>处理槽的节点应该具有从节点</strong>，保证当它出现故障时可以<strong>自动进行故障转移</strong>。集群模式下，Reids 节点角色分为<strong>主节点和从节点</strong>。首次启动的节点和<strong>被分配槽的节点都是主节点</strong>，从节点负责<strong>复制</strong>主节点槽信息和相关的数据。</p>
<p>使用 <strong>cluster replicate {nodeId}</strong> 命令让一个节点成为<strong>从节点</strong>。其中命令执行必须在对应的<strong>从节点上</strong>执行，nodeId 是要复制主节点的节点 ID，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6382&gt;cluster replicate cfb28ef1deee4e0fa78da86abe5d24566744411e</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6383&gt;cluster replicate 8e41673d59c9568aa9d29fb174ce733345b3e8f1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6384&gt;cluster replicate 40b8d09d44294d2e23c7c768efc8fcd153446746</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>Redis 集群模式下的主从复制使用了之前介绍的 Redis 复制流程，依然<strong>支持全量和部分复制。</strong>复制（replication）完成后，整个集群的<strong>结构</strong>如下图所示。</p>
<img src="assets/image-20200725161638088.png" alt="image-20200725161638088" style="zoom:56%;" />

<p>上述即依照 Redis 协议<strong>手动建立</strong>一个集群。它由 6 个节点构成，3 个主节点负责处理槽和相关数据，3 个从节点负责故障转移。手动比较复杂，Redis 官方提供了 <strong>redis-trib.rb</strong> 工具方便我们快速搭建集群，用这个工具需要安装 Ruby 环境。</p>
<h5 id="4-集群搭建完整demo"><a href="#4-集群搭建完整demo" class="headerlink" title="4. 集群搭建完整demo"></a>4. 集群搭建完整demo</h5><h6 id="1-第一步：创建集群节点配置文件"><a href="#1-第一步：创建集群节点配置文件" class="headerlink" title="(1) 第一步：创建集群节点配置文件"></a>(1) 第一步：创建集群节点配置文件</h6><p>首先找一个地方创建一个名为 <strong>redis-cluster</strong> 的目录：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/Desktop/redis-cluster</span><br></pre></td></tr></table></figure>

<p>然后创建<strong>六个</strong>配置文件，分别命名为：<strong>redis_7000.conf/redis_7001.conf…..redis_7005.conf</strong>，然后根据不同的端口号修改对应的端口值就好了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后台执行</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line">port 7000</span><br><span class="line"><span class="comment"># 为每一个集群节点指定一个 pid_file</span></span><br><span class="line">pidfile ~/Desktop/redis-cluster/redis_7000.pid</span><br><span class="line"><span class="comment"># 启动集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="comment"># 每一个集群节点都有一个配置文件，这个文件是不能手动编辑的。确保每一个集群节点的配置文件不通</span></span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line"><span class="comment"># 集群节点的超时时间，单位：ms，超时后集群会认为该节点失败</span></span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"><span class="comment"># 最后将 appendonly 改成 yes(AOF 持久化)</span></span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>

<p>记得把对应上述配置文件中<strong>根端口对应的配置都修改掉</strong> (port/ pidfile/ cluster-config-file)。</p>
<h6 id="2-第二步：分别启动6个Redis实例"><a href="#2-第二步：分别启动6个Redis实例" class="headerlink" title="(2) 第二步：分别启动6个Redis实例"></a>(2) 第二步：分别启动6个Redis实例</h6><p>根据 6 个配置文件启动 6 个 Redis 实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server ~/Desktop/redis-cluster/redis_7000.conf</span><br><span class="line">redis-server ~/Desktop/redis-cluster/redis_7001.conf</span><br><span class="line">redis-server ~/Desktop/redis-cluster/redis_7002.conf</span><br><span class="line">redis-server ~/Desktop/redis-cluster/redis_7003.conf</span><br><span class="line">redis-server ~/Desktop/redis-cluster/redis_7004.conf</span><br><span class="line">redis-server ~/Desktop/redis-cluster/redis_7005.conf</span><br></pre></td></tr></table></figure>

<p>然后执行 <strong>ps -ef | grep redis</strong> 查看是否启动成功：</p>
<img src="assets/7896890-452c3152054c36f1.png" style="zoom:50%;" />

<p>可以看到 <code>6</code> 个 Redis 节点都以集群的方式成功启动了，<strong>但是现在每个节点还处于独立的状态</strong>，也就是说它们每一个都各自成了一个集群，还没有互相联系起来，需要手动地把他们之间建立起联系。</p>
<h6 id="3-第三步：建立集群"><a href="#3-第三步：建立集群" class="headerlink" title="(3) 第三步：建立集群"></a>(3) 第三步：建立集群</h6><p>执行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005</span><br></pre></td></tr></table></figure>

<p>这里 <strong>–replicas 1</strong> 的意思是：希望为集群中的<strong>每个主节点创建一个从节点</strong>。</p>
<p>观察控制台输出：</p>
<img src="assets/7896890-d5ab644e76e9cc87.png" style="zoom:50%;" />

<p>看到 <strong>[OK]</strong> 的信息就表示集群已经搭建成功了，这里成功创建了<strong>三主三从</strong>的集群。</p>
<h6 id="4-第四步：验证集群"><a href="#4-第四步：验证集群" class="headerlink" title="(4) 第四步：验证集群"></a>(4) 第四步：验证集群</h6><p>先使用 <strong>redis-cli</strong> 任意连接一个节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -h 127.0.0.1 -p 7000</span><br><span class="line">127.0.0.1:7000&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>-c 表示集群模式；-h 指定 ip 地址；-p 指定端口。</strong></li>
</ul>
<p>然后随便 <code>set</code> 一些值观察控制台输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7000&gt; SET name wmyskxz</span><br><span class="line">-&gt; Redirected to slot [5798] located at 127.0.0.1:7001</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7001&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到这里 Redis 自动进行了 <strong>Redirected 操作</strong>跳转到了 7001 这个实例上。</p>
<p>再使用 <strong>cluster info (查看集群信息) 和 cluster nodes</strong> (查看节点列表) 来分别看看：(任意节点输入均可)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7001&gt; CLUSTER INFO</span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:2</span><br><span class="line">cluster_stats_messages_ping_sent:1365</span><br><span class="line">cluster_stats_messages_pong_sent:1358</span><br><span class="line">cluster_stats_messages_meet_sent:4</span><br><span class="line">cluster_stats_messages_sent:2727</span><br><span class="line">cluster_stats_messages_ping_received:1357</span><br><span class="line">cluster_stats_messages_pong_received:1369</span><br><span class="line">cluster_stats_messages_meet_received:1</span><br><span class="line">cluster_stats_messages_received:2727</span><br><span class="line"></span><br><span class="line">127.0.0.1:7001&gt; CLUSTER NODES</span><br><span class="line">56a04742f36c6e84968cae871cd438935081e86f 127.0.0.1:7003@17003 slave 4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 0 1584428884000 4 connected</span><br><span class="line">4ec8c022e9d546c9b51deb9d85f6cf867bf73db6 127.0.0.1:7000@17000 master - 0 1584428884000 1 connected 0-5460</span><br><span class="line">e2539c4398b8258d3f9ffa714bd778da107cb2cd 127.0.0.1:7005@17005 slave a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 0 1584428885222 6 connected</span><br><span class="line">d31cd1f423ab1e1849cac01ae927e4b6950f55d9 127.0.0.1:7004@17004 slave 236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 0 1584428884209 5 connected</span><br><span class="line">236cefaa9cdc295bc60a5bd1aed6a7152d4f384d 127.0.0.1:7001@17001 myself,master - 0 1584428882000 2 connected 5461-10922</span><br><span class="line">a3406db9ae7144d17eb7df5bffe8b70bb5dd06b8 127.0.0.1:7002@17002 master - 0 1584428884000 3 connected 10923-16383</span><br><span class="line">127.0.0.1:7001&gt;</span><br></pre></td></tr></table></figure>



<h4 id="结点通信机制"><a href="#结点通信机制" class="headerlink" title="结点通信机制"></a>结点通信机制</h4><h5 id="1-通信流程"><a href="#1-通信流程" class="headerlink" title="1. 通信流程"></a>1. 通信流程</h5><p>在分布式存储中需要提供维护<strong>节点元数据信息</strong>的机制，所谓<strong>元数据</strong>是指：节点负责哪些数据，是否出现故障等状态信息。常见的元数据维护方式分为：<strong>集中式和 P2P 方式</strong>。Redis 集群采用 P2P 的 <strong>Gossip（流言）协议</strong>，Gossip 协议工作<strong>原理</strong>就是<strong>节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播</strong>。</p>
<img src="assets/image-20200725161813217.png" alt="image-20200725161813217" style="zoom:50%;" />

<p>通信过程说明：</p>
<ul>
<li><p>集群中的<strong>每个节点</strong>都会单独开辟一个 <strong>TCP</strong> 通道，用于节点之间彼此通信，通信端口号在基础端口上加 <strong>10000</strong>。 </p>
</li>
<li><p>每个节点在<strong>固定周期</strong>内通过特定规则选择几个节点发送 <strong>ping 消息</strong>。</p>
</li>
<li><p>接收到 ping 消息的节点用 <strong>pong 消息</strong>作为响应。</p>
</li>
</ul>
<p>集群中每个节点通过一定规则挑选要通信的节点，每个节点可能知道全部节点，也可能仅知道部分节点，只要这些节点彼此可以正常通信，<strong>最终它们会达到一致的状态。</strong>当节点出故障、新节点加入、主从角色变化、槽信息变更等事件发生时，通过<strong>不断的 ping/pong 消息通信</strong>，经过一段时间后所有的节点都会知道<strong>整个集群全部节点的最新状态</strong>，从而达到<strong>集群状态同步</strong>的目的。</p>
<h5 id="2-Gossip消息"><a href="#2-Gossip消息" class="headerlink" title="2. Gossip消息"></a>2. Gossip消息</h5><p>Gossip 协议的主要职责就是<strong>信息交换</strong>。信息交换的载体就是节点彼此发送的 Gossip 消息。常用的 Gossip 消息可分为：<strong>ping 消息、pong 消息、meet 消息、fail 消息</strong>等。</p>
<p><img src="assets/image-20200725162120051.png" alt="image-20200725162120051"></p>
<ul>
<li><p><strong>meet 消息</strong>：用于通知<strong>新节点</strong>加入。</p>
</li>
<li><p><strong>ping 消息</strong>：用于检测节点<strong>是否在线和交换彼此状态</strong>信息。ping 消息发送<strong>封装</strong>了自身节点和部分其他节点的状态数据。</p>
</li>
<li><p><strong>pong 消息</strong>：当接收到 ping、meet 消息时，作为响应<strong>消息回复</strong>给发送方确认消息正常通信。</p>
</li>
<li><p><strong>fail 消息</strong>：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息。</p>
</li>
</ul>
<p>所有的消息格式划分为：<strong>消息头和消息体</strong>。消息头包含发送节点自身状态数据，接收节点根据消息头就可以获取到发送节点的相关数据。</p>
<p>集群内所有的消息都<strong>采用相同的消息头结构</strong> clusterMsg，是一个<strong>结构体</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> clusterMsgData &#123;</span><br><span class="line">    <span class="comment">/*ping,meet,pong消息体*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/*gossip消息结构数组*/</span></span><br><span class="line">        clusterMsgDataGossip gossip[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125; ping;</span><br><span class="line">    <span class="comment">/*FAIL消息体*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        clusterMsgDataFail about;</span><br><span class="line">    &#125; fail;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>消息体</strong> clusterMsgData 定义发送消息的<strong>数据</strong>。通过消息头判断消息类型和状态，通过消息体传送数据。</p>
<h5 id="3-消息类型"><a href="#3-消息类型" class="headerlink" title="3. 消息类型"></a>3. 消息类型</h5><p>集群中的节点采用 <strong>固定频率（每秒10次）</strong> 的 <strong>定时任务</strong> 进行通信相关的工作：判断是否需要发送消息及消息类型、确定接收节点、发送消息等。如果集群状态发生了变化，如增减节点、槽状态变更，通过节点间的通信，所有节点会很快得知整个集群的状态，使<strong>集群收敛</strong>。</p>
<p>节点间发送的消息主要分为 5 种：<strong>meet 消息、ping 消息、pong 消息、fail 消息、publish 消息</strong>。不同的消息类型，通信协议、发送的频率和时机、接收节点的选择等是不同的：</p>
<ul>
<li><strong>MEET 消息：</strong> 在节点握手阶段，当节点收到客户端的 <code>CLUSTER MEET</code> 命令时，会向新加入的节点发送 <code>MEET</code> 消息，请求新节点加入到当前集群；新节点收到 MEET 消息后会回复一个 <code>PONG</code> 消息。</li>
<li><strong>PING 消息</strong>： 集群里每个节点每秒钟会选择部分节点发送 PING 消息，接收者收到消息后会回复一个 PONG 消息。PING 消息的内容是自身节点和部分其他节点的状态信息，作用是彼此交换信息，以及检测节点是否在线。PING 消息使用 Gossip 协议发送，接收节点的选择兼顾了收敛速度和带宽成本，具体规则如下：(1)随机找 5 个节点，在其中选择最久没有通信的 1 个节点；(2)扫描节点列表，选择最近一次收到 PONG 消息时间大于 cluster_node_timeout / 2 的所有节点，防止这些节点长时间未更新。</li>
<li><strong>PONG消息：</strong> <code>PONG</code> 消息封装了自身状态数据。可以分为两种：<strong>第一种</strong> 是在接到 <code>MEET/PING</code> 消息后回复的 <code>PONG</code> 消息；<strong>第二种</strong> 是指节点向集群广播 <code>PONG</code> 消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播 <code>PONG</code> 消息。</li>
<li><strong>FAIL 消息：</strong> 当一个主节点判断另一个主节点进入 <code>FAIL</code> 状态时，会向集群广播这一 <code>FAIL</code> 消息；接收节点会将这一 <code>FAIL</code> 消息保存起来，便于后续的判断。</li>
<li><strong>PUBLISH 消息：</strong> 节点收到 <code>PUBLISH</code> 命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该 <code>PUBLISH</code> 命令。</li>
</ul>
<h4 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h4><p>集群伸缩的原理可以抽象为<strong>槽和对应数据在不同节点之间的灵活移动</strong>。</p>
<h5 id="1-集群扩容"><a href="#1-集群扩容" class="headerlink" title="1. 集群扩容"></a>1. 集群扩容</h5><p><strong>集群扩容</strong>即需要把当前的节点的<strong>槽和数据分一些给新的节点</strong>（进行移动）。过程如下：</p>
<ul>
<li>准备新节点。</li>
<li>加入集群。</li>
<li>迁移槽和数据。</li>
<li>添加从节点。</li>
</ul>
<p>新节点的配置建议和集群内的节点配置保持一致，配置后启动新节点即可。</p>
<p>新节点采用 <strong>cluster meet 命令</strong>加入到集群中。一旦与集群任意一个建立联系，各个节点最终都会感知。但是新加入的节点没有分配槽也是无法进行读写的。</p>
<p>需要迁移槽和数据。确定哪些槽需要迁移到新的节点，保证迁移之后各个节点槽的数量<strong>均匀</strong>。数据迁移是<strong>逐个槽</strong>进行的。</p>
<p>迁移过程如下：</p>
<img src="assets/image-20200430131036174.png" alt="image-20200430131036174" style="zoom:67%;" />

<p>图示如下：</p>
<img src="assets/image-20200725162706475.png" alt="image-20200725162706475" style="zoom:50%;" />

<p>可以使用 redis-trib 工具的 <strong>reshard</strong> 命令简化数据迁移的工作量。由于槽用于 <strong>hash 运算</strong>本身顺序没有意义，所以<strong>无需强制要求节点负责槽的顺序性</strong>，也就是一个结点上槽不一定是连续的。数据迁移完之后，集群又多了一个主节点，此时应该再给这个结点<strong>配备一个从节点</strong>。此时扩容完成。</p>
<h5 id="2-集群收缩"><a href="#2-集群收缩" class="headerlink" title="2. 集群收缩"></a>2. 集群收缩</h5><p>集群收缩即将集群中的节点<strong>安全下线</strong>。如果下线的结点分配有槽，需要将槽和数据迁移到其他节点，保证下线后数据完整性。需要将这个下线节点的槽<strong>均匀的分配到其他节点</strong>。也可以使用 <strong>reshard</strong> 命令进行迁移（reshard 迁移的目标节点只能有一个，所以下图需要执行 3 次命令）。如下图。</p>
<img src="assets/image-20200725162844161.png" alt="image-20200725162844161" style="zoom:50%;" />

<p>如果下线的结点没有负责槽或本身是从节点，则可以通过 <strong>cluster forget {downNodeId}</strong> 通知集群内其他节点<strong>忘记</strong>这个下线结点，这样其他节点就不再与这个结点进行 Gossip 通信，之后即可正常关闭。建议生产环境用 <strong>redis-trib.rb 工具的 del-node</strong> 命令进行节点下线。</p>
<p>如果下线主节点但<strong>不下线从节点</strong>，则需要把这个存留的从节点<strong>指向</strong>其他节点。如果主从节点<strong>都下线</strong>，建议先下线从节点再下线主节点，防止不必要的<strong>全量复制</strong>。</p>
<h4 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h4><p>与客户端通信时，Redis 集群为了追求性能最大化，<strong>没有采用代理</strong>的方式，而是采用<strong>客户端直连节点</strong>的方式进行。</p>
<h5 id="1-请求重定向MOVED"><a href="#1-请求重定向MOVED" class="headerlink" title="1. 请求重定向MOVED"></a>1. 请求重定向MOVED</h5><p>在集群模式下，<strong>Redis 接收任何键相关命令时首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身（槽命中），则处理键命令；否则回复 MOVED 重定向错误，告诉客户端请求正确的节点。这个过程就是 MOVED 重定向。</strong></p>
<img src="assets/image-20200725163306020.png" alt="image-20200725163306020" style="zoom:50%;" />

<p>可以借助 <strong>cluster keyslot {key}</strong> 命令返回 key 对应的<strong>槽</strong>。</p>
<img src="assets/image-20200725164111323.png" alt="image-20200725164111323" style="zoom:60%;" />

<p><strong>返回的重定向信息包含了键所对应的槽和负责该槽的节点地址。</strong>根据这些信息客户端可以<strong>重新发起请求</strong>。注意：集群中的节点对于不属于它的键操作<strong>只回复重定向响应，不会进行命令转发</strong>。</p>
<p>Redis 槽计算是根据<strong>键</strong>的有效部分使用 <strong>CRC16 函数计算出散列值</strong>，然后对 16383 <strong>取模</strong>，可以得到<strong>映射的槽</strong>。计算出键对应的槽之后，需要查找槽对应的节点。集群内通过<strong>消息交换</strong>每个节点都会知道<strong>所有节点的槽信息</strong>，内部<strong>保存</strong>在 <strong>clusterState</strong> 结构中。</p>
<p>根据 MOVED 重定向机制，客户端可以随机连接集群内<strong>任一节点</strong>获取键的信息。</p>
<h5 id="2-Smart客户端"><a href="#2-Smart客户端" class="headerlink" title="2. Smart客户端"></a>2. Smart客户端</h5><p>但是如果<strong>每次都进行重定向</strong>肯定会有性能开销，所以可以使用 <strong>Smart 客户端</strong>。大多数开发语言的 Redis 客户端都采用 Smart 客户端支持集群协议。Smart 客户端通过在<strong>内部维护 slot（槽）与 node（节点）的映射关系</strong>，在本地就可以实现键到节点的查找。</p>
<p>如 JedisCluster 会选择一个运行节点，获取节点与槽的信息，解析之后缓存在本地，并为<strong>每个节点创建唯一的 JedisPool 连接池</strong>。早期版本 Jedis 每次收到重定向错误（可能由于集群伸缩导致槽迁移）都会<strong>更新</strong>节点和槽的信息。然而如果每次都更新 slots 信息的话可能会产生 <strong>cluster slots 风暴</strong>问题，影响客户端性能。后续的版本对这个机制进行了改进，减少了客户端更新 slots 缓存的次数，可以容忍一定的重定向请求。</p>
<p>客户端执行多节点命令和操作（如 keys，flushall）的时候会遍历多个节点完成操作。</p>
<h5 id="3-ASK重定向"><a href="#3-ASK重定向" class="headerlink" title="3. ASK重定向"></a>3. ASK重定向</h5><p>如果当键<strong>正在迁移</strong>的时候集群收到对键的操作命令，如果数据<strong>都在</strong>原来的节点，直接执行并返回。然而此时可能一部分键在旧的节点上，而<strong>另一部分数据已经迁移到新的节点</strong>上，这时候集群就会回复 <strong>ASK 重定向异常</strong>。客户端解析这个异常信息并再次发起请求。</p>
<img src="assets/image-20200725164004531.png" alt="image-20200725164004531" style="zoom:62%;" />

<p>执行流程如下：</p>
<img src="assets/image-20200725164256992.png" alt="image-20200725164256992" style="zoom:50%;" />

<p>注意在集群下进行<strong>键迁移时</strong>如果使用 <strong>mget、mset 等批量操作</strong>时，slot 迁移数据期间由于键列表<strong>无法保证在同一结点</strong>，可能导致<strong>大量错误</strong>。虽然集群环境下优先使用 Pipeline 方式进行批量操作，但是 Pipeline 依然无法解决上述问题。所以啊，迁移键的时候最好就别进行批量操作了，慎用！</p>
<blockquote>
<p><strong>ASK 重定向和 MOVED 重定向的区别？</strong></p>
</blockquote>
<p>两者都是对客户端的重定向控制，但是有本质区别。</p>
<p><strong>ASK 重定</strong>：向说明集群正在<strong>进行 slot 数据迁移</strong>，客户端无法知道什么时候迁移完成，因此只能<strong>临时性的重定向</strong>，客户端也<strong>不会更新 slots 缓存</strong>。</p>
<p><strong>MOVED 重定向</strong>：说明键对应的槽已经<strong>明确迁移到了</strong>新的节点，类似于<strong>永久重定向</strong>，客户端需要<strong>更新 slots 缓存</strong>。</p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>Redis 集群自身实现了高可用，<strong>不需要 Sentinel</strong>，但是机制类似于 Redis Sentinel。</p>
<h5 id="1-故障发现"><a href="#1-故障发现" class="headerlink" title="1. 故障发现"></a>1. 故障发现</h5><p>集群间通过 <strong>ping/pong</strong> 消息实现结点通信，消息不但可以传播节点槽信息，还能传播其他<strong>状态信息</strong>，比如：主从状态、节点故障等。故障发现也是基于消息传播机制实现的，也是分为<strong>主观下线和客观下线</strong>。节点的状态使用 <strong>clusterState</strong> 结构体的 <strong>flags 属性</strong>进行定义。</p>
<h6 id="1-主观下线"><a href="#1-主观下线" class="headerlink" title="(1) 主观下线"></a>(1) 主观下线</h6><p>集群中每个节点都会定期给其他节点发送 ping 消息，接收节点回复 pong 进行响应。如果响应超时，则发送节点认为对方存在故障，标记为<strong>主观下线状态</strong>（pfail 状态）。主观下线是<strong>一个节点</strong>对于另一个节点不可用的判断，仅代表这一个节点的意见，可能存在<strong>误判</strong>。</p>
<h6 id="2-客观下线"><a href="#2-客观下线" class="headerlink" title="(2) 客观下线"></a>(2) 客观下线</h6><p>当某个节点认为一个节点不可用时，会得到主观下线的结论，然后相应的节点状态会随消息在集群内传播。客观下线则是需要<strong>多个</strong>节点<strong>达成共识</strong>，都认为一个节点不可用。<strong>当半数以上持有槽的主节点都标记某个结点是主观下线时，触发客观下线流程。</strong>注意只是<strong>主节点</strong>参与决策。每个节点收到的其他节点发送的<strong>主观下线信息</strong>是具有<strong>有效期</strong>的，如果时间过长，主观下线信息会过期。</p>
<p>集群中的节点<strong>每次</strong>收到其他节点的主观下线（pfail）状态时，<strong>都会尝试触发客观下线</strong>。首先会计算有效的主观下线报告数量，如果数量大于槽节点的<strong>一半</strong>，则更新为<strong>客观下线</strong>，同时向集群广播下线节点的 fail 消息。</p>
<p>广播下线节点的 fail 消息可以通知集群内所有的节点<strong>标记故障节点为客观下线状态</strong>并立即生效，同时通知故障节点的<strong>从节点触发故障转移流程</strong>（如果故障的就是从节点就不需要了）。如果不可用的节点持有槽，则需要进行<strong>故障转移</strong>。</p>
<h5 id="2-故障转移与恢复"><a href="#2-故障转移与恢复" class="headerlink" title="2. 故障转移与恢复"></a>2. 故障转移与恢复</h5><p>故障节点客观下线后，如果是持有槽的<strong>主节点</strong>，则需要在它的<strong>从节点</strong>中选出一个替换它，实现集群的高可用。</p>
<p>过程如下：</p>
<p><strong>(1) 资格检查。</strong>每个从节点<strong>都要</strong>检查最后与主节点直接的短线时间，如果过长则不具有资格。这时候可能有多个有资格成为主节点的从节点。</p>
<p><strong>(2) ==设置选举时间==。</strong>每个从节点都会触发选举来选择<strong>自己作为主节点</strong>。但是选谁？当从节点符合故障转移资格后，<strong>更新</strong>触发故障选举的时间，只有达到时间后才能触发选举。每个<strong>从节点进行选举的时间是不一样</strong>的，这个触发时间记录在 clusterState 结构体中。这里采用<strong>延迟触发机制</strong>。<strong>==复制偏移量越大的从节点的触发选举的时间越早==，因为它的数据完整性最高。</strong></p>
<img src="assets/image-20200725164733508.png" alt="image-20200725164733508" style="zoom:50%;" />

<p>所以从节点中<strong>复制偏移量最大</strong>的节点将<strong>提前触发选举</strong>，它成为主节点的几率也<strong>更大</strong>。</p>
<p><strong>(3) 发起选举</strong>。当从节点定时任务监测到达故障选举时间到达之后，发起选举流程，即更新配置纪元和广播选举消息。</p>
<p><strong>(4) 选举投票</strong>。持有槽的主节点才会处理选举消息，每个节点具有<strong>一票</strong>。</p>
<p><strong>(5) 替换主节点</strong>。选举成功的从节点触发替换主节点操作。当前从节点取消复制变成主节点。之后自己接管原来主节点负责的槽。然后向集群<strong>广播</strong>自己成为主节点的状态信息。</p>
<p>整个故障转移过程也会产生大量的日志，可以模拟一下故障场景，好好看看日志。</p>
<h4 id="集群运维"><a href="#集群运维" class="headerlink" title="集群运维"></a>集群运维</h4><h5 id="1-带宽消耗问题"><a href="#1-带宽消耗问题" class="headerlink" title="1. 带宽消耗问题"></a>1. 带宽消耗问题</h5><p>集群的带宽消耗主要为：<strong>读写命令消耗 + Gossip 消息消耗</strong>。Gossip 消息<strong>别太频繁</strong>，不然可能占用较多带宽。</p>
<img src="assets/image-20200430182045402.png" alt="image-20200430182045402" style="zoom:70%;" />

<p>官方建议集群最大规模不要超过 1000。</p>
<h5 id="2-Pub-Sub广播问题"><a href="#2-Pub-Sub广播问题" class="headerlink" title="2. Pub/Sub广播问题"></a>2. Pub/Sub广播问题</h5><p>Redis 的 Pub/Sub（发布/订阅）功能用于针对频道实现<strong>消息的发布和订阅</strong>。但是集群模式下 publish 命令会向所有的节点进行广播，造成每条 publish 数据都会在集群内所有节点传播一次，加重带宽负担。</p>
<img src="../../JavaNotes/I 缓存/assets/image-20200430182110432.png" alt="image-20200430182110432" style="zoom:67%;" />

<p>在含有<strong>大量</strong>节点集群中应该<strong>避免频繁使用发布订阅功能</strong>，否则会严重消耗集群内网络带宽。</p>
<h5 id="3-集群倾斜问题"><a href="#3-集群倾斜问题" class="headerlink" title="3. 集群倾斜问题"></a>3. 集群倾斜问题</h5><h6 id="1-数据倾斜"><a href="#1-数据倾斜" class="headerlink" title="(1) 数据倾斜"></a>(1) 数据倾斜</h6><p>主要有几种：</p>
<ul>
<li>节点和槽分配严重不均匀。可以使用 <strong>redis-trib.rb 工具的 rebalance</strong> 命令进行平衡。</li>
<li>不同槽对应键数量差异过大。主要是发现键多的槽</li>
<li>集合对象包含大量元素。使用 redis-cli –bigkeys 找出大集合对象，然后可以考虑分解。</li>
<li>内存相关配置不一致。</li>
</ul>
<h6 id="2-请求倾斜"><a href="#2-请求倾斜" class="headerlink" title="(2) 请求倾斜"></a>(2) 请求倾斜</h6><p>对特点的节点请求过多，造成负载不均衡。</p>
<ul>
<li><p>合理设计键，让请求均匀。</p>
</li>
<li><p>对热点的大集合对象进行拆分，避免都请求到一个节点。</p>
</li>
<li><p>对于一致性要求不高的场合可以使用本地缓存减少热键调用。</p>
</li>
</ul>
<h5 id="4-集群读写分离"><a href="#4-集群读写分离" class="headerlink" title="4. 集群读写分离"></a>4. 集群读写分离</h5><p>集群模式下的读写分离成本比较高，可以直接<strong>拓展主节点</strong>的数量来提高集群性能，一般<strong>不建议</strong>集群模式下做读写分离。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《Redis开发与运维》</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/I%20%E7%BC%93%E5%AD%98/G%20Redis%E5%86%85%E5%AD%98%E3%80%81%E9%98%BB%E5%A1%9E%E4%B8%8E%E8%BF%90%E7%BB%B4/" rel="next" title="ShiftJava/I 缓存/G Redis内存、阻塞与运维">
                <i class="fa fa-chevron-left"></i> ShiftJava/I 缓存/G Redis内存、阻塞与运维
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/J%20ORM%E6%A1%86%E6%9E%B6/B%20MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="prev" title="ShiftJava/J ORM框架/B MyBatis面试题">
                ShiftJava/J ORM框架/B MyBatis面试题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-Cluster"><span class="nav-number">1.</span> <span class="nav-text">Redis Cluster</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据分布理论"><span class="nav-number">1.1.</span> <span class="nav-text">数据分布理论</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-哈希数据分区方案"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 哈希数据分区方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-节点取模分区"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">(1) 节点取模分区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-一致性哈希分区"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">(2) 一致性哈希分区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-虚拟槽分区"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">(3) 虚拟槽分区</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Redis数据分区"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. Redis数据分区</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群的作用与功能限制"><span class="nav-number">1.2.</span> <span class="nav-text">集群的作用与功能限制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-集群的作用"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 集群的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-集群的功能限制"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 集群的功能限制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群搭建"><span class="nav-number">1.3.</span> <span class="nav-text">集群搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-节点准备"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 节点准备</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-节点握手"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 节点握手</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-分配数据槽"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 分配数据槽</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-集群搭建完整demo"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 集群搭建完整demo</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-第一步：创建集群节点配置文件"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">(1) 第一步：创建集群节点配置文件</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-第二步：分别启动6个Redis实例"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">(2) 第二步：分别启动6个Redis实例</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-第三步：建立集群"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">(3) 第三步：建立集群</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-第四步：验证集群"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">(4) 第四步：验证集群</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结点通信机制"><span class="nav-number">1.4.</span> <span class="nav-text">结点通信机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-通信流程"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 通信流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Gossip消息"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. Gossip消息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-消息类型"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 消息类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群伸缩"><span class="nav-number">1.5.</span> <span class="nav-text">集群伸缩</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-集群扩容"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. 集群扩容</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-集群收缩"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. 集群收缩</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求路由"><span class="nav-number">1.6.</span> <span class="nav-text">请求路由</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-请求重定向MOVED"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. 请求重定向MOVED</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Smart客户端"><span class="nav-number">1.6.2.</span> <span class="nav-text">2. Smart客户端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-ASK重定向"><span class="nav-number">1.6.3.</span> <span class="nav-text">3. ASK重定向</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#故障转移"><span class="nav-number">1.7.</span> <span class="nav-text">故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-故障发现"><span class="nav-number">1.7.1.</span> <span class="nav-text">1. 故障发现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-主观下线"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">(1) 主观下线</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-客观下线"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">(2) 客观下线</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-故障转移与恢复"><span class="nav-number">1.7.2.</span> <span class="nav-text">2. 故障转移与恢复</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集群运维"><span class="nav-number">1.8.</span> <span class="nav-text">集群运维</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-带宽消耗问题"><span class="nav-number">1.8.1.</span> <span class="nav-text">1. 带宽消耗问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Pub-Sub广播问题"><span class="nav-number">1.8.2.</span> <span class="nav-text">2. Pub/Sub广播问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-集群倾斜问题"><span class="nav-number">1.8.3.</span> <span class="nav-text">3. 集群倾斜问题</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-数据倾斜"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">(1) 数据倾斜</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-请求倾斜"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">(2) 请求倾斜</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-集群读写分离"><span class="nav-number">1.8.4.</span> <span class="nav-text">4. 集群读写分离</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.9.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
