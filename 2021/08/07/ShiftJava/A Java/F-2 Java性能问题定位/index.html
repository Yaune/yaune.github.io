<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] Java性能问题定位分析性能优化一向是后端服务优化的重点，但是线上性能故障问题不是经常出现，或者受限于业务产品，根本就没办法出现性能问题，包括笔者自己遇到的性能问题也不多，所以为了提前储备知识，当出现问题的时候不会手忙脚乱，这里模拟下常见的几个Java性能故障，来学习怎么去分析和定位。 基础工具既然是定位问题肯定是需要借助工具，需要了解一些常用工具。 1. top命令top 命令使最常">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;A Java&#x2F;F-2 Java性能问题定位">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;F-2%20Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] Java性能问题定位分析性能优化一向是后端服务优化的重点，但是线上性能故障问题不是经常出现，或者受限于业务产品，根本就没办法出现性能问题，包括笔者自己遇到的性能问题也不多，所以为了提前储备知识，当出现问题的时候不会手忙脚乱，这里模拟下常见的几个Java性能故障，来学习怎么去分析和定位。 基础工具既然是定位问题肯定是需要借助工具，需要了解一些常用工具。 1. top命令top 命令使最常">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;F-2%20Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D&#x2F;assets&#x2F;java-performance1.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;F-2%20Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D&#x2F;assets&#x2F;java-performance2.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;F-2%20Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D&#x2F;assets&#x2F;java-performance3.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;F-2%20Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D&#x2F;assets&#x2F;java-performance4.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;F-2%20Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D&#x2F;assets&#x2F;java-performance5.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;F-2%20Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D&#x2F;assets&#x2F;java-performance6.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;F-2%20Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D&#x2F;assets&#x2F;java-performance7.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;F-2%20Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D&#x2F;assets&#x2F;java-performance8.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;F-2%20Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D&#x2F;assets&#x2F;java-performance1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/A Java/F-2 Java性能问题定位/"/>





  <title>ShiftJava/A Java/F-2 Java性能问题定位 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/A%20Java/F-2%20Java%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/A Java/F-2 Java性能问题定位</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="Java性能问题定位分析"><a href="#Java性能问题定位分析" class="headerlink" title="Java性能问题定位分析"></a>Java性能问题定位分析</h3><p>性能优化一向是后端服务优化的重点，但是线上性能故障问题不是经常出现，或者受限于业务产品，根本就没办法出现性能问题，包括笔者自己遇到的性能问题也不多，所以为了提前储备知识，当出现问题的时候不会手忙脚乱，这里模拟下常见的几个Java性能故障，来学习怎么去分析和定位。</p>
<h4 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h4><p>既然是<strong>定位问题</strong>肯定是需要借助工具，需要了解一些常用工具。</p>
<h5 id="1-top命令"><a href="#1-top命令" class="headerlink" title="1. top命令"></a>1. <strong>top命令</strong></h5><p><strong>top 命令</strong>使最常用的 Linux 命令之一，它可以实时的显示当前<strong>正在执行的进程的 CPU 使用率</strong>，<strong>内存使用率</strong>等系统信息。<strong>top -Hp pid</strong> 可以查看线程的系统资源使用情况。</p>
<h5 id="2-vmstat命令"><a href="#2-vmstat命令" class="headerlink" title="2. vmstat命令"></a>2. <strong>vmstat命令</strong></h5><p>vmstat 是一个指定周期和采集次数的虚拟内存检测工具，可以统计内存，CPU，swap 的使用情况，它还有一个重要的常用功能，用来观察进程的<strong>上下文切换</strong>。字段说明如下：</p>
<ul>
<li>r: 运行队列中进程数量（当数量大于 CPU 核数表示有阻塞的线程）</li>
<li>b: 等待 IO 的进程数量</li>
<li>swpd: 使用虚拟内存大小</li>
<li>free: 空闲物理内存大小</li>
<li>buff: 用作缓冲的内存大小(内存和硬盘的缓冲区)</li>
<li>cache: 用作缓存的内存大小（CPU 和内存之间的缓冲区）</li>
<li>si: 每秒从交换区写到内存的大小，由磁盘调入内存</li>
<li>so: 每秒写入交换区的内存大小，由内存调入磁盘</li>
<li>bi: 每秒读取的块数</li>
<li>bo: 每秒写入的块数</li>
<li>in: 每秒中断数，包括时钟中断。</li>
<li>cs: 每秒上下文切换数。</li>
<li>us: 用户进程执行时间百分比(user time)</li>
<li>sy: 内核系统进程执行时间百分比(system time)</li>
<li>wa: IO 等待时间百分比</li>
<li>id: 空闲时间百分比</li>
</ul>
<h5 id="3-pidstat命令"><a href="#3-pidstat命令" class="headerlink" title="3. pidstat命令"></a>3. <strong>pidstat命令</strong></h5><p><strong>pidstat</strong> 是 Sysstat 中的一个组件，也是一款功能强大的性能监测工具，<strong>top</strong> 和 <strong>vmstat</strong> 两个命令都是<strong>监测进程的内存</strong>、CPU 以及 I/O 使用情况，而 <strong>pidstat 命令可以检测到线程级别</strong>的。pidstat 命令线程切换字段说明如下：</p>
<ul>
<li>UID：被监控任务的真实用户ID。</li>
<li>TGID：线程组ID。</li>
<li>TID：线程ID。</li>
<li>cswch/s：主动切换上下文次数，这里是因为资源阻塞而切换线程，比如锁等待等情况。</li>
<li>nvcswch/s：被动切换上下文次数，这里指CPU调度切换了线程。</li>
</ul>
<h5 id="4-jstack命令"><a href="#4-jstack命令" class="headerlink" title="4. jstack命令"></a>4. <strong>jstack命令</strong></h5><p><strong>jstack</strong> 是 JDK 工具命令，它是一种<strong>线程堆栈分析</strong>工具，最常用的功能就是使用 jstack pid 命令查看线程的堆栈信息，也经常用来<strong>排除死锁</strong>情况。</p>
<h5 id="5-jstat命令"><a href="#5-jstat命令" class="headerlink" title="5. jstat命令"></a>5. <strong>jstat命令</strong></h5><p>它可以检测 Java 程序运行的<strong>实时情况</strong>，包括<strong>堆内存信息和垃圾回收信息</strong>，我们常常用来查看程序垃圾回收情况。常用的命令是<code>jstat -gc pid</code>。信息字段说明如下：</p>
<ul>
<li>S0C：年轻代中 To Survivor 的容量（单位 KB）；</li>
<li>S1C：年轻代中 From Survivor 的容量（单位 KB）；</li>
<li>S0U：年轻代中 To Survivor 目前已使用空间（单位 KB）；</li>
<li>S1U：年轻代中 From Survivor 目前已使用空间（单位 KB）；</li>
<li>EC：年轻代中 Eden 的容量（单位 KB）；</li>
<li>EU：年轻代中 Eden 目前已使用空间（单位 KB）；</li>
<li>OC：老年代的容量（单位 KB）；</li>
<li>OU：老年代目前已使用空间（单位 KB）；</li>
<li>MC：元空间的容量（单位 KB）；</li>
<li>MU：元空间目前已使用空间（单位 KB）；</li>
<li>YGC：从应用程序启动到采样时年轻代中 gc 次数；</li>
<li>YGCT：从应用程序启动到采样时年轻代中 gc 所用时间 (s)；</li>
<li>FGC：从应用程序启动到采样时 老年代（Full Gc）gc 次数；</li>
<li>FGCT：从应用程序启动到采样时 老年代代（Full Gc）gc 所用时间 (s)；</li>
<li>GCT：从应用程序启动到采样时 gc 用的总时间 (s)。</li>
</ul>
<h5 id="6-jmap命令"><a href="#6-jmap命令" class="headerlink" title="6. jmap命令"></a>6. <strong>jmap命令</strong></h5><p>jmap 也是 JDK 工具命令，可以查看<strong>堆内存</strong>的初始化信息以及堆内存的使用情况，还可以生成 <strong>dump 文件</strong>来进行详细分析。查看堆内存情况命令 <strong>jmap -heap pid</strong>。堆转储。</p>
<h5 id="7-mat内存工具"><a href="#7-mat内存工具" class="headerlink" title="7. mat内存工具"></a>7. <strong>mat内存工具</strong></h5><p><strong>MAT</strong>(Memory Analyzer Tool) 工具是 eclipse 的一个插件(MAT 也可以单独使用)，它<strong>分析大内存的 dump 文件</strong>时，可以非常直观的看到各个对象在堆空间中所占用的内存大小、类实例数量、对象引用关系、利用 OQL 对象查询，以及可以很方便的找出对象 GC Roots 的相关信息。</p>
<p><strong>idea 中也有这么一个插件，就是 JProfiler</strong>。</p>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>基础环境 Jdk1.8，采用 SpringBoot 框架来写<strong>几个接口来触发模拟场景</strong>，首先是模拟 CPU 占满情况。</p>
<h4 id="常见问题分析及定位"><a href="#常见问题分析及定位" class="headerlink" title="常见问题分析及定位"></a>常见问题分析及定位</h4><h5 id="1-CPU占满"><a href="#1-CPU占满" class="headerlink" title="1. CPU占满"></a>1. CPU占满</h5><p>写一个死循环模拟 CPU 占满即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/cpu/loop"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCPULoop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"请求cpu死循环"</span>);</span><br><span class="line">    Thread.currentThread().setName(<span class="string">"loop-thread-cpu"</span>);</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (num == Integer.MAX_VALUE) &#123;</span><br><span class="line">            System.out.println(<span class="string">"reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求接口地址测试 curl localhost:8080/cpu/loop，发现 CPU 立马飙升到 100%。</p>
<p><img src="assets/java-performance1.png" alt=""></p>
<p>通过执行 <strong>top -Hp 32805</strong> 查看 Java 线程情况。</p>
<p><img src="assets/java-performance2.png" alt=""></p>
<p>执行 printf ‘%x’ 32826 获取 16 进制的线程 <strong>id</strong>，用于 <strong>dump 信息查询</strong>，结果为 803a。最后执行 jstack 32805 |grep -A 20 803a 来查看下详细的 dump 信息。</p>
<p><img src="assets/java-performance3.png" alt=""></p>
<p>这里 dump 信息直接定位出了问题方法以及代码行，这就定位出了 <strong>CPU 占满</strong>的问题。</p>
<h5 id="2-内存泄露"><a href="#2-内存泄露" class="headerlink" title="2. 内存泄露"></a>2. 内存泄露</h5><p>模拟内存泄漏借助了 <strong>ThreadLocal</strong> 对象来完成，ThreadLocal 是一个线程私有变量，可以<strong>绑定到线程</strong>上，在整个线程的生命周期都会存在，但是由于 ThreadLocal 的特殊性，ThreadLocal 是基于 ThreadLocalMap 实现的，ThreadLocalMap 的 Entry 继承 WeakReference，而 Entry 的 Key 是 WeakReference 的封装，换句话说 <strong>Key 就是弱引用</strong>，弱引用在下次 GC 之后就会被回收，如果 <strong>ThreadLocal 在 set 之后不进行后续的操作</strong>，因为 <strong>GC 会把 Key 清除掉，但是 Value 由于线程还在存活，所以 Value 一直不会被回收，最后就会发生内存泄漏</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟内存泄漏</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/memory/leak"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">leak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"模拟内存泄漏"</span>);</span><br><span class="line">    ThreadLocal&lt;Byte[]&gt; localVariable = <span class="keyword">new</span> ThreadLocal&lt;Byte[]&gt;();</span><br><span class="line">    localVariable.set(<span class="keyword">new</span> Byte[<span class="number">4096</span> * <span class="number">1024</span>]); <span class="comment">// 为线程添加变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给启动加上<strong>堆内存大小限制</strong>，同时设置内存溢出的时候输出<strong>堆栈快照</strong>并输出日志。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar -Xms500m -Xmx500m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof -XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/tmp/heaplog.log analysis-demo-<span class="number">0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>启动成功后循环执行 100 次。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..500&#125;; <span class="keyword">do</span> curl localhost:8080/memory/leak;<span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>还没执行完毕，系统已经返回 500 错误了。查看系统日志出现了如下异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>

<p>用 jstat -gc pid 命令来看看程序的 GC 情况。</p>
<p><img src="assets/java-performance4.png" alt=""></p>
<p>很明显内存溢出了，堆内存经过 45 次 Full Gc 之后都没释放出可用内存，这说明当前堆内存中的对象都是<strong>存活</strong>的，有 GC Roots 引用，无法回收。那是什么原因导致内存溢出呢？是不是只要加大内存就行了呢？如果是普通的内存溢出也许扩大内存就行了，但是如果是内存泄漏的话，扩大的内存不一会就会被占满，所以还需要确定<strong>是不是内存泄漏</strong>。之前保存了堆 Dump 文件，这个时候借助 MAT 工具来分析下。导入工具选择 Leak Suspects Report，工具直接就会列出问题报告。</p>
<img src="assets/java-performance5.png" style="zoom:22%;" />

<p>这里已经列出了可疑的 4 个内存泄漏问题，点击其中一个查看详情。</p>
<img src="assets/java-performance6.png" style="zoom:45%;" />

<p>这里已经指出了内存被线程占用了接近 50M 的内存，占用的对象就是 ThreadLocal。如果想详细的通过手动去分析的话，可以点击 Histogram，查看最大的对象占用是谁，然后再分析它的引用关系，即可确定是谁导致的内存溢出。</p>
<p><img src="assets/java-performance7.png" alt=""></p>
<p>上图发现占用内存最大的对象是一个 <strong>Byte 数组</strong>，看看它到底被哪个 GC Root <strong>引用</strong>导致没有被回收。按照上图红框操作指引，结果如下图：</p>
<p><img src="assets/java-performance8.png" alt=""></p>
<p>Byte 数组是被<strong>线程对象引用的</strong>，图中也标明，Byte 数组对像的 GC Root 是线程，所以它是<strong>不会被回收</strong>的，展开详细信息查看，发现最终的内存占用对象是被 ThreadLocal 对象占据了。这也和 <strong>MAT 工具</strong>自动分析的结果一致。</p>
<h5 id="3-死锁"><a href="#3-死锁" class="headerlink" title="3. 死锁"></a>3. 死锁</h5><p>死锁会导致耗尽线程资源，占用内存，表现就是<strong>内存占用升高</strong>，CPU 不一定会飙升(看场景决定)，如果是直接 new 线程，会导致 JVM 内存被耗尽，报无法创建线程的错误，这也是体现了使用线程池的好处。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池</span></span><br><span class="line">ExecutorService service </span><br><span class="line">    = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">4</span>, <span class="number">10</span>, <span class="number">0</span>, TimeUnit.SECONDS, </span><br><span class="line">                             <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>),</span><br><span class="line">                             Executors.defaultThreadFactory(),</span><br><span class="line">                             <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/cpu/test"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testCPU</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"请求cpu"</span>);</span><br><span class="line">    Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line">    service.submit(<span class="keyword">new</span> DeadLockThread(lock1, lock2), <span class="string">"deadLookThread-"</span> + <span class="keyword">new</span> Random().nextInt());</span><br><span class="line">    service.submit(<span class="keyword">new</span> DeadLockThread(lock2, lock1), <span class="string">"deadLookThread-"</span> + <span class="keyword">new</span> Random().nextInt());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object lock1;</span><br><span class="line">    <span class="keyword">private</span> Object lock2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DeadLockThread1</span><span class="params">(Object lock1, Object lock2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock1 = lock1;</span><br><span class="line">        <span class="keyword">this</span>.lock2 = lock2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"get lock2 and wait lock1"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"get lock1 and lock2 "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环请求接口 2000 次，发现不一会系统就出现了日志错误，线程池和队列都满了，由于选择的当队列满了就拒绝的策略，所以系统直接抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@<span class="number">2760298</span> rejected from java.util.concurrent.ThreadPoolExecutor@<span class="number">7</span>ea7cd51[Running, pool size = <span class="number">10</span>, active threads = <span class="number">10</span>, queued tasks = <span class="number">1024</span>, completed tasks = <span class="number">846</span>]</span><br></pre></td></tr></table></figure>

<p>通过 <strong>ps -ef|grep java</strong> 命令找出 Java 进程 pid，执行 jstack pid 即可出现 Java 线程堆栈信息，这里发现了 5 个死锁，只列出其中一个，很明显线程 <strong>pool-1-thread-2</strong> 锁住了 0x00000000f8387d88 等待 0x00000000f8387d98 锁，线程 pool-1-thread-1 锁住了 0x00000000f8387d98 等待锁 0x00000000f8387d88，这就产生了死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Java stack information <span class="keyword">for</span> the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line"><span class="string">"pool-1-thread-2"</span>:</span><br><span class="line">        at top.luozhou.analysisdemo.controller.DeadLockThread2.run(DeadLockThread.java:<span class="number">30</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000000f8387d98</span>&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000f8387d88</span>&gt; (a java.lang.Object)</span><br><span class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"><span class="string">"pool-1-thread-1"</span>:</span><br><span class="line">        at top.luozhou.analysisdemo.controller.DeadLockThread1.run(DeadLockThread.java:<span class="number">30</span>)</span><br><span class="line">        - waiting to lock &lt;<span class="number">0x00000000f8387d88</span>&gt; (a java.lang.Object)</span><br><span class="line">        - locked &lt;<span class="number">0x00000000f8387d98</span>&gt; (a java.lang.Object)</span><br><span class="line">        at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:<span class="number">511</span>)</span><br><span class="line">        at java.util.concurrent.FutureTask.run(FutureTask.java:<span class="number">266</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line">          </span><br><span class="line"> Found <span class="number">5</span> deadlocks.</span><br></pre></td></tr></table></figure>

<h5 id="4-线程频繁切换"><a href="#4-线程频繁切换" class="headerlink" title="4. 线程频繁切换"></a>4. 线程频繁切换</h5><p>上下文切换会导致将大量 CPU 时间浪费在<strong>寄存器、内核栈以及虚拟内存的保存和恢复</strong>上，导致系统整体性能下降。当发现系统的性能出现明显的下降时候，需要考虑是否发生了大量的线程上下文切换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/thread/swap"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">theadSwap</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"模拟线程切换"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadSwap1(<span class="keyword">new</span> AtomicInteger(<span class="number">0</span>)),<span class="string">"thread-swap"</span>+i).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSwap1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger integer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadSwap1</span><span class="params">(AtomicInteger integer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.integer = integer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            integer.addAndGet(<span class="number">1</span>);</span><br><span class="line">            Thread.yield(); <span class="comment">// 让出CPU资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里创建多个线程去执行基础的<strong>原子+1</strong>操作，然后让出 CPU 资源，理论上 CPU 就会去调度别的线程，我们请求接口创建 100 个线程看看效果如何，curl localhost:8080/thread/swap?num=100。接口请求成功后，执行 <strong>vmstat 1 10</strong>，表示每 1 秒打印一次，打印 10 次，线程切换采集结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line">r  b   swpd   free   buff  cache   si   so    bi    bo   <span class="keyword">in</span>   cs us sy id wa st</span><br><span class="line">101  0 128000 878384    908 468684    0    0     0     0 4071 8110498 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4065 8312463 15 85  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4107 8207718 14 87  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4083 8410174 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468684    0    0     0     0 4083 8264377 14 86  0  0  0</span><br><span class="line">100  0 128000 878384    908 468688    0    0     0   108 4182 8346826 14 86  0  0  0</span><br></pre></td></tr></table></figure>

<p>这里关注 4 个指标，<strong>r, cs, us, sy。</strong></p>
<p><strong>r=100</strong>, 说明等待的进程数量是 100，线程有阻塞。</p>
<p><strong>cs=800多万</strong>，说明<strong>每秒上下文切换了 800</strong> 多万次，这个数字相当大了。</p>
<p><strong>us=14</strong>，说明用户态占用了 14% 的 CPU 时间片去处理逻辑。</p>
<p><strong>sy=86</strong>，说明内核态占用了 86% 的 CPU，这里明显就是做上下文切换工作了。</p>
<p>通过 <strong>top 命令</strong>以及 top -Hp pid 查看进程和线程 CPU 情况，发现 Java <strong>线程 CPU 占满</strong>了，但是线程 CPU 使用情况很平均，没有某一个线程把 CPU 吃满的情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                            </span><br><span class="line"> 87093 root      20   0 4194788 299056  13252 S 399.7 16.1  65:34.67 java </span><br><span class="line"> PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                             </span><br><span class="line"> 87189 root      20   0 4194788 299056  13252 R  4.7 16.1   0:41.11 java                                    </span><br><span class="line"> 87129 root      20   0 4194788 299056  13252 R  4.3 16.1   0:41.14 java                                                                                </span><br><span class="line"> 87130 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.51 java                                                                                </span><br><span class="line"> 87133 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.59 java                                                                                </span><br><span class="line"> 87134 root      20   0 4194788 299056  13252 R  4.3 16.1   0:40.95 java</span><br></pre></td></tr></table></figure>

<p>结合上面用户态 CPU 只使用了 14%，内核态 CPU 占用了 86%，可以基本判断是 Java 程序线程<strong>上下文切换</strong>导致性能问题。</p>
<p>使用 <strong>pidstat</strong> 命令来看看 Java 进程内部的线程切换数据，执行 <strong>pidstat -p 87093 -w 1 10</strong>，采集数据如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">11:04:30 PM   UID       TGID       TID   cswch/s nvcswch/s  Command</span><br><span class="line">11:04:30 PM     0         -     87128      0.00     16.07  |__java</span><br><span class="line">11:04:30 PM     0         -     87129      0.00     15.60  |__java</span><br><span class="line">11:04:30 PM     0         -     87130      0.00     15.54  |__java</span><br><span class="line">11:04:30 PM     0         -     87131      0.00     15.60  |__java</span><br><span class="line">11:04:30 PM     0         -     87132      0.00     15.43  |__java</span><br><span class="line">11:04:30 PM     0         -     87133      0.00     16.02  |__java</span><br><span class="line">11:04:30 PM     0         -     87134      0.00     15.66  |__java</span><br><span class="line">11:04:30 PM     0         -     87135      0.00     15.23  |__java</span><br><span class="line">11:04:30 PM     0         -     87136      0.00     15.33  |__java</span><br><span class="line">11:04:30 PM     0         -     87137      0.00     16.04  |__java</span><br></pre></td></tr></table></figure>

<p>根据上面采集的信息可以知道 Java 的线程每秒切换 15 次左右，<strong>正常情况下，应该是个位数或者小数</strong>。结合这些信息可以断定 Java 线程开启过多，导致频繁上下文切换，从而影响了整体性能。</p>
<p><strong>为什么系统的上下文切换是每秒 800 多万，而 Java 进程中的某一个线程切换才 15 次左右？</strong></p>
<p>系统上下文切换分为三种情况： </p>
<p>1、多任务：在多任务环境中，一个进程被切换出 CPU，运行另外一个进程，这里会发生上下文切换。</p>
<p>2、中断处理：发生中断时，硬件会切换上下文。在 vmstat 命令中是 in。</p>
<p>3、用户和内核模式切换：当操作系统中需要在用户模式和内核模式之间进行转换时，需要进行上下文切换，比如进行系统函数调用。</p>
<p>Linux 为每个 CPU 维护了一个<strong>就绪队列</strong>，将活跃进程按照优先级和等待 CPU 的时间排序，然后选择最需要 CPU 的进程，也就是优先级最高和等待 CPU 时间最长的进程来运行。也就是 vmstat 命令中的 <strong>r</strong>。</p>
<p>那么，进程在什么时候才会被<strong>调度到 CPU 上运行</strong>？</p>
<ul>
<li>进程执行完终止了，它之前使用的 CPU 会释放出来，这时再从就绪队列中拿一个新的进程来运行。</li>
<li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片被轮流分配给各个进程。当某个进程时间片耗尽了就会被系统挂起，切换到其它等待 CPU 的进程运行。</li>
<li>进程在系统资源不足时，要等待资源满足后才可以运行，这时进程也会被挂起，并由系统调度其它进程运行。</li>
<li>当进程通过睡眠函数 sleep 主动挂起时，也会重新调度。</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</li>
<li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</li>
</ul>
<p>结合之前的内容分析，阻塞的就绪队列是 100 左右，而 CPU 只有 4 核，这部分原因造成的上下文切换就可能会相当高，再加上中断次数是 4000 左右和系统的函数调用等，整个系统的上下文切换到 800 万也不足为奇了。Java 内部的线程切换才 15 次，是因为线程使用 <strong>Thread.yield()</strong> 来让出 CPU 资源，但是 CPU 有可能继续调度该线程，这个时候<strong>线程之间并没有切换</strong>，这也是为什么内部的某个线程切换次数并不是非常大的原因。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p>1、<a href="https://linux.die.net/man/1/pidstat" target="_blank" rel="noopener">https://linux.die.net/man/1/pidstat</a></p>
<p>2、<a href="https://linux.die.net/man/8/vmstat" target="_blank" rel="noopener">https://linux.die.net/man/8/vmstat</a></p>
<p>3、<a href="https://help.eclipse.org/2020-03/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html" target="_blank" rel="noopener">https://help.eclipse.org/2020-03/index.jsp?topic=/org.eclipse.mat.ui.help/welcome.html</a></p>
<p>4、<a href="https://www.linuxblogs.cn/articles/18120200.html" target="_blank" rel="noopener">https://www.linuxblogs.cn/articles/18120200.html</a></p>
<p>5、<a href="https://www.tutorialspoint.com/what-is-context-switching-in-operating-system" target="_blank" rel="noopener">https://www.tutorialspoint.com/what-is-context-switching-in-operating-system</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/F-3%20%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" rel="next" title="ShiftJava/A Java/F-3 面试题总结">
                <i class="fa fa-chevron-left"></i> ShiftJava/A Java/F-3 面试题总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/E-5%20%E4%BB%A3%E7%90%86/" rel="prev" title="ShiftJava/A Java/E-5 代理">
                ShiftJava/A Java/E-5 代理 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java性能问题定位分析"><span class="nav-number">1.</span> <span class="nav-text">Java性能问题定位分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础工具"><span class="nav-number">1.1.</span> <span class="nav-text">基础工具</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-top命令"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. top命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-vmstat命令"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. vmstat命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-pidstat命令"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. pidstat命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-jstack命令"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. jstack命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-jstat命令"><span class="nav-number">1.1.5.</span> <span class="nav-text">5. jstat命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-jmap命令"><span class="nav-number">1.1.6.</span> <span class="nav-text">6. jmap命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-mat内存工具"><span class="nav-number">1.1.7.</span> <span class="nav-text">7. mat内存工具</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#环境准备"><span class="nav-number">1.2.</span> <span class="nav-text">环境准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见问题分析及定位"><span class="nav-number">1.3.</span> <span class="nav-text">常见问题分析及定位</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-CPU占满"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. CPU占满</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-内存泄露"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 内存泄露</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-死锁"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-线程频繁切换"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 线程频繁切换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.4.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
