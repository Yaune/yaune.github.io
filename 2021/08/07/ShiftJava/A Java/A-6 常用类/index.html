<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] 常用类Object类重点啊！经常问这个问题。Object 类是所有类的父类。数组也继承了 Object 类。然而，接口是不继承 Object 类的。 1. Object类APIObject 类的 API（面试题：问有哪些方法？） 12345678910111213141516171819202122&#x2F;&#x2F; 返回当前运行时对象的Class对象public final native Clas">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;A Java&#x2F;A-6 常用类">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;A-6%20%E5%B8%B8%E7%94%A8%E7%B1%BB&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] 常用类Object类重点啊！经常问这个问题。Object 类是所有类的父类。数组也继承了 Object 类。然而，接口是不继承 Object 类的。 1. Object类APIObject 类的 API（面试题：问有哪些方法？） 12345678910111213141516171819202122&#x2F;&#x2F; 返回当前运行时对象的Class对象public final native Clas">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;A-6%20%E5%B8%B8%E7%94%A8%E7%B1%BB&#x2F;assets&#x2F;image-20200626140641201.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;A-6%20%E5%B8%B8%E7%94%A8%E7%B1%BB&#x2F;assets&#x2F;image-20200504165902815.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;A-6%20%E5%B8%B8%E7%94%A8%E7%B1%BB&#x2F;assets&#x2F;1582383197264.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;A-6%20%E5%B8%B8%E7%94%A8%E7%B1%BB&#x2F;assets&#x2F;image-20200626140641201.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/A Java/A-6 常用类/"/>





  <title>ShiftJava/A Java/A-6 常用类 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/A%20Java/A-6%20%E5%B8%B8%E7%94%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/A Java/A-6 常用类</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><p>重点啊！经常问这个问题。Object 类是<strong>所有类的父类</strong>。<strong>数组</strong>也继承了 Object 类。然而，<strong>接口</strong>是不继承 Object 类的。</p>
<h5 id="1-Object类API"><a href="#1-Object类API" class="headerlink" title="1. Object类API"></a>1. Object类API</h5><p>Object 类的 API（面试题：问<strong>有哪些方法</strong>？）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回当前运行时对象的Class对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"><span class="comment">// 返回对象的哈希码，主要使用在哈希表中，如HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 比较2个对象的内存地址是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"><span class="comment">// 创建并返回当前对象的一份拷贝。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function"><span class="comment">// 返回类的名字@实例的哈希码的16进制的字符串，建议Object所有的子类都重写这个方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁。timeout是等待时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">// 多了nanos参数，这个参数表示额外时间，指超时的时间还需要加上nanos毫秒</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">// 实例被垃圾回收器回收的时候触发的操作</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br></pre></td></tr></table></figure>

<p><strong>native</strong>: Java 关键字，Native Method 用以修饰<strong>非 Java 代码实现</strong>的方法(C || C++)。被 <strong>final 修饰的方法也不能被覆写</strong>的。被 native 修饰的方式一些是可以覆写的（clone、finalize），一些不能覆写（notify、notifyAll、wait 方法）。由于 Object 是所有类的父类，所以任何类都可以直接覆写上面<strong>允许</strong>覆写的方法进行拓展。</p>
<h5 id="2-equals"><a href="#2-equals" class="headerlink" title="2. equals()"></a>2. equals()</h5><p>equals() 函数可以用来检查一个对象与调用这个 equals() 的这个对象<strong>是否相等</strong>。</p>
<p>Object 类<strong>默认</strong>的 eqauls() 函数进行比较的依据是：调用它的对象和传入的对象的<strong>引用</strong>是否相等，默认进行的是<strong>引用比较</strong>。如果两个<strong>引用是相同</strong>的则返回 true；否则返回 false。</p>
<ul>
<li>对于<strong>基本类型</strong>，== 判断两个值是否<strong>相等</strong>，基本类型没有 equals() 方法。</li>
<li><strong>对于引用类型，== 判断两个变量是否引用==同一个==对象，而 equals() 判断两个对象内容是否==等价==。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(x.equals(y));  <span class="comment">// true 等价</span></span><br><span class="line">System.out.println(x == y);       <span class="comment">// false 对象相等</span></span><br><span class="line">Integer m = <span class="number">1</span>;</span><br><span class="line">Integer n = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 此处m n的值均从Integer的缓存池中获取，所以引用相同</span></span><br><span class="line">System.out.println(m == n);</span><br></pre></td></tr></table></figure>

<h6 id="1-等价的特性"><a href="#1-等价的特性" class="headerlink" title="(1) 等价的特性"></a>(1) 等价的特性</h6><p>覆写 equals() 函数的时候要遵守一些<strong>规则</strong>。</p>
<p><strong>I 自反性</strong>：对于任意非空的引用值 x，x.equals(x) 返回值为真。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(x); 	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>II 对称性</strong>：对于任意非空的引用值 x 和 y，x.equals(y) 必须和 y.equals(x) 返回<strong>相同</strong>的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == y.equals(x); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>III 传递性</strong>：对于任意的非空引用值 x, y 和 z, 如果 x.equals(y) 返回真，y.equals(z) 返回真，那么 x.equals(z) 也必须返回真。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.equals(y) &amp;&amp; y.equals(z))</span><br><span class="line">    x.equals(z);  <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

<p><strong>IV 一致性</strong>：对于任意非空的引用值 x 和 y，无论调用 x.equals(y) 多少次，都要返回<strong>相同</strong>的结果。在比较的过程中，对象中的数据不能被修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(y) == x.equals(y); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>V 与null比较</strong></p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.equals(<span class="keyword">null</span>); <span class="comment">// false;</span></span><br></pre></td></tr></table></figure>

<h6 id="2-覆写equals方法"><a href="#2-覆写equals方法" class="headerlink" title="(2) 覆写equals方法"></a>(2) 覆写equals方法</h6><p>写出<strong>完美equals方法</strong>的建议（源自 JavaCore）：</p>
<ul>
<li>检测 this 与 otherObject 是否<strong>引用同一对象</strong>（地址相同）。</li>
<li>检测 otherObject <strong>是否为 null</strong>（null 就肯定不是了）。</li>
<li>比较 this 与 otherObject 是否属于<strong>同一个类</strong>（类型不同也不是）。</li>
<li>将 otherObject <strong>类型转换</strong>为相应的类类型变量。</li>
<li>现在开始对<strong>所有需要比较的域依次进行比较</strong>。使用 <strong>==</strong> 比较<strong>基本类型域</strong>，使用 <strong>equals 比较对象域</strong>。这里就需要看对不同类自己的情况写。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是Employee类的equals方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span></span>&#123;</span><br><span class="line">     <span class="comment">// 检测this与otherObject是否引用同一对象</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == otherObject) <span class="keyword">return</span> <span class="keyword">true</span>;   </span><br><span class="line">    <span class="comment">// 检测otherObject是否为null</span></span><br><span class="line">    <span class="keyword">if</span>(otherObject == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;   </span><br><span class="line">    <span class="comment">// 比较this与otherObject是否属于同一种类型</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != otherObject.geClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将otherObject转换为相应的类类型变量：类型转换</span></span><br><span class="line">    Employee other = (Employee) otherObject;    </span><br><span class="line">    <span class="comment">// 现在开始对所有需要比较的域进行比较。使用 == 比较基本类型域，使用equals比较对象域。</span></span><br><span class="line">    <span class="keyword">return</span> Object.equals(name, other.name) &amp;&amp; salary == other.salary &amp;&amp; Objects.equals(hireDay, other.hireDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="assets/image-20200626140641201.png" alt="image-20200626140641201" style="zoom:62%;" />

<p>再看看 <strong>String</strong> 类的 equals 方法，简直就是套路，果然牛皮。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果地址相同直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首先判断是否是String的类型（也就是判断class类型）</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">// 强制类型转换获取这个对象的String</span></span><br><span class="line">        String aString = (String)anObject;</span><br><span class="line">        <span class="keyword">if</span> (coder() == aString.coder()) &#123;</span><br><span class="line">            <span class="comment">// 下面就是对两个字符串的每一个字符进行对比（就是上述第四条）</span></span><br><span class="line">            <span class="keyword">return</span> isLatin1() ? StringLatin1.equals(value, aString.value)</span><br><span class="line">                : StringUTF16.equals(value, aString.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-合理使用equals方法"><a href="#3-合理使用equals方法" class="headerlink" title="(3) 合理使用equals方法"></a>(3) 合理使用equals方法</h6><p>Object 的 equals 方法容易<strong>抛空指针异常</strong>，应使用<strong>常量或确定有值的对象</strong>来调用 equals（阿里规范）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能使用一个值为null的引用类型变量来调用非静态方法，否则会抛出异常</span></span><br><span class="line">String str = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">"12345"</span>)) &#123;<span class="comment">//...&#125;</span></span><br></pre></td></tr></table></figure>

<p>改成下面就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"12345"</span>.equals(str);    <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>不过更推荐使用 <strong>java.util.Objects#equals</strong> (JDK7 引入的工具类)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Objects.equals(<span class="keyword">null</span>, <span class="string">"123"</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>我们看一下 <strong>java.util.Objects#equals</strong> 的源码就知道原因了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span></span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3. hashCode()"></a>3. hashCode()</h5><h6 id="1-概述"><a href="#1-概述" class="headerlink" title="(1) 概述"></a>(1) 概述</h6><p>hashCode() 返回<strong>散列值</strong>，散列值是由对象导出的一个<strong>整形值</strong>。每个对象都有一个<strong>默认的散列值</strong>，不覆写这个方法就返回对象的<strong>存储地址</strong>。</p>
<p>equals() 方法用来判断两个对象是否<strong>等价</strong>。<strong>等价的两个对象散列值一定相同</strong>，但是<strong>散列值相同的两个对象不一定等价</strong>。如果两个对象的 <strong>equals 返回 true</strong>，那么他们的 hashcode 值<strong>可能相等</strong>，也可能不相等。</p>
<blockquote>
<p>为什么需要同时覆写 equals 方法和 hashCode 方法？</p>
</blockquote>
<p>因为两种定义必须一致：如果 x.equals(y) 返回 <strong>true</strong>，那么 x.hashCode() 与 y.hashCode() 就必须<strong>相同</strong>。</p>
<p>在覆写 <strong>equals</strong>() 方法时应当<strong>总是同时覆写</strong> hashCode() 方法，保证<strong>等价的两个对象散列值</strong>也<strong>相等</strong>。</p>
<p><strong>因为 HashMap 或 HashSet 就是同时通过这个两个方法来判断对象是否存在的，当键发生哈希冲突时，仅一个方法是不能有效的组织与检索的。</strong></p>
<p>一个反例：下面的 EqualExample 仅覆写了 equals 方法而 <strong>没有覆写</strong> hasCode() 方法，所以两个对象的散列值是<strong>不同</strong>的，最终导致 HashSet 中添加了两个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EqualExample e1 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);	<span class="comment">// 因为上述的只是覆写了equals()</span></span><br><span class="line">EqualExample e2 = <span class="keyword">new</span> EqualExample(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);    <span class="comment">// 没有覆写 hashCode()</span></span><br><span class="line">System.out.println(e1.equals(e2));   		    <span class="comment">// true</span></span><br><span class="line">HashSet&lt;EqualExample&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">set.add(e1);</span><br><span class="line">set.add(e2);</span><br><span class="line">System.out.println(set.size());   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>所以啊，==<strong>必须同时覆写 equals() 和 hashCode() 方法！</strong>==如果重新定义类中的 equals 方法，就必须<strong>重新</strong>定义 hashCode 方法。</p>
<h6 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="(2) 散列函数"></a>(2) 散列函数</h6><p>理想的散列函数应当具有<strong>均匀性</strong>，即不相等的对象应当<strong>均匀分布</strong>到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。<strong>R 一般取 31</strong>，因为它是一个<strong>奇素数</strong>，如果是<strong>偶数</strong>的话，当出现<strong>乘法溢出，信息就会丢失</strong>，因为与 2 相乘相当于向左移一位。</p>
<p>散列函数详细参考数据结构与算法部分。</p>
<p>一个数与 31 相乘可以转换成移位和减法：<strong>31*x == (x&lt;&lt;5)-x</strong>，编译器会自动进行这个优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 覆写 hashCode() 方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">17</span>;</span><br><span class="line">    <span class="comment">// xyz为类的实例变量</span></span><br><span class="line">    result = <span class="number">31</span> * result + x;</span><br><span class="line">    result = <span class="number">31</span> * result + y;</span><br><span class="line">    result = <span class="number">31</span> * result + z;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最方便的就是利用 <strong>Objects 工具类覆写 hashCode</strong> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个简单的覆写hashCode方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入多个对象到hash()返回hashCode</span></span><br><span class="line">	<span class="keyword">return</span> Objects.hash(firstName, lastName);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-toString"><a href="#4-toString" class="headerlink" title="4. toString()"></a>4. toString()</h5><p><strong>建议</strong>每个类都覆写 toString() 方法，方便调试（阿里规范）。</p>
<p>不覆写就默认返回 <strong>类名@hashCode(地址值)</strong> 的形式，比如 <strong>ToStringExample@4557817c</strong>，@ 后面的数值为 <strong>hashCode 散列码</strong>的无符号十六进制表示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ToStringTest test = <span class="keyword">new</span> ToStringTest(<span class="number">123</span>);</span><br><span class="line">System.out.println(test.toString());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ToStringExample@<span class="number">4554617</span>c    <span class="comment">// 类名@地址值(默认的hashCode)</span></span><br></pre></td></tr></table></figure>

<p>静态的 Arrays.toString() 方法可以直接<strong>打印数组</strong>（内部已经<strong>覆写</strong>了该方法）。打印多维数组使用 Arrays.deepToString() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">Arrays.toString(a);             <span class="comment">// [1, 2, 3]    Arrays类已经覆写了toString()</span></span><br></pre></td></tr></table></figure>

<h5 id="5-clone"><a href="#5-clone" class="headerlink" title="5. clone()"></a>5. clone()</h5><p>clone 方法是创建并返回一个对象<strong>复制后</strong>的结果。如果一个类<strong>没有实现 Cloneable 接口</strong>（只是一个标记接口），那么对此类对象进行复制时，会出现 CloneNotSupportedException 异常。默认是进行<strong>浅拷贝</strong>的，深拷贝需要自己实现（详见常用接口部分）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建并返回此对象的一个副本</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure>

<p>clone 是 <strong>protected</strong> 的方法，各个类可以直接覆写。</p>
<h5 id="6-getClass"><a href="#6-getClass" class="headerlink" title="6. getClass()"></a>6. getClass()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();  <span class="comment">// 返回此Object的运行类</span></span><br></pre></td></tr></table></figure>

<p>该方法由 final 声明本地方法，<strong>不能被覆写</strong>，作用是返回<strong>运行时类对象（Class 对象）</strong>，通过这个类对象可以获取该运行时类的相关属性和方法。每个类都有，可以直接用。</p>
<h5 id="7-wait"><a href="#7-wait" class="headerlink" title="7. wait()"></a>7. wait()</h5><p>wait 方法会引起<strong>当前线程阻塞</strong>，直到另外一个线程在<strong>对应的锁对象</strong>上调用 notify 或 notifyAll 方法，或达到了方法参数中<strong>指定的时间</strong>，当前线程才会被唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在其他线程调用此对象的notify()方法或notifyAll()方法，或者超过指定的时间量前，导致当前线程等待</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="comment">// 用于让当前线程失去操作权限，当前线程进入等待序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>wait 方法会把<strong>当前线程</strong>放在锁对象的<strong>等待队列</strong>中，线程一直处于<strong>休眠</strong>状态，在这个对象上的所有同步请求都<strong>不会</strong>得到响应。要注意的是，wait 方法把当前线程放置到<strong>这个锁对象</strong>的等待队列中，解锁也仅仅是在这个锁对象上；当前线程在等待过程中仍然持有其他对象的锁。</p>
<p>如果当前线程被其他线程在当前线程等待之前或正在等待时调用了 <strong>interrupt</strong>() 中断了，那么就会抛出 InterruptException 异常。</p>
<p>详细内容参考并发部分。</p>
<h5 id="8-notify"><a href="#8-notify" class="headerlink" title="8. notify()"></a>8. notify()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>唤醒</strong>可能等待<strong>该对象</strong>的<strong>对象锁的其他线程</strong>。由 JVM（与优先级无关）<strong>随机挑选</strong>一个<strong>处于 wait 状态</strong>的线程进行唤醒。</p>
<p>调用 notify()之前，线程<strong>必须获取该对象的对象锁</strong>，执行完 notify() 方法后，<strong>不会马上释放锁</strong>，直到退出 synchronized 代码块当前线程才会释放锁。</p>
<h5 id="9-notifyAll"><a href="#9-notifyAll" class="headerlink" title="9. notifyAll()"></a>9. notifyAll()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>与 notify 方法类似，只不过 notifyAll 是<strong>唤醒所有</strong>等待池中等待这个锁（共享资源）的线程，唤醒的线程进入可运行状态，同时重新竞争对象锁，之后获得锁的线程进入就绪状态。</p>
<h5 id="10-finalize"><a href="#10-finalize" class="headerlink" title="10. finalize()"></a>10. finalize()</h5><p>该方法用于<strong>垃圾回收</strong>。用于对象被回收之前的<strong>自救</strong>（详见 JVM 部分）。</p>
<h4 id="Objects类"><a href="#Objects类" class="headerlink" title="Objects类"></a>Objects类</h4><p>Objects 是一个用于对象的工具类。常用方法有：</p>
<ul>
<li>判断对象是否等价。可以传入 null 对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">deepEquals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="keyword">null</span> || b == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.deepEquals0(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>根据传入数组计算哈希值。可以用于覆写 hashCode 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p><strong>基本类型都有对应的包装类型</strong>，基本类型与其对应的包装类型之间的赋值使用<strong>自动装箱与拆箱</strong>完成。</p>
<h5 id="1-自动装箱-拆箱"><a href="#1-自动装箱-拆箱" class="headerlink" title="1. 自动装箱/拆箱"></a>1. 自动装箱/拆箱</h5><ul>
<li>对象包器类内部基本数值类型是<strong>私有</strong>的，且声明为 final 不可变，一旦构造就<strong>不能改变</strong>其包含的值。</li>
<li>自动装箱过程是<strong>编译器</strong>自动在代码中插入<strong>对象装箱代码</strong>。拆箱也是如此。</li>
<li>每种包装类都有一个静态方法 <strong>valueOf</strong>()，接收基本类型，返回引用类型，也有一个实例方法 <strong>xxxValue</strong>()，返回对应的基本类型。</li>
<li><strong>泛型</strong>中不能写基本数据类型，需要写对应的包装类。</li>
<li>6 种数值型的包装类有一个共同的父类 <strong>Number</strong> 类。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>    ---	 Byte</span><br><span class="line"><span class="keyword">short</span>   ---  Short</span><br><span class="line"><span class="keyword">int</span>	    ---  Integer</span><br><span class="line"><span class="keyword">long</span>    ---  Long</span><br><span class="line"><span class="keyword">float</span>   ---  Float</span><br><span class="line"><span class="keyword">double</span>  ---  Double</span><br><span class="line"><span class="keyword">char</span>    ---  Character</span><br><span class="line"><span class="keyword">boolean</span> ---  Boolean</span><br></pre></td></tr></table></figure>

<h5 id="2-Integer类API"><a href="#2-Integer类API" class="headerlink" title="2. Integer类API"></a>2. Integer类API</h5><h6 id="1-基本API"><a href="#1-基本API" class="headerlink" title="(1) 基本API"></a>(1) 基本API</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以int形式返回Integer对象的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span></span>;     </span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="comment">// 以一个新String对象的形式返回给定数值i的radix进制参数表示。默认10进制</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> radix)</span></span>;   </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span></span>;</span><br><span class="line"><span class="comment">// 解析字符串参数对应的整数，第二个参数为进制</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span>;</span><br></pre></td></tr></table></figure>

<h6 id="2-二进制算法"><a href="#2-二进制算法" class="headerlink" title="(2) 二进制算法"></a>(2) 二进制算法</h6><p>Integer 类有一些二进制操作，包括<strong>位翻转</strong>与<strong>循环移位</strong>等。</p>
<p>Integer 的静态方法，可以进行<strong>位翻转</strong>。位翻转就是将 int 当做二进制，左边的位与右边的位进行互换，reverse 是按照位进行互换，reverseBytes 是按 byte 进行互换。高效实现位翻转的基本思路是：首先交换相邻的单一位，然后以两位为一组，再交换相邻的位，接着 4 位一组交换、然后 8 位一组、16位一组交换之后就完成了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">reverseBytes</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-缓存池"><a href="#3-缓存池" class="headerlink" title="3. 缓存池"></a>3. 缓存池</h5><p>为了减少开销，运用了<strong>池化思想</strong>，为这些不可变的对象创造相应的<strong>缓存池</strong>，用于共享数据，是一种==<strong>享元模式</strong>==的思想。由于包装类内部的数据表示是使用 <strong>final</strong> 修饰的所以是<strong>不可变</strong>的，所以缓存的对象可以被<strong>安全的共享</strong>。</p>
<p>以包装类 <strong>Integer</strong> 为代表，其构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其内部就是用 final 修饰数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>

<p>在 Java8 中，Integer 缓存池的大小==默认为 <strong>-128~127</strong>==。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;    <span class="comment">// 默认最小值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high = <span class="number">127</span>;    <span class="comment">// 默认最大值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];	<span class="comment">// 缓存池数组</span></span><br><span class="line"><span class="comment">// 静态初始化块</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// high value may be configured by property</span></span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">    String integerCacheHighPropValue =</span><br><span class="line">        sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">    <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">            i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">            <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">            h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">            <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    high = h;</span><br><span class="line">	<span class="comment">// 初始化的时候就把值放入缓冲池中</span></span><br><span class="line">    cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> j = low;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">    <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>==valueOf()== 方法</strong>的实现比较简单，就是先判断值是否在<strong>缓存池</strong>中，如果在的话就<strong>直接返回缓存池的内容</strong>。</p>
<p>Integer 类中 <strong>valueOf</strong> 方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果在缓存范围内从缓存池数组获取数据</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="comment">// 超过范围就新建对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器会在<strong>自动装箱</strong>过程调用 <strong>valueOf</strong>() 方法，因此多个值相同且值在缓存池<strong>范围内</strong>的 Integer 实例使用自动装箱来创建，那么就会引用<strong>相同的对象</strong>。</p>
<p>虽然 -128~127 区间内的缓存值可以直接用 == 比较，但是超出范围就不行了。阿里规范建议用 <strong>equals</strong>() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Integer m = <span class="number">123</span>;  <span class="comment">// 123在缓存池中</span></span><br><span class="line">Integer n = <span class="number">123</span>;</span><br><span class="line">System.out.println(m == n); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 500不在缓存池中</span></span><br><span class="line">Integer a = Integer.valueOf(<span class="number">500</span>);</span><br><span class="line">Integer b = Integer.valueOf(<span class="number">500</span>);</span><br><span class="line">System.out.println(a == b); 	<span class="comment">// false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">// true</span></span><br><span class="line"><span class="comment">// 字面量从缓存池取</span></span><br><span class="line">Integer c = <span class="number">12</span>;</span><br><span class="line">Integer d = <span class="number">12</span>;</span><br><span class="line">System.out.println(c == d);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>其他基本类型对应的<strong>缓存池</strong>范围如下：</p>
<ul>
<li><strong>boolean</strong> values <strong>true and false</strong>。</li>
<li>all byte values。</li>
<li><strong>short</strong> values between -128 and 127。</li>
<li><strong>int</strong> values between -128 and 127。</li>
<li><strong>char</strong> in the range \u0000 to \u007F。</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。但是==只有 Integer 类可以<strong>修改</strong>默认的缓存范围==。在 VM options 加入参数：==-XX:AutoBoxChacheMax=7777==。就可以将最大缓存值设置为 7777。在此范围内的都可以用 == 进行是否相等判断。</p>
<blockquote>
<p><strong>new Integer(123)</strong> 与 <strong>Integer.valueOf(123)</strong> 的区别?</p>
</blockquote>
<ul>
<li>new Integer(123) 每次都会<strong>==新建==一个对象</strong>（用了 new 关键字）。</li>
<li>Integer.valueOf(123) 会使用<strong>缓存池中的对象</strong>，多次调用会取得<strong>同一个对象</strong>的引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相当于创建2个对象</span></span><br><span class="line">Integer x = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer y = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">System.out.println(x == y);    <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 相当于从缓存池取</span></span><br><span class="line">Integer z = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">Integer k = Integer.valueOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(z == k);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h4><h5 id="1-杂记"><a href="#1-杂记" class="headerlink" title="1. 杂记"></a>1. 杂记</h5><p>String 类对象为<strong>==不可变==</strong>字符串。<strong>优点</strong>：编译器可以让字符串<strong>共享</strong>。(可以想象各种字符串存放在公共的<strong>存储池</strong>中，字符串变量指向存储池中的位置)。但虚拟机中实际上只有<strong>字符串常量</strong>是共享的(<strong>final</strong> 修饰)，而 + 或 substring 等操作产生的结果<strong>通常并不是</strong>共享的。</p>
<p>使用 equals() 方法来检验两个字符串是否<strong>相等</strong>。比较的是内容。一定不要用 “==” 比较字符串，此比较的是对象，完全可能有两个字符串对象的内容一样但是地址不同。</p>
<p>“” 是空串，也是一个对象，有自己的长度 (0) 和内容(空)。</p>
<h5 id="2-String类重要API"><a href="#2-String类重要API" class="headerlink" title="2. String类重要API"></a>2. String类重要API</h5><p>String 类的 API 很重要啊，在笔试的时候经常操作字符串，会这些 API 可能会少很多工作。</p>
<ul>
<li>构造方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个新创建的 String 对象，使其表示一个空字符序列</span></span><br><span class="line">String();  		</span><br><span class="line"><span class="comment">// 通过使用平台的默认字符集解码指定的byte数组，构造一个新的String</span></span><br><span class="line">String(<span class="keyword">byte</span>[] bytes); 	 </span><br><span class="line"><span class="comment">// 通过使用指定的charset解码指定的byte数组，构造一个新的String</span></span><br><span class="line">String(<span class="keyword">byte</span>[] bytes, String charsetName); </span><br><span class="line"><span class="comment">// 使用字符数组(char[])创建String对分配一个新的String </span></span><br><span class="line">String(<span class="keyword">char</span>[] value); 	 </span><br><span class="line"><span class="comment">// 分配一个新的字符串，它包含字符串缓冲区参数中当前包含的字符序列</span></span><br><span class="line">String(StringBuffer buffer); </span><br><span class="line"><span class="comment">// 分配一个新的字符串，它包含字符串生成器参数中当前包含的字符序列</span></span><br><span class="line">String(StringBuilder builder);</span><br></pre></td></tr></table></figure>

<ul>
<li>长度相关。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当且仅当length()为0时返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">// 返回此字符串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断该字符串中是否包含指定的字符串序列。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当且仅当此字符串包含指定的char值序列时，返回true</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>返回<strong>指定索引处</strong>的字符值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定索引处的char字符</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>从前向后</strong>扫描，返回字符或者字符串参数在该字符串中<strong>第一次出现</strong>的索引。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定字符在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>; 		</span><br><span class="line"><span class="comment">// 返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>;   	</span><br><span class="line"><span class="comment">// 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>; 	</span><br><span class="line"><span class="comment">// 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>从后向前</strong>扫描，返回字符或字符串参数在该字符串中<strong>第一次</strong>出现的索引。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定字符在此字符串中最后一次出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch)</span></span>; 		</span><br><span class="line"><span class="comment">// 返回指定子字符串在此字符串中最右边出现处的索引 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span></span>;  	</span><br><span class="line"><span class="comment">// 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span></span>; </span><br><span class="line"><span class="comment">// 返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取该字符串的一部分子字符串。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的字符串，它是此字符串的一个子字符串</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span></span>; 			</span><br><span class="line"><span class="comment">// 返回一个新字符串，它是此字符串的一个子字符串</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span></span>; </span><br><span class="line"><span class="comment">// 这个方法经常与上面两个方法String.lastIndexOf()和String.indexOf()方法一起使用，使用这两个方法查找分割的位置，然后再使用String.subString()方法进行分割</span></span><br></pre></td></tr></table></figure>

<ul>
<li>重写 Object 类的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将此字符串与指定的对象比较</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span></span>; </span><br><span class="line"><span class="comment">// 返回此字符串的哈希码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现 comparable 接口的比较方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按字典顺序比较两个字符串 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>连接得到字符串。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在后面的每个字符串之间插入第一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">join</span><span class="params">(CharSequence delimiter, CharSequence... elements)</span></span>;      </span><br><span class="line">String all = String.join(<span class="string">"/"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);  <span class="comment">// all = "a/b/c";</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不按大小写的比较方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按字典顺序比较两个字符串，不考虑大小写 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span></span>;  </span><br><span class="line"><span class="comment">// 将此String与另一个String比较，不考虑大小写</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>基本类型：int, long, float, double, char, char 数组，Object(对象)转换成 String 的方法：String.valueOf(xxx)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span>        <span class="comment">// 返回 int 参数的字符串表示形式</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span>       <span class="comment">// 返回 long 参数的字符串表示形式</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span>      <span class="comment">// 返回 float 参数的字符串表示形式</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span>     <span class="comment">// 返回 double 参数的字符串表示形式</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span>    <span class="comment">// 返回 boolean 参数的字符串表示形式</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span>       <span class="comment">// 返回 char 参数的字符串表示形式</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span>[] data)</span></span>; <span class="comment">// 返回 char 数组参数的字符串表示形式</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span></span>;  <span class="comment">// 返回 Object 参数的字符串表示形式</span></span><br><span class="line"><span class="comment">// 返回 char 数组参数的特定子数组的字符串表示形式</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>把 String 字符串转换为<strong>字节</strong>数组。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用平台的默认字符集将此String编码为byte序列，并将结果存储到一个新的byte数组中</span></span><br><span class="line"><span class="keyword">byte</span>[] getBytes();</span><br></pre></td></tr></table></figure>

<ul>
<li>对 String 中所有的字符都进行<strong>大小写</strong>转换。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用默认语言环境的规则将此String中的所有字符都转换为小写</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span></span>;   	</span><br><span class="line"><span class="comment">// 使用默认语言环境的规则将此String中的所有字符都转换为大写</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断该字出发是否匹配给定的<strong>正则表达式</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span></span>;  <span class="comment">// 判断此字符串是否匹配给定的正则表达式</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用正则表达式<strong>分割</strong>该字符串为字符串数组。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据给定正则表达式的匹配拆分此字符串</span></span><br><span class="line">String[] split(String regex);   </span><br><span class="line"><span class="comment">// 根据匹配给定的正则表达式来拆分此字符串 </span></span><br><span class="line">String[] split(String regex, <span class="keyword">int</span> limit);  </span><br><span class="line"> <span class="comment">// 注意，获取的数组中不包含作为分割符的字符(或字符串)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断字符串的<strong>前缀后缀</strong>（注意加了 s）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span>;  </span><br><span class="line"><span class="comment">// 测试此字符串从指定索引开始的子字符串是否以指定前缀开</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span></span>; </span><br><span class="line"><span class="comment">// 测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>该字符串与指定的字符序列或者 StringBuffer 比较。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(CharSequence cs)</span></span>; <span class="comment">// 将此字符串与指定的 CharSequence 比较</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(StringBuffer sb)</span></span>; <span class="comment">// 将此字符串与指定的 StringBuffer 比较</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>把字符数组转换成 String。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定数组中表示该字符序列的 String</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span>[] data)</span></span>; </span><br><span class="line"><span class="comment">// 返回指定数组中表示该字符序列的 String</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span>[] data, <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>把该字符串中的字符拷贝到指定的字符数组中去。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符从此字符串复制到目标字符数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span>[] dst, <span class="keyword">int</span> dstBegin)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>把该字符串转换成字符数组</strong>：笔试经常用！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] toCharArray(); <span class="comment">// 将此字符串转换为一个新的字符数组</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用新字符<strong>替换</strong>字符串中的旧字符。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个新的字符串，用newChar替换此字符串中所有的oldChar得到</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span></span>; </span><br><span class="line"><span class="comment">// 使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用<strong>新子字符串替换该字符串</strong>中匹配正则表达式的那些旧子字符串：一个全部替换，一个只替换<strong>第一个</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串 </span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span></span>; </span><br><span class="line"><span class="comment">// 使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串    </span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>把该字符串规范化表示，去掉该字符串的前后空白符。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">intern</span><span class="params">()</span></span>;    <span class="comment">// 返回字符串对象的规范化表示形式 放到常量池</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span></span>;      <span class="comment">// 返回字符串的副本，忽略前导空白和尾部空白。中间不去</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断该字符串的子字符串是否相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试两个字符串区域是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span>; </span><br><span class="line"><span class="comment">// 测试两个字符串区域是否相等</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h5><p>以下分析基于 Java11。</p>
<h6 id="1-基本属性"><a href="#1-基本属性" class="headerlink" title="(1) 基本属性"></a>(1) 基本属性</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> </span></span><br><span class="line"><span class="class">    <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出 String 类实现了序列化和比较接口。CharSequence：这个接口是一个<strong>只读的字符序列</strong>。StringBuffer 和 StringBuild也 是实现了这个接口。String 被声明为 <strong>==final==</strong>，因此它<strong>不可被继承</strong>。</p>
<p>在 Java 8 中，String 内部使用 <strong>char 数组</strong>存储数据。char 可以存很多种不同的字符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据数组声明为final不可变</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure>

<p>在 Java 9 <strong>之后</strong>，String 类的实现改用 <strong>==byte 数组==</strong>存储字符串，同时使用 <strong>coder</strong> 来标识使用了哪种<strong>编码</strong>。byte 存储的字符范围较小，所以额外需要 coder 标识编码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**用数组存储实际的数据*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**标识编码*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 哈希值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="comment">// 比较器</span></span><br><span class="line"> 　　<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER </span><br><span class="line">        = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>value 数组被声明为 final</strong>，这意味着 value 数组初始化之后就<strong>不能再引用其它数组</strong>。并且 String 内部没有改变 value 数组的方法，因此可以保证 String <strong>不可变</strong>，由于是不可变对象，所以<strong>天生线程安全</strong>。</p>
<p>而 <strong>hash</strong> 是 String 实例化的 hashcode 的一个<strong>缓存</strong>，这样就不用每次比较都去计算哈希值了。</p>
<p>这个 <strong>CASE_INSENSITIVE_ORDER</strong> 就是持有一个静态内部类，用于<strong>忽略大小写得比较两个字符串</strong>。在 String 中已经有了一个 compareTo 的方法，为什么还要有一个 CaseInsensitiveComparator 的内部静态类呢？其实这一切都是为了<strong>代码复用</strong>。</p>
<h6 id="2-主要方法"><a href="#2-主要方法" class="headerlink" title="(2) 主要方法"></a>(2) 主要方法</h6><p>String 类提供了很多<strong>看似修改</strong> String 的方法，实际上都是通过<strong>创建新的 String 对象</strong>来实现的。</p>
<p>以下是 String <strong>构造函数</strong>的源码，可以看到，在将一个<strong>字符串对象</strong>作为另一个字符串对象的构造函数参数时，并<strong>不会完全复制</strong> value 数组内容，而是都会<strong>指向同一个 value 数组</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">    <span class="keyword">this</span>.coder = <span class="string">""</span>.coder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;    <span class="comment">// value是String类中内部存放数据的final数组</span></span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>几个基本方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>String 其实内部是通过 <strong>char</strong>[] 实现的，那么就不难发现 length()，isEmpty()，charAt() 这些方法其实就是在内部<strong>调用数组</strong>的方法。</p>
<p>再看看计算<strong>哈希值和判等</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        hash = h = isLatin1() ? StringLatin1.hashCode(value)</span><br><span class="line">            : StringUTF16.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLatin1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> COMPACT_STRINGS &amp;&amp; coder == LATIN1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即首先判断编码 coder 是否是 <strong>LATIN</strong>，然后根据结果选择用 StringLatin1 或者 StringUTF16 的 hashCode 方法。</p>
<p>StringLatin1.hashCode() 如下。<strong>这个地方顺丰面试问了</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">byte</span> v : value) &#123;</span><br><span class="line">        h = <span class="number">31</span> * h + (v &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringUTF16.hashCode(value) 如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> length = value.length &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        h = <span class="number">31</span> * h + getChar(value, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看 equals 方法。对 equals 进行了覆写。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果地址相同直接返回true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首先判断是否是String的类型</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">// 获取这个对象的String</span></span><br><span class="line">        String aString = (String)anObject;</span><br><span class="line">        <span class="keyword">if</span> (coder() == aString.coder()) &#123;</span><br><span class="line">            <span class="keyword">return</span> isLatin1() ? StringLatin1.equals(value, aString.value)</span><br><span class="line">                : StringUTF16.equals(value, aString.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到也是判断 coder 类型然后选择不同的 equals 方法进行判断。选其中一个看吧。</p>
<p><strong>StringLatin1.equals</strong>(value, aString.value) 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(<span class="keyword">byte</span>[] value, <span class="keyword">byte</span>[] other)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先判断长度</span></span><br><span class="line">    <span class="keyword">if</span> (value.length == other.length) &#123;</span><br><span class="line">        <span class="comment">// 如果两个长度相同每次取相同索引位置的地方的元素进行比较</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value[i] != other[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-不可变的好处"><a href="#4-不可变的好处" class="headerlink" title="4. 不可变的好处"></a>4. 不可变的好处</h5><p><strong>(1) 可以缓存hash值</strong> </p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 <strong>HashMap 的 key</strong>。不可变的特性可以使得 <strong>hash 值也不可变</strong>，因此只需要进行<strong>一次</strong>计算，即可缓存起来下次用。源码里面使用 hash 存放哈希值。</p>
<p><strong>(2) 可以创建String Pool</strong> </p>
<p>如果一个 String 对象已经被<strong>创建</strong>过了，那么就会从 String Pool 中取得引用。只有 String 是<strong>不可变</strong>的，才可能使用 String Pool 缓存池。</p>
<p><strong>(3) 参数安全性</strong> </p>
<p>String 经常作为参数，String 不可变性可以保证<strong>参数不可变</strong>。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>(4) ==线程安全==</strong> </p>
<p>String 不可变性天生具备==<strong>线程安全</strong>==，可以在<strong>多个线程中安全地使用</strong>。可共享。String类是 <strong>immutable</strong> 类，可以安全的在多线程中共享。</p>
<h5 id="5-String-Pool"><a href="#5-String-Pool" class="headerlink" title="5. String Pool"></a>5. String Pool</h5><p><strong>字符串常量池</strong>（String Pool）保存着所有<strong>字符串字面量</strong>（literal strings），这些字面量在<strong>编译时期</strong>就确定。还可以使用 <strong>String 的 ==intern()==</strong> 方法在运行过程中<strong>将字符串添加到 String Pool</strong> 中。虚拟机为字符串字面量开辟一个<strong>字符串常量池</strong>，类似于<strong>缓存区</strong>，创建<strong>字符串常量</strong>时，首先<strong>查询字符串常量池是否存在该字符串</strong>，如果存在该<strong>字符串</strong>，返回<strong>引用实例</strong>，不存在，<strong>实例化该字符串并放入池</strong>中。</p>
<p>在 Java 中有两种创建<strong>字符串对象</strong>的方式：1）采用<strong>字面值</strong>的方式赋值  2）采用 <strong>new</strong> 关键字新建一个<strong>字符串对象</strong>。这两种方式在性能和内存占用方面存在着差别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(“aaa”);</span><br><span class="line">String str2 = “aaa”;</span><br></pre></td></tr></table></figure>

<p>new String() 方式首先检查 String pool 中有没有这个字符串，如果没有则先在 String pool 中创建一个字符串，然后再在<strong>堆</strong>中创建一个字符串，并返回堆中字符串的引用。如果 String Pool 中已经有了，则仅在堆中创建。所以可能创建一个对象也可能创建两个对象。</p>
<p>虽然两个语句都是返回一个 String 对象的<strong>引用</strong>，但是 JVM 对这两种创建的方式是不一样的。看下面的<strong>代码和图</strong>进行理解！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">System.out.println(s1 == s2);	<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="string">"aaa"</span>;</span><br><span class="line">String s4 = <span class="string">"aaa"</span>;</span><br><span class="line">System.out.println(s1 == s3);	<span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s4);	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">String s5 = <span class="string">"bbb"</span>;</span><br><span class="line">String s6 = <span class="string">"bbb"</span>;</span><br><span class="line">System.out.println(s5 == s6);	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">s1 = s1.intern();   <span class="comment">// 检查String Pool中没有"aaa"则添加进去</span></span><br><span class="line">s2 = s2.intern();</span><br><span class="line">System.out.println(s1 == s2);	<span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s3);	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>流程分析：</strong></p>
<p>对于 <strong>new 新建对象</strong>的方式，，如果 String Pool 中没有，JVM 会在内部维护的 <strong>String Pool</strong> 中存放一个 “aaa” 的<strong>对象</strong>，并且在 <strong>堆</strong> 中<strong>再创建一个 String 对象</strong>，然后将该<strong>堆</strong>中的对象的<strong>引用返回给用户</strong>（所以指向的是堆中的对象），如下图创建 <strong>S1</strong> 时，缓存池中没有 “aaa”，所以在缓存池中存放入 “aaa”，此时再在堆中创建一个 “aaa”，并将对中字符串的引用返回，所以此时 S1 指向的是缓存池外面堆中的 “aaa”。</p>
<p>当执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br></pre></td></tr></table></figure>

<p>时，首先去看 Pool 中，已经有了 “aaa” ，所以 Pool 中就<strong>不管</strong>了。然后再 Pool 外再新建一个 “aaa”，并返回其引用给 S2，所以 S2 指向的其实是 Pool 外面堆中的另一个 “aaa” 对象。所以 S1 和 S2 其实是各自指向自己的 Pool 外的对象它们只是把 “aaa” 放入 Pool 就<strong>不用</strong>了（注意：这时候其实已经创建了 <strong>3 个对象</strong>）。所以有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(s1 == s2);	<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>然后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="string">"aaa"</span>;</span><br><span class="line">String s4 = <span class="string">"aaa"</span>;</span><br></pre></td></tr></table></figure>

<p>这就是第二种以<strong>字面量</strong>的方式创建字符串的方式，JVM 首先会在 <strong>String Pool</strong> 中查找是否存在 “aaa” 对象，如果已经有<strong>则不创建</strong>，没有的话则在 String Pool 中<strong>创建一个对象</strong>。即<strong>字面量</strong>形式创建会<strong>==自动==地将字符串放入 String Pool 中</strong>。</p>
<p>所以创建的 s3 和 s4 都是直接从 Pool <strong>取出引用</strong>而同时指向的 Pool 中的 “aaa”。所以有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(s1 == s3);	<span class="comment">// false 因为不是一个对象</span></span><br><span class="line">System.out.println(s3 == s4);	<span class="comment">// true  因为是同一个对象</span></span><br></pre></td></tr></table></figure>

<img src="assets/image-20200504165902815.png" alt="image-20200504165902815" style="zoom: 50%;" />

<p>当一个字符串调用 <strong>intern</strong>() 方法时，如果 String Pool 中已经存在一个字符串和该字符串<strong>值相等</strong>（使用 equals() 方法进行确定），那么<strong>就会返回</strong> String Pool 中字符串的<strong>引用</strong>；否则，就会在 String Pool 中<strong>添加</strong>一个新的字符串，并返回这个新字符串的引用。</p>
<p>所以执行下面时</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1 = s1.intern();   <span class="comment">// 检查String Pool中没有"aaa"则添加进去</span></span><br><span class="line">s2 = s2.intern();</span><br></pre></td></tr></table></figure>

<p>s1 和 s2 会把 “aaa” 放入 Pool 中，但是已经有了就不放了。这时候 s1 和 s2 会修改它们的指针转而指向 Pool 中的<strong>同一个 “aaa” 对象</strong>，所以这时候有 s1 和 s2 和 s3 都指向了 Pool 中的同一个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(s1 == s2);	<span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s3);	<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在 Java7 之前，String Pool 被放在<strong>运行时常量池</strong>中，它属于<strong>永久代</strong>。而在 Java 7，String Pool 被移到<strong>==堆==</strong>中。这是因为永久代的空间<strong>有限</strong>，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p>
<p><strong>String Pool 总结：</strong></p>
<ul>
<li>单独使用 “” 引号创建的字面量字符串和使用只包含常量的字符串连接符如 “aa” + “bb” 创建的字符串都是<strong>常量</strong>，<strong>编译期</strong>就已经确定存储到 String Pool 中。</li>
<li>使用 <strong>new String(“”)</strong> 创建的对象会存储到<strong>堆中</strong>（如果 pool 中没有也会创建），是<strong>运行期</strong>新创建的。</li>
<li>使用包含变量的字符串连接如 “aa” + s 创建的对象是<strong>运行期</strong>才创建的，存储到 <strong>堆</strong> 中。</li>
<li>运行期调用 String 的 intern() 方法可以向 String Pool 中动态添加字符串。</li>
</ul>
<h5 id="6-详解new-String-“aaa”"><a href="#6-详解new-String-“aaa”" class="headerlink" title="6. 详解new String(“aaa”)"></a>6. 详解new String(“aaa”)</h5><p>使用这种方式一共会创建<strong>两个字符串对象</strong>（前提是 String Pool 中还没有 “aaa” 字符串对象）。</p>
<ul>
<li>“aaa” 属于字符串<strong>字面量</strong>，因此编译时期会在 <strong>String Pool</strong> 中创建一个字符串对象，指向这个 “abc” 字符串字面量；</li>
<li>而使用 new 的方式会在<strong>堆中</strong>创建一个字符串对象，返回的<strong>引用</strong>指向的是<strong>堆中</strong>的字符串而不是 String Pool 中的。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewStringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap -verbose 进行<strong>反编译</strong>，得到以下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Constant pool:</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">   #2 = Class              #18            // java/lang/String</span><br><span class="line">   #3 = String             #19            // abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  #18 = Utf8               java/lang/String</span><br><span class="line">  #19 = Utf8               abc</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(java.lang.String[])</span></span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">3</span>, locals=<span class="number">2</span>, args_size=<span class="number">1</span></span><br><span class="line">         0: new           #2                  // class java/lang/String</span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         4: ldc           #3                  // String abc</span><br><span class="line">         6: invokespecial #4                  // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">         <span class="number">9</span>: astore_1</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>在 Constant Pool 中，<strong>#19</strong> 存储这字符串<strong>字面量</strong> “abc”，#3 是 <strong>String Pool</strong> 的字符串<strong>对象</strong>，它<strong>指向</strong> #19 这个字符串字面量。在 main 方法中，0: 行使用 new <strong>#2</strong> 在<strong>堆</strong>中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p><strong>考题拓展</strong></p>
<p>下面代码会创建几个对象？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"aaa"</span>);</span><br></pre></td></tr></table></figure>

<p>其实会创建 <strong>3 个</strong>对象。第一句在 <strong>Pool 中和堆中</strong>各创建一个对象，第二句由于 Pool 已经有了 “aaa” 所以<strong>不会再在 Pool 中创建了</strong>，仅会在<strong>堆中</strong>创建，所以一共创建了 3 个对象。</p>
<blockquote>
<p>下面代码会创建几个对象？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"A"</span> + <span class="string">"B"</span>) ;</span><br></pre></td></tr></table></figure>

<p>字符串常量池：”A”,”B”,”AB” : 3个<br>堆：new String(“AB”) ：1个<br>引用： str1 ：1个<br>总共 ： 5个  </p>
<blockquote>
<p>下面代码会创建几个对象？</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"ABC"</span>) + <span class="string">"ABC"</span> ;</span><br></pre></td></tr></table></figure>

<p>字符串常量池：”ABC” : 1个<br>堆：new String(“ABC”) ：1个<br>引用： str2 ：1个<br>总共 ： 3个  </p>
<h5 id="7-StringBuilder-StringBuffer类"><a href="#7-StringBuilder-StringBuffer类" class="headerlink" title="7. StringBuilder/StringBuffer类"></a>7. StringBuilder/StringBuffer类</h5><p>继承体系如下图所示：</p>
<img src="assets/1582383197264.png" alt="1582383197264" style="zoom:77%;" />

<h6 id="1-可变性"><a href="#1-可变性" class="headerlink" title="(1) 可变性"></a>(1) 可变性</h6><blockquote>
<p>StringBuilder 与 StringBuffer 为什么是可变的？</p>
</blockquote>
<p>String 类中使用 <strong>final</strong> 关键字修饰<strong>字符数组</strong>来保存字符串，所以 String 对象是<strong>不可变</strong>的。</p>
<p>StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用<strong>字符数组</strong>保存字符串，但是<strong>没有用 final 关键字修饰</strong>，所以这两种对象都是<strong>可变</strong>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放数据的数组，没有用final</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="comment">// 记录已经用的数组数量</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。</p>
<p>当<strong>对字符串进行修改</strong>的时候，需要使用 StringBuffer 和 StringBuilder 类。和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被<strong>多次的修改</strong>，并且<strong>不产生新的未使用对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    <span class="comment">// 这里直接传入value数组并将新的str添加到value数组中，没有创建新的对象</span></span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-线程安全性"><a href="#2-线程安全性" class="headerlink" title="(2) 线程安全性"></a>(2) 线程安全性</h6><p>字符串<strong>修改较为频繁</strong>时使用，StringBuilder 与 StringBuffer 实现<strong>几乎相同</strong>，只是<strong>StringBuilder</strong> 线程<strong>不安全</strong>（不能同步访问）， <strong>StringBuffer</strong> <strong>线程安全</strong>。由于 StringBuilder 相较于 StringBuffer 有速度优势，<strong>所以多数情况下建议使用 StringBuilder 类</strong>。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>
<p>StringBuilder 的 append 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StringBuffer 的 append 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出两者其实最终都调用他们的共同<strong>父类 AbstractStringBuilder 的 append</strong> 方法，但是 StringBuffer 是用了 <strong>synchronized</strong> 锁住的。</p>
<h6 id="3-使用原则"><a href="#3-使用原则" class="headerlink" title="(3) 使用原则"></a>(3) 使用原则</h6><p><strong>基本原则</strong>：如果要操作少量的数据，用 String ；单线程操作大量数据，用 StringBuilder ；多线程操作大量数据，用 StringBuffer。</p>
<p><strong>可变性</strong> ：String 不可变。StringBuffer 和 StringBuilder 可变。</p>
<p><strong>线程安全</strong>：String <strong>不可变</strong>，因此是<strong>线程安全</strong>的；StringBuilder 不是<strong>线程安全</strong>的；StringBuffer 是线程安全的，内部使用 <strong>synchronized</strong> 进行同步，所以<strong>速度慢</strong>。</p>
<h4 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>Arrays 类主要是用于操作<strong>数组</strong>的工具类。</p>
<h5 id="2-Arrays类的API"><a href="#2-Arrays类的API" class="headerlink" title="2. Arrays类的API"></a>2. Arrays类的API</h5><p>有的 API 在笔试的时候非常有用！</p>
<ul>
<li><strong>排序</strong>：使用 <strong>Arrays.sort()</strong> 方法对<strong>数值型</strong>数组排序，使用的是<strong>快速排序</strong>算法。也可传入<strong>比较器</strong>对象进行排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span>;  <span class="comment">// 对数组进行排序</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>二分查找</strong>：(注意：二分法查找是针对<strong>排序好</strong>的数组才可以使用)。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  在整个数组中按照二分查找法查找数据，查找成功返回下标，否则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(type[] a, type v)</span></span>;   </span><br><span class="line"><span class="comment">// 在整个数组中按照二分查找法从传入的开始位置和结束位置查找数据，查找成功返回下标，否则返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(type[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end, type v)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>数组转列表</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] a = &#123;<span class="string">"11"</span>, <span class="string">"22"</span>, <span class="string">"33"</span>&#125;;		</span><br><span class="line"><span class="comment">// 将字符串数组转换为列表</span></span><br><span class="line">List&lt;String&gt; stringList = Arrays.asList(a);</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>toString</strong> 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组中的元素拼接成一个字符串 [1, 2, 3, 4]</span></span><br><span class="line"><span class="function">String <span class="keyword">static</span> <span class="title">toString</span><span class="params">(type[] b)</span></span>;   	    </span><br><span class="line"><span class="comment">// 将二维数组转换为字符串形式</span></span><br><span class="line"><span class="function">String <span class="keyword">static</span> <span class="title">deepToString</span><span class="params">(type[] a)</span></span>;   	 </span><br><span class="line"><span class="comment">// 定义一个二维数组</span></span><br><span class="line"><span class="keyword">int</span>[][] magicSquare = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;; </span><br><span class="line"><span class="comment">// 将多维转字符串</span></span><br><span class="line">String s = Arrays.deepToString(magicSquare);    </span><br><span class="line"><span class="comment">// s = "[[1, 2], [3, 4], [5, 6]]";</span></span><br></pre></td></tr></table></figure>

<ul>
<li>拷贝。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] b = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;    <span class="comment">// 创建并初始化数组</span></span><br><span class="line"><span class="comment">// 将数组b全部重新拷贝给另一个数组两者指向不同。第二个参数为长度。</span></span><br><span class="line"><span class="keyword">int</span>[] copyb = Arrays.copyOf(b, b.length);   </span><br><span class="line"><span class="comment">// 将源数组按照传入的开始位置和结束位置拷贝到一个新的数组中;</span></span><br><span class="line"><span class="function">type <span class="keyword">static</span> <span class="title">copyOfRange</span><span class="params">(type[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>其他常用方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数据按照传入的长度拷贝到一个新的数组中</span></span><br><span class="line"><span class="function">type <span class="keyword">static</span> <span class="title">valueOf</span><span class="params">(type[] a, <span class="keyword">int</span> length)</span></span>;  </span><br><span class="line"><span class="comment">// 将数组中的所有元素值都设置为v</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">(type[] a, type v)</span></span>;  </span><br><span class="line"><span class="comment">// 如果两个数组的长度和每个元素值都相等，那么返回true,否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(type[] a, type[] b)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h5><p>这里看看几个常用方法的源码。</p>
<h6 id="1-Arrays-sort"><a href="#1-Arrays-sort" class="headerlink" title="(1) Arrays.sort()"></a>(1) Arrays.sort()</h6><p>源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    DualPivotQuicksort.sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的是 DualPivotQuicksort.sort() 方法。这他娘的好复杂，以后再看吧。。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] work, <span class="keyword">int</span> workBase, <span class="keyword">int</span> workLen)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 小数组用快排 QUICKSORT_THRESHOLD = 286</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt; QUICKSORT_THRESHOLD) &#123;</span><br><span class="line">        sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Index run[i] is the start of i-th run</span></span><br><span class="line"><span class="comment">     * (ascending or descending sequence).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[] run = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_RUN_COUNT + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>; run[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the array is nearly sorted</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">        <span class="comment">// Equal items in the beginning of the sequence</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; right &amp;&amp; a[k] == a[k + <span class="number">1</span>])</span><br><span class="line">            k++;</span><br><span class="line">        <span class="keyword">if</span> (k == right) <span class="keyword">break</span>;  <span class="comment">// Sequence finishes with equal items</span></span><br><span class="line">        <span class="keyword">if</span> (a[k] &lt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// ascending</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &lt;= a[k]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] &gt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// descending</span></span><br><span class="line">            <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &gt;= a[k]);</span><br><span class="line">            <span class="comment">// Transform into an ascending sequence</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> lo = run[count] - <span class="number">1</span>, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Merge a transformed descending sequence followed by an</span></span><br><span class="line">        <span class="comment">// ascending sequence</span></span><br><span class="line">        <span class="keyword">if</span> (run[count] &gt; left &amp;&amp; a[run[count]] &gt;= a[run[count] - <span class="number">1</span>]) &#123;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The array is not highly structured,</span></span><br><span class="line"><span class="comment">         * use Quicksort instead of merge sort.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">            sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// These invariants should hold true:</span></span><br><span class="line">    <span class="comment">//    run[0] = 0</span></span><br><span class="line">    <span class="comment">//    run[&lt;last&gt;] = right + 1; (terminator)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// A single equal run</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span> &amp;&amp; run[count] &gt; right) &#123;</span><br><span class="line">        <span class="comment">// Either a single ascending or a transformed descending run.</span></span><br><span class="line">        <span class="comment">// Always check that a final run is a proper terminator, otherwise</span></span><br><span class="line">        <span class="comment">// we have an unterminated trailing run, to handle downstream.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    right++;</span><br><span class="line">    <span class="keyword">if</span> (run[count] &lt; right) &#123;</span><br><span class="line">        <span class="comment">// Corner case: the final run is not a terminator. This may happen</span></span><br><span class="line">        <span class="comment">// if a final run is an equals run, or there is a single-element run</span></span><br><span class="line">        <span class="comment">// at the end. Fix up by adding a proper terminator at the end.</span></span><br><span class="line">        <span class="comment">// Note that we terminate with (right + 1), incremented earlier.</span></span><br><span class="line">        run[++count] = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine alternation base for merge</span></span><br><span class="line">    <span class="keyword">byte</span> odd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; (n &lt;&lt;= <span class="number">1</span>) &lt; count; odd ^= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use or create temporary array b for merging</span></span><br><span class="line">    <span class="keyword">int</span>[] b;                 <span class="comment">// temp array; alternates with a</span></span><br><span class="line">    <span class="keyword">int</span> ao, bo;              <span class="comment">// array offsets from 'left'</span></span><br><span class="line">    <span class="keyword">int</span> blen = right - left; <span class="comment">// space needed for b</span></span><br><span class="line">    <span class="keyword">if</span> (work == <span class="keyword">null</span> || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">        work = <span class="keyword">new</span> <span class="keyword">int</span>[blen];</span><br><span class="line">        workBase = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (odd == <span class="number">0</span>) &#123;</span><br><span class="line">        System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">        b = a;</span><br><span class="line">        bo = <span class="number">0</span>;</span><br><span class="line">        a = work;</span><br><span class="line">        ao = workBase - left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = work;</span><br><span class="line">        ao = <span class="number">0</span>;</span><br><span class="line">        bo = workBase - left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merging</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> last; count &gt; <span class="number">1</span>; count = last) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = (last = <span class="number">0</span>) + <span class="number">2</span>; k &lt;= count; k += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> hi = run[k], mi = run[k - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = run[k - <span class="number">2</span>], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                    b[i + bo] = a[p++ + ao];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    b[i + bo] = a[q++ + ao];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            run[++last] = hi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = right, lo = run[count - <span class="number">1</span>]; --i &gt;= lo;</span><br><span class="line">                 b[i + bo] = a[i + ao]</span><br><span class="line">                );</span><br><span class="line">            run[++last] = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] t = a; a = b; b = t;</span><br><span class="line">        <span class="keyword">int</span> o = ao; ao = bo; bo = o;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-Arrays-binarySearch"><a href="#2-Arrays-binarySearch" class="headerlink" title="(2) Arrays.binarySearch()"></a>(2) Arrays.binarySearch()</h6><p>看看<strong>二分查找</strong>的算法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> binarySearch0(a, <span class="number">0</span>, a.length, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用的是本类中的 <strong>binarySearch0</strong> 方法，用的<strong>迭代法</strong>。可以学习一波。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Like public version, but without range checks.</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch0</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 左边索引</span></span><br><span class="line">    <span class="keyword">int</span> low = fromIndex;</span><br><span class="line">    <span class="comment">// 右边索引</span></span><br><span class="line">    <span class="keyword">int</span> high = toIndex - <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// 左索引小于等于右索引</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="comment">// 求中间索引</span></span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 求中间值</span></span><br><span class="line">        <span class="keyword">int</span> midVal = a[mid];</span><br><span class="line">        <span class="comment">// 中间值小于目标值</span></span><br><span class="line">        <span class="keyword">if</span> (midVal &lt; key)</span><br><span class="line">            <span class="comment">// 左索引跑到在中间索引右边</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 中间值大于目标值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (midVal &gt; key)</span><br><span class="line">            <span class="comment">// 更新右索引</span></span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到模板值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-System-arrayCopy"><a href="#4-System-arrayCopy" class="headerlink" title="4. System.arrayCopy()"></a>4. System.arrayCopy()</h5><p>开发设计者在对数组的<strong>复制</strong>时，通常都会使用 <strong>System.arraycopy()</strong> 方法。</p>
<p>System.arraycopy() 的 API ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,  // 源数组</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> srcPos,  // 源数组的起始位置</span></span></span><br><span class="line"><span class="function"><span class="params">                             Object dest, // 目标数组</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> destPos, // 目标数组的起始位置</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> length   // 复制长度</span></span></span><br><span class="line"><span class="function"><span class="params">                             )</span></span>;</span><br></pre></td></tr></table></figure>

<p>System.arraycopy() 在拷贝数组的时候，采用的使用<strong>浅拷贝</strong>，如果是拷贝对象数组则需要注意一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String[] st  = &#123;<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>&#125;;</span><br><span class="line">String[] dt  = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">System.arraycopy(st, <span class="number">0</span>, dt, <span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(String str : st)&#123;</span><br><span class="line">    System.out.print(<span class="string">" "</span> + str +<span class="string">" "</span>);   <span class="comment">// A  B  C  D  E </span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(); </span><br><span class="line"><span class="keyword">for</span>(String str : dt)&#123;</span><br><span class="line">    System.out.print(<span class="string">" "</span> + str +<span class="string">" "</span>);   <span class="comment">// A  B  C  D  E </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(st[<span class="number">0</span>] == dt[<span class="number">0</span>]); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>



<h4 id="其他类"><a href="#其他类" class="headerlink" title="其他类"></a>其他类</h4><h5 id="1-BigDecimal-BigInteger类"><a href="#1-BigDecimal-BigInteger类" class="headerlink" title="1. BigDecimal/BigInteger类"></a>1. BigDecimal/BigInteger类</h5><p>BigInteger 用于处理大型数据，可以处理<strong>任意长度</strong>数字序列的数值，BigDecimal 用于<strong>精确计算</strong>（如财务数据）。它们的初始化需要调用相应的<strong>构造器</strong>。大数的加减乘除也<strong>不能</strong>使用 +、-、*、/ 这些运算符号，而是用一些方法来代替，比如 add()、subtract()、mutiply()、divide() 这四种方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法，直接将十进制的字符串格式变成大整数</span></span><br><span class="line">BigInteger a = BigInteger.valueOf(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// API BigInteger和BigDecimal 的方法类似</span></span><br><span class="line"><span class="function">BigInteger <span class="title">abs</span><span class="params">()</span>                    <span class="comment">// 绝对值</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span>      <span class="comment">// 和</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span>   <span class="comment">// 商</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span> <span class="comment">// 积</span></span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span>                  <span class="comment">// 大整数的float类型的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span>                      <span class="comment">// 大整数的整型值</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span>                    <span class="comment">// 大整数的long型值</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">max</span><span class="params">(BigInteger val)</span>      <span class="comment">// 两个大整数的最大者</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">min</span><span class="params">(BigInteger val)</span>      <span class="comment">// 两个大整数的最小者</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger val)</span>      <span class="comment">// 求模</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">pow</span><span class="params">(<span class="keyword">int</span> exponent)</span> <span class="comment">// 返回当前大整数的exponent次方</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">remainder</span><span class="params">(BigInteger val)</span> <span class="comment">// 返回当前大整数除以val的余数</span></span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span>  <span class="comment">// 返回两个大整数相减的结果</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> <span class="comment">// 将当前大整数转换成十进制的字符串形式</span></span></span><br></pre></td></tr></table></figure>

<h5 id="2-Random-类"><a href="#2-Random-类" class="headerlink" title="2. Random 类"></a>2. Random 类</h5><h6 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="(1) 概述"></a>(1) 概述</h6><p>Random 类位于 java.util 包中，主要用于生成<strong>伪随机数</strong>。Random 类将 <strong>种子数</strong> 作为随机算法的起源数字，计算生成伪随机数，其与生成的随机数字的区间无关。若没有指定种子数，则会以<strong>当前时间</strong>作为种子数。</p>
<p>拥有相同种子的 Random 实例，在相同次数下，生成的伪随机数完全相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Random random1 = <span class="keyword">new</span> Random(<span class="number">10</span>);</span><br><span class="line">Random random2 = <span class="keyword">new</span> Random(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 因为中子数相同</span></span><br><span class="line">System.out.println(random1.nextInt()); <span class="comment">// -1157793070</span></span><br><span class="line">System.out.println(random2.nextInt()); <span class="comment">// -1157793070</span></span><br></pre></td></tr></table></figure>

<p>Random 类是<strong>线程安全</strong>的，多个线程可以同时使用一个 Random 实例对象，但如果并发性很高，会产生<strong>竞争</strong>，这时可以使用 JUC 中的 <strong>ThreadLocalRandom</strong> 类。</p>
<h6 id="2-常用方法"><a href="#2-常用方法" class="headerlink" title="(2) 常用方法"></a>(2) 常用方法</h6><ul>
<li><strong>random.nextInt()</strong>：用于从该随机数生成器的序列中得到下一个伪均匀分布的 <strong>int 值</strong>。</li>
<li><strong>random.nextInt(int bound)</strong>：用于从该随机数生成器的序列中得到下一个 0 到给定值之间伪均匀分布的 int 值，<strong>[0, 结束值)</strong>。</li>
<li><strong>random.nextBoolean()</strong>：用于从该随机数生成器的序列中得到下一个伪均匀分布的 boolean 值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">System.out.println(random.nextInt()); 	<span class="comment">// 1414623307 没指定范围</span></span><br><span class="line">System.out.println(random.nextInt(<span class="number">10</span>)); <span class="comment">// 指定了范围</span></span><br><span class="line">System.out.println(random.nextBoolean()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>





<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><p><a href="https://blog.csdn.net/Creepin_/article/details/105246043" target="_blank" rel="noopener">Java枚举原理</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/HuiH/p/11677018.html" target="_blank" rel="noopener">Java之Object类</a></p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/A-7%20%E5%B8%B8%E7%94%A8%E6%8E%A5%E5%8F%A3/" rel="next" title="ShiftJava/A Java/A-7 常用接口">
                <i class="fa fa-chevron-left"></i> ShiftJava/A Java/A-7 常用接口
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/A-5%20%E6%9E%9A%E4%B8%BE%E7%B1%BB/" rel="prev" title="ShiftJava/A Java/A-5 枚举类">
                ShiftJava/A Java/A-5 枚举类 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#常用类"><span class="nav-number">1.</span> <span class="nav-text">常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Object类"><span class="nav-number">1.1.</span> <span class="nav-text">Object类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Object类API"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. Object类API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-equals"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. equals()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-等价的特性"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">(1) 等价的特性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-覆写equals方法"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">(2) 覆写equals方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-合理使用equals方法"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">(3) 合理使用equals方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-hashCode"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. hashCode()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-概述"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">(1) 概述</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-散列函数"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">(2) 散列函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-toString"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. toString()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-clone"><span class="nav-number">1.1.5.</span> <span class="nav-text">5. clone()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-getClass"><span class="nav-number">1.1.6.</span> <span class="nav-text">6. getClass()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-wait"><span class="nav-number">1.1.7.</span> <span class="nav-text">7. wait()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-notify"><span class="nav-number">1.1.8.</span> <span class="nav-text">8. notify()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-notifyAll"><span class="nav-number">1.1.9.</span> <span class="nav-text">9. notifyAll()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-finalize"><span class="nav-number">1.1.10.</span> <span class="nav-text">10. finalize()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Objects类"><span class="nav-number">1.2.</span> <span class="nav-text">Objects类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#包装类"><span class="nav-number">1.3.</span> <span class="nav-text">包装类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-自动装箱-拆箱"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 自动装箱/拆箱</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Integer类API"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. Integer类API</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-基本API"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">(1) 基本API</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-二进制算法"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">(2) 二进制算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-缓存池"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 缓存池</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String类"><span class="nav-number">1.4.</span> <span class="nav-text">String类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-杂记"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 杂记</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-String类重要API"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. String类重要API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-源码分析"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-基本属性"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">(1) 基本属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-主要方法"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">(2) 主要方法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-不可变的好处"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. 不可变的好处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-String-Pool"><span class="nav-number">1.4.5.</span> <span class="nav-text">5. String Pool</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-详解new-String-“aaa”"><span class="nav-number">1.4.6.</span> <span class="nav-text">6. 详解new String(“aaa”)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-StringBuilder-StringBuffer类"><span class="nav-number">1.4.7.</span> <span class="nav-text">7. StringBuilder/StringBuffer类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-可变性"><span class="nav-number">1.4.7.1.</span> <span class="nav-text">(1) 可变性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-线程安全性"><span class="nav-number">1.4.7.2.</span> <span class="nav-text">(2) 线程安全性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-使用原则"><span class="nav-number">1.4.7.3.</span> <span class="nav-text">(3) 使用原则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Arrays类"><span class="nav-number">1.5.</span> <span class="nav-text">Arrays类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-1"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Arrays类的API"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. Arrays类的API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-源码解析"><span class="nav-number">1.5.3.</span> <span class="nav-text">3. 源码解析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-Arrays-sort"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">(1) Arrays.sort()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-Arrays-binarySearch"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">(2) Arrays.binarySearch()</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-System-arrayCopy"><span class="nav-number">1.5.4.</span> <span class="nav-text">4. System.arrayCopy()</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他类"><span class="nav-number">1.6.</span> <span class="nav-text">其他类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-BigDecimal-BigInteger类"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. BigDecimal/BigInteger类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Random-类"><span class="nav-number">1.6.2.</span> <span class="nav-text">2. Random 类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-概述-2"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">(1) 概述</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-常用方法"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">(2) 常用方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.7.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
