<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] 内部类将一个类的定义放在另一个类的定义内部，这就是内部类。内部类可以分为四类：普通内部类、静态内部类、匿名内部类、局部内部类。  为什么要使用内部类？  使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。—《Think in java》 对于多重继承，接口只是解决了部分问题，而内部类使得多重继承">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;A Java&#x2F;A-4 内部类">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;A-4%20%E5%86%85%E9%83%A8%E7%B1%BB&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] 内部类将一个类的定义放在另一个类的定义内部，这就是内部类。内部类可以分为四类：普通内部类、静态内部类、匿名内部类、局部内部类。  为什么要使用内部类？  使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。—《Think in java》 对于多重继承，接口只是解决了部分问题，而内部类使得多重继承">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/A Java/A-4 内部类/"/>





  <title>ShiftJava/A Java/A-4 内部类 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/A%20Java/A-4%20%E5%86%85%E9%83%A8%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/A Java/A-4 内部类</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>将一个类的定义放在另一个类的定义内部，这就是内部类。内部类可以分为四类：<strong>普通内部类、静态内部类、匿名内部类、局部内部类</strong>。</p>
<blockquote>
<p>为什么要使用内部类？</p>
</blockquote>
<p>使用内部类最吸引人的原因是：每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。—《Think in java》</p>
<p>对于多重继承，接口只是解决了部分问题，而内部类使得<strong>多重继承</strong>的解决方案变得更加<strong>完整</strong>。它能够非常好的解决<strong>多重继承</strong>的问题。</p>
<h4 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h4><ul>
<li><p>只有内部类可以是 <strong>private 私有</strong>类，或者 <strong>static</strong> 静态类。</p>
</li>
<li><p>内部类是一种<strong>编译器</strong>现象，与虚拟机无关。<strong>编译器</strong>将会把内部类翻译成用 <strong>$</strong> (美元符号）分隔外部类名与内部类名的<strong>常规类文件</strong>， 而虚拟机则对此一无所知。每个内部类都会被编译为一个<strong>独立</strong>的类。</p>
</li>
</ul>
<h4 id="普通内部类"><a href="#普通内部类" class="headerlink" title="普通内部类"></a>普通内部类</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>在一个类里面作为类的一个直接定义就可以了，例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NormalInnerClass</span></span>&#123;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里 NormalInnerClass 类为 InnerClassTest 类的<strong>普通内部类</strong>，在这种定义方式下，<strong>普通内部类对象依赖外部类对象</strong>而存在，即在创建一个普通内部类对象时<strong>首先需要创建其外部类对象</strong>。可以把这个内部类理解为外部类的一个<strong>==实例属性==</strong>。</p>
<p>在创建上面代码中的 InnerClassA 对象时要先创建 InnerClassTest 对象，例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> outField1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> outField2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> outField3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> outField4 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在外部类对象内部，直接通过 new InnerClass(); 创建内部类对象</span></span><br><span class="line">        InnerClassA innerObj = <span class="keyword">new</span> InnerClassA();</span><br><span class="line">        System.out.println(<span class="string">"创建 "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field1 字段的值为: "</span> + innerObj.field1);</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field2 字段的值为: "</span> + innerObj.field2);</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field3 字段的值为: "</span> + innerObj.field3);</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field4 字段的值为: "</span> + innerObj.field4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassA</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> field1 = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> field2 = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> field3 = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> field4 = <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// static int field5 = 5; // 编译错误！普通内部类中不能定义 static 属性</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClassA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"创建 "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line">            System.out.println(<span class="string">"其外部类的 outField1 字段的值为: "</span> + outField1);</span><br><span class="line">            System.out.println(<span class="string">"其外部类的 outField2 字段的值为: "</span> + outField2);</span><br><span class="line">            System.out.println(<span class="string">"其外部类的 outField3 字段的值为: "</span> + outField3);</span><br><span class="line">            System.out.println(<span class="string">"其外部类的 outField4 字段的值为: "</span> + outField4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InnerClassTest outerObj = <span class="keyword">new</span> InnerClassTest();</span><br><span class="line">        <span class="comment">// 不在外部类内部，使用：外部类对象.new 内部类构造器(); 的方式创建内部类对象</span></span><br><span class="line">        <span class="comment">// InnerClassA innerObj = outerObj.new InnerClassA();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">创建 InnerClassA 对象</span><br><span class="line">其外部类的 outField1 字段的值为: <span class="number">1</span></span><br><span class="line">其外部类的 outField2 字段的值为: <span class="number">2</span></span><br><span class="line">其外部类的 outField3 字段的值为: <span class="number">3</span></span><br><span class="line">其外部类的 outField4 字段的值为: <span class="number">4</span></span><br><span class="line">创建 InnerClassTest 对象</span><br><span class="line">其内部类的 field1 字段的值为: <span class="number">5</span></span><br><span class="line">其内部类的 field2 字段的值为: <span class="number">6</span></span><br><span class="line">其内部类的 field3 字段的值为: <span class="number">7</span></span><br><span class="line">其内部类的 field4 字段的值为: <span class="number">8</span></span><br></pre></td></tr></table></figure>

<h5 id="2-内外访问"><a href="#2-内外访问" class="headerlink" title="2. 内外访问"></a>2. 内外访问</h5><p>普通内部类就像外部类声明的一个普通<strong>属性字段</strong>一样，因此其的对象时<strong>依附</strong>于外部类对象而存在的。使用一个字段肯定得<strong>先有对象</strong>，使用普通内部类也要先创建外部类对象，道理类似。</p>
<p>可以注意到，<strong>内部类对象</strong>可以访问<strong>外部类对象中所有访问权限的字段</strong>，外部类对象也可以通过<strong>内部类的对象引用</strong>来访问内部类中定义的<strong>所有</strong>访问权限的字段（还是当成普通属性字段就行了）。</p>
<p>成员内部类中不能存在 <code>static</code> 方法, 但是可以存在 <code>static</code> 域, 前提是需要使用 <code>final</code> 关键字进行修饰。</p>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>静态内部类即含有 <strong>static</strong> 修饰的内部类。<strong>只有内部类</strong>可以声明为 <strong>static</strong>。静态内部类可以有<strong>静态域和方法</strong>。</p>
<p>一个类的<strong>静态成员</strong>独立于这个类的<strong>任何一个对象</strong>存在，只要在具有访问权限的地方，就可以通过 <strong>类名.静态成员名</strong> 的形式来访问这个静态成员，类似，<strong>静态内部类</strong>也可以理解为一个外部类的<strong>==静态成员==</strong>，<strong>创建一个类的静态内部类对象不需要依赖其外部类对象</strong>。</p>
<p><strong>创建静态内部类的实例的方式：</strong></p>
<ul>
<li>就在<strong>外部类</strong>中创建：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StaticClass staticClass = <span class="keyword">new</span> StaticClass();</span><br></pre></td></tr></table></figure>

<ul>
<li>在<strong>其他类</strong>中创建，类似于通过<strong>类名引用静态字段</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 name = <span class="keyword">new</span> 外部类名.内部类名();</span><br><span class="line">InnerClassTest2.StaticClass staticClass = <span class="keyword">new</span> InnerClassTest2.StaticClass();</span><br></pre></td></tr></table></figure>

<p>静态内部类就像外部类的<strong>一个静态成员</strong>一样，创建其对象<strong>无需依赖外部类对象</strong>（访问一个类的静态成员也无需依赖这个类的对象，因为它是独立于所有类的对象的）。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类实例字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> outerField = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> outerStaticField = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClassTest2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建 "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line">        <span class="comment">// 创建静态内部类对象</span></span><br><span class="line">        StaticClass innerObj = <span class="keyword">new</span> StaticClass();</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field1 字段的值为: "</span> + innerObj.field1);</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field2 字段的值为: "</span> + innerObj.field2);</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field3 字段的值为: "</span> + innerObj.field3);</span><br><span class="line">        System.out.println(<span class="string">"其内部类的 field4 字段的值为: "</span> + innerObj.field4);</span><br><span class="line">        System.out.println(<span class="string">"内部类静态字段值："</span> + StaticClass.field5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticClass</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 静态内部类中可以定义各种属性</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> field1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">int</span> field2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> field3 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> field4 = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 静态内部类中可以定义static属性</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> field5 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">StaticClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println("创建 " + StaticClass.class.getSimpleName() + " 对象");</span><br><span class="line">            <span class="comment">// 可以引用外部类的静态字段</span></span><br><span class="line">            System.out.println(<span class="string">"外部类静态字段值："</span> + InnerClassTest2.outerStaticField);</span><br><span class="line">            <span class="comment">// 不能引用外部类的实例字段</span></span><br><span class="line">            <span class="comment">// System.out.println("其外部类的 field1 字段的值为: " + outerField); // 编译错误！！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 无需依赖外部类对象，直接创建内部类对象</span></span><br><span class="line">        <span class="comment">// InnerClassTest.StaticClass staticClassObj = new InnerClassTest.StaticClass();</span></span><br><span class="line">        InnerClassTest2 outerObj = <span class="keyword">new</span> InnerClassTest2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建 InnerClassTest2 对象</span><br><span class="line">创建 StaticClass 对象</span><br><span class="line">外部类静态字段值: <span class="number">3</span></span><br><span class="line">其内部类的 field1 字段的值为: <span class="number">1</span></span><br><span class="line">其内部类的 field2 字段的值为: <span class="number">2</span></span><br><span class="line">其内部类的 field3 字段的值为: <span class="number">3</span></span><br><span class="line">其内部类的 field4 字段的值为: <span class="number">4</span></span><br><span class="line">内部类静态字段值：<span class="number">5</span></span><br></pre></td></tr></table></figure>

<h5 id="2-内外访问-1"><a href="#2-内外访问-1" class="headerlink" title="2. 内外访问"></a>2. 内外访问</h5><p>可以把<strong>静态内部类当做外部类的一个静态成员属性</strong>，下面就好理解了。</p>
<p>静态内部类中也<strong>无法访问外部类的非静态成员</strong>，因为外部类的非静态成员是属于<strong>每一个外部类对象的</strong>，而本身静态内部类就是<strong>独立</strong>外部类对象存在的，所以静态内部类不能访问外部类的非静态成员。但是静态内部类<strong>可以访问</strong>外部类的<strong>静态属性</strong>。<strong>静态属性可以互相访问</strong>。</p>
<p>而<strong>外部类</strong>依然可以访问<strong>静态</strong>内部类对象的<strong>所有访问权限</strong>的成员，这一点和普通内部类无异。</p>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><h5 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>匿名内部类有多种形式，其中最常见的一种形式莫过于在<strong>方法参数中新建一个接口对象 / 类对象</strong>。多用于实现<strong>回调</strong>接口。匿名内部类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个匿名内部类定义在方法中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">int</span> interval, <span class="keyword">boolean</span> beep)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个实现 ActionListener 接口的类的新对象，需要实现的方法 actionPerformed 定义在括号内</span></span><br><span class="line">    ActionListener listener = <span class="keyword">new</span> ActionListener()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"At the tone, the time is "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Timer t = <span class="keyword">new</span> Timer(interval, listener);</span><br><span class="line">    t.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clickListener.onClick(<span class="keyword">new</span> Object() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"obj1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>直接 new 一个<strong>接口</strong>，并实现这个接口<strong>声明的方法</strong>，在这个过程其实会创建一个<strong>匿名内部类实现这个接口</strong>，并重写接口方法。</p>
<p>如果<strong>构造参数的闭小括号后面跟一个开大括号</strong>， 正在定义的就是匿名内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person count = <span class="keyword">new</span> Person(<span class="string">"Dracula"</span>) &#123;...&#125;</span><br><span class="line"><span class="comment">// an object of an inner class extending Person</span></span><br></pre></td></tr></table></figure>

<p>习惯的做法是用匿名内部类实现事件监听器和其他回调。 如今最好还是使用 <strong>lambda</strong> 表达式。</p>
<h5 id="2-内外访问-2"><a href="#2-内外访问-2" class="headerlink" title="2. 内外访问"></a>2. 内外访问</h5><p><strong>在匿名内部类中可以使用外部类的属性</strong>，但是外部类却<strong>不能</strong>使用匿名内部类中定义的属性，因为是<strong>匿名</strong>内部类，因此在外部类中无法获取这个类的类名，也就<strong>无法得到属性信息</strong>。</p>
<h5 id="3-高级技巧"><a href="#3-高级技巧" class="headerlink" title="3. 高级技巧"></a>3. 高级技巧</h5><p>高级技巧：使用匿名类实现==双括号<strong>初始化</strong>==（源自 Java Core）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处两个&#123;&#125;。第一个&#123;&#125;表明是一个匿名内部类。第二个&#123;&#125;表明为类里面的初始化代码块，会在构造对象时调用。</span></span><br><span class="line">invite(<span class="keyword">new</span> ArrayList&lt;String&gt;()&#123;&#123; add(<span class="string">"Harry"</span>); add(<span class="string">"Tony"</span>); &#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>调用 getClass 方法时调用的是 this.getClass(), 而<strong>静态方法</strong>没有 this。所以应该使用以下表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Object())&#123;&#125;.getClass().getEnclosingClass()      <span class="comment">// 获取静态方法的Class</span></span><br></pre></td></tr></table></figure>

<p>在这里，newObject(){} 会建立 Object 的一个匿名子类的一个匿名对象，getEnclosingClass 则得到其外围类， 也就是包含这个静态方法的类。</p>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类使用的<strong>比较少</strong>，其声明在一个方法体或一段代码块的内部，而且不在定义类的定义域之内便无法使用，其提供的功能使用匿名内部类都可以实现，而本身匿名内部类可以写得比它更简洁，因此局部内部类用的比较少。</p>
<p>局部内部类<strong>不能用 public 或 private 修饰符</strong>进行声明。<strong>不能用访问修饰符</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> field1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> field2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> field3 = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> field4 = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClassTest4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"创建 "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" 对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在方法内部创建局部内部类</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">localInnerClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 局部内部类 A，只能在当前方法中使用</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">            <span class="comment">// static int field = 1; // 编译错误！局部内部类中不能定义 static 字段</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println("创建 " + A.class.getSimpleName() + " 对象");</span><br><span class="line">                System.out.println(<span class="string">"其外部类的 field1 字段的值为: "</span> + field1);</span><br><span class="line">                System.out.println(<span class="string">"其外部类的 field2 字段的值为: "</span> + field2);</span><br><span class="line">                System.out.println(<span class="string">"其外部类的 field3 字段的值为: "</span> + field3);</span><br><span class="line">                System.out.println(<span class="string">"其外部类的 field4 字段的值为: "</span> + field4);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 局部内部类 B，只能在当前代码块中使用</span></span><br><span class="line">            <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println("创建 " + B.class.getSimpleName() + " 对象");</span><br><span class="line">                    System.out.println(<span class="string">"其外部类的 field1 字段的值为: "</span> + field1);</span><br><span class="line">                    System.out.println(<span class="string">"其外部类的 field2 字段的值为: "</span> + field2);</span><br><span class="line">                    System.out.println(<span class="string">"其外部类的 field3 字段的值为: "</span> + field3);</span><br><span class="line">                    System.out.println(<span class="string">"其外部类的 field4 字段的值为: "</span> + field4);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            B b = <span class="keyword">new</span> B();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// B b1 = new B(); // 编译错误！不在类 B 的定义域内，找不到类 B，</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InnerClassTest4 outObj = <span class="keyword">new</span> InnerClassTest4();</span><br><span class="line">        outObj.localInnerClassTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">创建 InnerClassTest4 对象</span><br><span class="line">创建 A 对象</span><br><span class="line">其外部类的 field1 字段的值为: <span class="number">1</span></span><br><span class="line">其外部类的 field2 字段的值为: <span class="number">2</span></span><br><span class="line">其外部类的 field3 字段的值为: <span class="number">3</span></span><br><span class="line">其外部类的 field4 字段的值为: <span class="number">4</span></span><br><span class="line">创建 B 对象</span><br><span class="line">其外部类的 field1 字段的值为: <span class="number">1</span></span><br><span class="line">其外部类的 field2 字段的值为: <span class="number">2</span></span><br><span class="line">其外部类的 field3 字段的值为: <span class="number">3</span></span><br><span class="line">其外部类的 field4 字段的值为: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>在局部内部类里面<strong>可以访问外部类对象的所有访问权限（包括 private）的字段</strong>，而外部类却<strong>不能访问局部内部类</strong>中定义的字段，因为局部内部类的定义只在其特定的<strong>方法体或代码块</strong>中有效，一旦出了这个<strong>定义域</strong>，那么其定义就<strong>失效</strong>了。外部类不能获取局部内部类的对象，因而无法访问局部内部类的字段。</p>
<p>局部内部类还有一个优点。它们<strong>不仅能够访问包含它们的外部类</strong>， 还<strong>可以访问==局部变量==</strong>。不过那些局部变量<strong>必须</strong>事实上为 ==<strong>final</strong>==。如果需要变值的话一个替代方案可以是使用长度为 1 的数组。数组引用为 final 但是其值可以变化。即局部内部类只能访问<strong>方法</strong>中声明的 <strong>final 类型</strong>的变量。</p>
<h4 id="内部类原理解析"><a href="#内部类原理解析" class="headerlink" title="内部类原理解析"></a>内部类原理解析</h4><p>前面分析已知<strong>普通内部类</strong>可以<strong>访问外部类所有访问权限修饰的字段</strong>（<strong>包括 private</strong> 的属性），同时外部类也可以访问普通内部类的<strong>所有访问</strong>权限修饰的字段。但是根据访问控制 <strong>private</strong> 权限的字段只在被<strong>当前类可见</strong>啊。由于外部类可以知道内部类的类型信息，所以外部类可以访问内部类的各种属性，但是普通内部类是<strong>如何</strong>能调用外部类的私有属性？</p>
<p><strong>其实==内部类持有外部类的一个引用==，在==内部类构造函数==中会将外部类的引用传递进来。</strong></p>
<p>为解决这个疑问，编译一波康康。以<strong>普通内部类</strong>距举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> field1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> field2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClassTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        InnerClassA inner = <span class="keyword">new</span> InnerClassA();</span><br><span class="line">        <span class="keyword">int</span> v = inner.x2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassA</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x1 = field1;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> x2 = field2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们用 <strong>javac</strong> 命令（javac InnerClassTest.java）<strong>编译</strong>这个 Java 文件，会得到<strong>两个 .classs 文件</strong>：<br><strong>InnerClassTest</strong>.class 和 <strong>InnerClassTest$InnerClassA</strong>.class。内部类编译之后是各自<strong>独立</strong>的 class 文件。</p>
<p>我们再用 <strong>javap -c</strong> 命令（javap -c InnerClassTest 和 javap -c InnerClassTest$InnerClassA）分别<strong>反编译</strong>这两个 .class 文件。可以得到 <strong>InnerClassTest.class</strong> 的字节码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class javase.innerclass.InnerClassTest &#123;</span><br><span class="line">    // 外部类的字段</span><br><span class="line">    int field1;</span><br><span class="line"></span><br><span class="line">    public javase.innerclass.InnerClassTest();</span><br><span class="line">    Code:</span><br><span class="line">    <span class="number">0</span>: aload_0</span><br><span class="line">    <span class="number">1</span>: invokespecial <span class="comment">#1                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">    <span class="number">4</span>: aload_0</span><br><span class="line">    <span class="number">5</span>: iconst_1</span><br><span class="line">    <span class="number">6</span>: putfield      <span class="comment">#2                  // Field field1:I</span></span><br><span class="line">    <span class="number">9</span>: aload_0</span><br><span class="line">    <span class="number">10</span>: iconst_2</span><br><span class="line">    <span class="number">11</span>: putfield      <span class="comment">#3                  // Field field2:I</span></span><br><span class="line">    <span class="number">14</span>: new           <span class="comment">#4                  // class javase/innerclass/InnerClassTest$InnerClassA</span></span><br><span class="line">    <span class="number">17</span>: dup</span><br><span class="line">    <span class="number">18</span>: aload_0</span><br><span class="line">    <span class="number">19</span>: invokespecial <span class="comment">#5                  // Method javase/innerclass/InnerClassTest$InnerClassA."&lt;init&gt;":(Ljavase/innerclass/InnerClassTest;)V</span></span><br><span class="line">    <span class="number">22</span>: astore_1</span><br><span class="line">    <span class="number">23</span>: aload_1</span><br><span class="line">    <span class="number">24</span>: getfield      <span class="comment">#6                  // Field javase/innerclass/InnerClassTest$InnerClassA.x2:I</span></span><br><span class="line">    <span class="number">27</span>: istore_2</span><br><span class="line">    <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>InnerClassTest$InnerClassA</strong> 类的字节码如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class javase.innerclass.InnerClassTest$InnerClassA &#123;</span><br><span class="line">    // 内部类的字段 </span><br><span class="line">    int x1;</span><br><span class="line">	// 注意：这是对外部类对象的一个引用，这个引用是通过构造方法传入的</span><br><span class="line">    final javase.innerclass.InnerClassTest this$<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    public javase.innerclass.InnerClassTest$InnerClassA(javase.innerclass.InnerClassTest);</span><br><span class="line">    Code:</span><br><span class="line">    <span class="number">0</span>: aload_0</span><br><span class="line">    <span class="number">1</span>: aload_1</span><br><span class="line">    <span class="number">2</span>: putfield      <span class="comment">#1                  // Field this$0:Ljavase/innerclass/InnerClassTest;</span></span><br><span class="line">    <span class="number">5</span>: aload_0</span><br><span class="line">    <span class="number">6</span>: invokespecial <span class="comment">#2                  // Method java/lang/Object."&lt;init&gt;":()V</span></span><br><span class="line">    <span class="number">9</span>: aload_0</span><br><span class="line">    <span class="number">10</span>: aload_0</span><br><span class="line">    <span class="number">11</span>: getfield      <span class="comment">#1                  // Field this$0:Ljavase/innerclass/InnerClassTest;</span></span><br><span class="line">    <span class="number">14</span>: getfield      <span class="comment">#3                  // Field javase/innerclass/InnerClassTest.field1:I</span></span><br><span class="line">    <span class="number">17</span>: putfield      <span class="comment">#4                  // Field x1:I</span></span><br><span class="line">    <span class="number">20</span>: aload_0</span><br><span class="line">    <span class="number">21</span>: aload_0</span><br><span class="line">    <span class="number">22</span>: getfield      <span class="comment">#1                  // Field this$0:Ljavase/innerclass/InnerClassTest;</span></span><br><span class="line">    <span class="number">25</span>: getfield      <span class="comment">#5                  // Field javase/innerclass/InnerClassTest.field2:I</span></span><br><span class="line">    <span class="number">28</span>: putfield      <span class="comment">#6                  // Field x2:I</span></span><br><span class="line">    <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到上面有一个字段为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> javase.innerclass.InnerClassTest <span class="keyword">this</span>$<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>可知<strong>编译器</strong>给内部类提供了一个接受 InnerClassTest 类型对象（即外部类对象）的<strong>构造方法</strong>，内部类本身还定义了一个名为 <strong>this$0</strong> 的 InnerClassTest 类型的<strong>引用</strong>，这个引用在构造方法中指向了参数所对应的外部类对象。所以内部类是持有外部类对象的<strong>引用</strong>的，因此内部类可以使用外部类的 private 属性。</p>
<p>上面只是对<strong>普通内部类</strong>进行了分析，但其实<strong>匿名内部类和局部内部类的原理和普通内部类是类似的</strong>，只是在访问上有些不同：外部类<strong>无法</strong>访问匿名内部类和局部内部类对象的字段，因为外部类<strong>根本就不知道</strong>匿名内部类或局部内部类的<strong>类型信息</strong>（匿名内部类的类名被隐匿，局部内部类只能在定义域内使用）。但是匿名内部类和局部内部类却可以访问外部类的私有成员，<strong>原理也是</strong>通过<strong>持有外部类对象引用</strong>可以得到对应外部类对象的私有成员的值。</p>
<p>而对于<strong>静态内部类</strong>来说，因为其实<strong>独立于</strong>外部类对象而存在，因此编译器<strong>不会</strong>为静态内部类对象提供外部类对象的<strong>引用</strong>，因为静态内部类对象的创建根本不需要外部类对象支持。但是<strong>外部类对象</strong>还是可以访问静态内部类对象的<strong>私有成员</strong>，<strong>因为外部类可以知道静态内部类的类型信息</strong>，即可以得到静态内部类的对象，那么就可以通过静态内部类来获得对应的私有成员值。</p>
<p><strong>==总结：==</strong></p>
<p><strong>普通内部类</strong>可以与外部类<strong>互相访问其属性</strong>，原理就是外部类知道内部类的<strong>类型信息</strong>，所以外部类可以访问内部类的类型信息；反过来内部类是通过<strong>编译</strong>后<strong>持有外部类对象的引用</strong>才能访问外部类的<strong>非静态</strong>字段。</p>
<p>类似的，<strong>匿名内部类和局部内部类</strong>都持有外部类对象的引用，所以可以访问外部类非静态字段，然而外部类是<strong>不知道</strong>匿名内部类和局部内部类的<strong>类型信息</strong>的，所以外部类不能访问其字段。</p>
<p>总之，<strong>非静态内部类（普通、匿名、局部）中都会持有对外部类的对象的引用，从而可以访问外部类对象。反过来就要看外部类是否知道内部类的类型信息了。</strong></p>
<p>对于<strong>静态内部类</strong>，静态是不依赖于任何实例对象的，所以静态内部类<strong>不会持有外部类的实例对象</strong>，所以<strong>无法访问</strong>外部类的非静态字段，因此静态内部类只能访问外部类的静态字段，而外部类是可以得到静态内部类的类型信息，所以外部类可以访问静态内部类的各种属性。<strong>静态内部类对象不依赖其外部类对象存在，而其余的内部类对象必须依赖其外部类对象而存在</strong>。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>如果内部类访问了 <strong>private 私有数</strong>据域， 就有可能通过<strong>附加在外围类所在包</strong>中的其他类<strong>访问</strong>它们，这就存在一定的<strong>安全问题</strong>。但需要将攻击代码与被攻击类放在<strong>同一个包</strong>中。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://blog.csdn.net/hacker_zhidian/article/details/82193100" target="_blank" rel="noopener">https://blog.csdn.net/hacker_zhidian/article/details/82193100</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/A-5%20%E6%9E%9A%E4%B8%BE%E7%B1%BB/" rel="next" title="ShiftJava/A Java/A-5 枚举类">
                <i class="fa fa-chevron-left"></i> ShiftJava/A Java/A-5 枚举类
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/A-2%20%E7%B1%BB%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%BB%A7%E6%89%BF/" rel="prev" title="ShiftJava/A Java/A-2 类基础与继承">
                ShiftJava/A Java/A-2 类基础与继承 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类"><span class="nav-number">1.</span> <span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#杂记"><span class="nav-number">1.1.</span> <span class="nav-text">杂记</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#普通内部类"><span class="nav-number">1.2.</span> <span class="nav-text">普通内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-内外访问"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 内外访问</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态内部类"><span class="nav-number">1.3.</span> <span class="nav-text">静态内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-内外访问-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 内外访问</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匿名内部类"><span class="nav-number">1.4.</span> <span class="nav-text">匿名内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-2"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-内外访问-2"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 内外访问</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-高级技巧"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 高级技巧</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#局部内部类"><span class="nav-number">1.5.</span> <span class="nav-text">局部内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类原理解析"><span class="nav-number">1.6.</span> <span class="nav-text">内部类原理解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他"><span class="nav-number">1.7.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.8.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
