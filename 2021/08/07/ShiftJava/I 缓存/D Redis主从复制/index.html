<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] Redis主从复制主从复制基础1. 概述复制能解决单点故障问题，是实现分布式系统高可用的基础。复制机制下数据集可以有多个副本，这些副本可以用于读写分离、故障转移、实时备份等场景。   主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 主节点(master)，后者称为 从节点(slave)。且数据的复制是 单向 的，只能由主节点到从节点。Redi">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;I 缓存&#x2F;D Redis主从复制">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] Redis主从复制主从复制基础1. 概述复制能解决单点故障问题，是实现分布式系统高可用的基础。复制机制下数据集可以有多个副本，这些副本可以用于读写分离、故障转移、实时备份等场景。   主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 主节点(master)，后者称为 从节点(slave)。且数据的复制是 单向 的，只能由主节点到从节点。Redi">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&#x2F;assets&#x2F;image-20200527210706894.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&#x2F;assets&#x2F;image-20200426102846543.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&#x2F;assets&#x2F;image-20200426102938446.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&#x2F;assets&#x2F;image-20200426103208385.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&#x2F;assets&#x2F;image-20200527210920684.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&#x2F;assets&#x2F;image-20200426110935809.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&#x2F;assets&#x2F;image-20200426111023515.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&#x2F;assets&#x2F;image-20200426105809787.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&#x2F;assets&#x2F;image-20200426125508512.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;I%20%E7%BC%93%E5%AD%98&#x2F;D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6&#x2F;assets&#x2F;image-20200527210706894.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/I 缓存/D Redis主从复制/"/>





  <title>ShiftJava/I 缓存/D Redis主从复制 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/I%20%E7%BC%93%E5%AD%98/D%20Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/I 缓存/D Redis主从复制</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:17+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h3><h4 id="主从复制基础"><a href="#主从复制基础" class="headerlink" title="主从复制基础"></a>主从复制基础</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>复制能解决<strong>单点故障</strong>问题，是实现分布式系统<strong>高可用</strong>的基础。复制机制下数据集可以有多个副本，这些副本可以用于<strong>读写分离、故障转移、实时备份</strong>等场景。</p>
<img src="assets/image-20200527210706894.png" alt="image-20200527210706894" style="zoom: 57%;" />

<p><strong>主从复制</strong>，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为 <strong>主节点(master)</strong>，后者称为 <strong>从节点(slave)</strong>。且数据的复制是 <strong>单向</strong> 的，只能由<strong>主节点到从节点</strong>。Redis 主从复制支持<strong>主从同步</strong>和<strong>从从同步</strong>两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。</p>
<h5 id="2-主从复制的作用"><a href="#2-主从复制的作用" class="headerlink" title="2. 主从复制的作用"></a>2. 主从复制的作用</h5><p><strong>数据冗余：</strong> 主从复制实现了数据的<strong>热备份</strong>，是持久化之外的一种数据冗余方式。</p>
<p><strong>故障恢复：</strong> 当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复 (实际上是一种服务的冗余)。</p>
<p><strong>负载均衡：</strong> 在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写 Redis 数据时应用连接主节点，读 Redis 数据时应用连接从节点），分担服务器负载。尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高 Redis 服务器的并发量。</p>
<p><strong>高可用基石：</strong> 除了上述作用以外，主从复制还是哨兵和集群能够实施的<strong>基础</strong>，因此说主从复制是 Redis 高可用的基础。</p>
<h5 id="3-复制建立与断开"><a href="#3-复制建立与断开" class="headerlink" title="3. 复制建立与断开"></a>3. 复制建立与断开</h5><p>参与复制的 Redis 实例分为<strong>主节点</strong>（master）和<strong>从节点</strong>（slave）。复制的数据流是<strong>单向</strong>的，只能由主节点到从节点。默认情况下，Redis 实例都是主节点。</p>
<h6 id="1-建立复制"><a href="#1-建立复制" class="headerlink" title="(1) 建立复制"></a>(1) 建立复制</h6><p>配置方式：</p>
<ul>
<li>在<strong>配置文件</strong>中加入 <strong>slaveof {masterHost} {masterPort}</strong> 随 Redis 启动生效。</li>
<li>在 Redis-server 启动命令后加入 –slaveof {masterHost} {masterPort} 生效。</li>
<li>直接使用<strong>命令</strong>：<strong>slaveof {masterHost} {masterPort}</strong> 生效。</li>
</ul>
<p><strong>slaveof 配置</strong>都是在<strong>从节点发起</strong>。主从节点复制关系建立成功之后可以用 <strong>info replication</strong> 命令查看<strong>复制相关状态</strong>。</p>
<p>复制可以使用 <strong>sync 和 fsync</strong>，sync 只支持全量复制，所以主要用<strong>后者</strong>。</p>
<h6 id="2-断开复制"><a href="#2-断开复制" class="headerlink" title="(2) 断开复制"></a>(2) 断开复制</h6><p>在从节点执行 <strong>slaveof no one</strong> 断开主从复制关系。断开之后从节点变成主节点，但是原来同步的数据<strong>不会丢失</strong>。<strong>但是切换主节点</strong>：如果从节点断开主从复制进而又把<strong>另一个</strong>节点当做主节点，则切换后从节点会<strong>清空</strong>之前同步的数据。</p>
<h6 id="3-只读"><a href="#3-只读" class="headerlink" title="(3) 只读"></a>(3) 只读</h6><p>默认情况下，从节点使用 <strong>slave-read-only=yes</strong> 配置为<strong>只读模式</strong>。生产环境这样做！因为对从节点的修改主节点是不知道的。</p>
<h5 id="4-复制拓扑关系"><a href="#4-复制拓扑关系" class="headerlink" title="4. 复制拓扑关系"></a>4. 复制拓扑关系</h5><p>Redis 复制的拓扑关系可以支持<strong>单层或多层</strong>复制关系。根据复杂性可以分为<strong>一主一从、一主多从、树状主从结构</strong>。</p>
<h6 id="1-一主一从结构"><a href="#1-一主一从结构" class="headerlink" title="(1) 一主一从结构"></a>(1) 一主一从结构</h6><p>最简单的拓扑结构，用于主节点出现宕机时从节点提供<strong>故障转移</strong>支持。</p>
<img src="assets/image-20200426102846543.png" alt="image-20200426102846543" style="zoom:67%;" />

<p>当应用写命令并发量较高时且需要持久化时，可以只在从节点上开始 AOF，这样既保证数据安全又避免了持久化对主节点的影响。</p>
<h6 id="2-一主多从结构"><a href="#2-一主多从结构" class="headerlink" title="(2) 一主多从结构"></a>(2) 一主多从结构</h6><p>应用端可以利用多个从节点实现<strong>读写分离</strong>，对于<strong>读占比较大</strong>的场景，或者某些<strong>耗时</strong>的操作，可以把读命令发送到<strong>从节点</strong>来分担主节点的压力。</p>
<p>对于<strong>写并发量较大</strong>的场景，<strong>多个从节点</strong>会导致主节点写命令的多次发送到从节点而消耗网络带宽，<strong>增大了主节点的负担</strong>。</p>
<img src="assets/image-20200426102938446.png" alt="image-20200426102938446" style="zoom:67%;" />

<h6 id="3-树状主从结构"><a href="#3-树状主从结构" class="headerlink" title="(3) 树状主从结构"></a>(3) 树状主从结构</h6><p>引入<strong>复制中间层</strong>，可以降低主节点发送给从节点的数据量，<strong>减小主节点负担</strong>。</p>
<img src="assets/image-20200426103208385.png" alt="image-20200426103208385" style="zoom:67%;" />

<p>上图中引入中间层 slave1，减少主节点传输给从节点的消耗，而 slave1 可以继续往下复制数据给下一层的节点。</p>
<h4 id="复制原理"><a href="#复制原理" class="headerlink" title="复制原理"></a>复制原理</h4><h5 id="1-复制过程"><a href="#1-复制过程" class="headerlink" title="1. 复制过程"></a>1. 复制过程</h5><p>复制大致有六个过程：</p>
<p>(1) <strong>保存主节点信息</strong>。</p>
<p>(2) <strong>连接主节点</strong>。从节点内部通过每秒运行的<strong>定时任务</strong>维护复制相关逻辑，当定时任务<strong>发现存在新的主节点</strong>的时候，会尝试与该节点<strong>建立连接</strong>。连接成功会产生日志，连接失败则会无限<strong>重连</strong>。</p>
<p>(3) <strong>发送 ping 命令</strong>。从节点发送 ping 指令给主节点进行<strong>首次通信</strong>，用于检测网络情况和主节点是否可以处理请求。如果返回 pong 失败，则主节点会<strong>断开连接</strong>下一次定时任务继续<strong>重连</strong>。</p>
<p>(4) <strong>权限认证</strong>。这发生在主节点设置了 requirepass 参数时。</p>
<p>(5) <strong>数据同步</strong>。主从连接首次通信正常后，主节点会把持有的数据<strong>全部发送</strong>给从节点，这是<strong>非常耗时</strong>的操作。</p>
<p>(6) <strong>命令持续复制</strong>。接下来主节点会<strong>持续</strong>把命令发送给从节点，<strong>保证主从数据一致性</strong>。</p>
<p><img src="assets/image-20200527210920684.png" alt="image-20200527210920684"></p>
<p>复制过程中最核心的便是：<strong>数据同步</strong>，下面详述。</p>
<h5 id="2-psync"><a href="#2-psync" class="headerlink" title="2. psync"></a>2. psync</h5><p>sync 与 psync 命令都能用于实现数据同步，但是 sync 指令只能实现全量复制，用的较少。<strong>psync 运行需要的核心组件如下</strong>：</p>
<ul>
<li>主从节点各自<strong>复制偏移量</strong>。</li>
<li>主节点<strong>复制积压缓冲区</strong>。</li>
<li>主节点<strong>运行 id</strong>。</li>
</ul>
<h6 id="1-复制偏移量"><a href="#1-复制偏移量" class="headerlink" title="(1) 复制偏移量"></a>(1) 复制偏移量</h6><p>参与复制的主从节点<strong>都会</strong>维护各自的<strong>复制偏移量</strong>。通过对比主从节点的复制偏移量，可以判断主从节点<strong>数据是否一致</strong>。从节点会每秒上报自己的复制偏移量给主节点。</p>
<p>复制偏移量的统计信息在 <strong>info replication</strong> 中的 <strong>master_repl_offset</strong> 指标中。</p>
<img src="assets/image-20200426110935809.png" alt="image-20200426110935809" style="zoom:67%;" />

<h6 id="2-复制积压缓冲区"><a href="#2-复制积压缓冲区" class="headerlink" title="(2) 复制积压缓冲区"></a>(2) 复制积压缓冲区</h6><p><strong>复制积压缓冲区</strong>是保存在<strong>主节点</strong>上的一个<strong>固定长度的队列</strong>，默认 <strong>1MB</strong>，当主节点在于从节点连接后创建。这时候主节点写命令的时候，<strong>不但把命令发给从节点，还会写入到复制积压缓冲区。</strong></p>
<img src="assets/image-20200426111023515.png" alt="image-20200426111023515" style="zoom:67%;" />

<p>复制积压缓冲区是一个<strong>定长的先进先出队列</strong>（FIFO），所以能够实现<strong>保存最近已复制数据</strong>的功能，用于<strong>部分复制和复制命令丢失时的数据补救</strong>。</p>
<p>复制积压缓冲区的统计信息在 <strong>info replication</strong> 中的 <strong>repl_backlog_size</strong> 指标中。</p>
<h6 id="3-主节点运行id"><a href="#3-主节点运行id" class="headerlink" title="(3) 主节点运行id"></a>(3) 主节点运行id</h6><p>每个 Redis <strong>结点</strong>启动后会分配动态分配一个 40 位的十六进制字符串作为<strong>运行 Id</strong>，可以<strong>唯一标识</strong> Redis 节点。</p>
<h6 id="4-psync使用"><a href="#4-psync使用" class="headerlink" title="(4) psync使用"></a>(4) psync使用</h6><p>从节点使用 <strong>psync</strong> 命令完成部分<strong>复制和全量复制</strong>功能。格式如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># runId: 从节点复制主节点的运行Id</span><br><span class="line"># offset: 当前从节点已经复制的偏移量，第一次参与复制则为-1</span><br><span class="line">psync &#123;runId&#125; &#123;offset&#125;</span><br></pre></td></tr></table></figure>

<img src="assets/image-20200426105809787.png" alt="image-20200426105809787" style="zoom:67%;" />

<p><strong>主节点</strong>根据 psync 参数与自身<strong>参数情况</strong>选择进行回复。</p>
<ul>
<li>+<strong>FULLRESYNC</strong> {runId} {offset}：从节点触发全量复制。</li>
<li>+<strong>CONTINUE</strong>：从节点触发部分复制。</li>
<li>+<strong>ERR</strong>：主节点版本低于2.8，无法识别 psync 命令。</li>
</ul>
<h5 id="3-数据同步流程"><a href="#3-数据同步流程" class="headerlink" title="3. 数据同步流程"></a>3. 数据同步流程</h5><p>Redis 2.8 之后使用 <strong>psync</strong> 命令完成主从数据同步，同步可以分为：<strong>全量复制、部分复制</strong>。</p>
<ul>
<li><strong>全量复制</strong>：一般用于<strong>初次复制</strong>的场景，开销较大。</li>
<li><strong>部分复制</strong>：用于处理在主从复制中因<strong>网络闪断</strong>等原因造成的<strong>数据丢失</strong>场景，从节点再次连接主节点后，如果条件允许，主节点<strong>补发</strong>丢失的数据给从节点。可以避免开销过大。</li>
</ul>
<h6 id="1-全量复制"><a href="#1-全量复制" class="headerlink" title="(1) 全量复制"></a>(1) 全量复制</h6><p>主从<strong>第一次建立复制</strong>时必须经历的阶段，触发全量复制的命令是 <strong>sync（Redis2.8之前） 和 fsync（Redis2.8之后）</strong>。</p>
<blockquote>
<p><strong>全量复制流程</strong></p>
</blockquote>
<ul>
<li>由于是第一次复制，从节点没有复制偏移量和主节点运行 Id，所以发送 <strong>fsync ？-1</strong>。</li>
<li>主节点判断这是全量复制，返回 +FULLRESYNC。</li>
<li>从节点接收到主节点的响应数据，即可保存运行 Id 和偏移量 offset。</li>
<li>主节点执行 <strong>bgsave</strong> 命令保存 <strong>RDB 文件到本地</strong>。</li>
<li>主节点把 RDB 文件<strong>发送</strong>到从节点，从节点将其作为本地数据文件。如果 RDB 文件过大，那么发送过程可能非常耗时。</li>
<li>从节点从开始接收 RDB 快照到接收完成期间，主节点仍然可以响应指令，主节点把这一时期的命令数据保存在<strong>复制客户端缓冲区</strong>内，等从节点加载完 RDB 文件后，主节点再把缓冲区内的数据发送到从节点，保证数据一致性。</li>
<li>从节点接收完主节点传送来的数据后会<strong>清空自身旧数据</strong>，然后<strong>加载 RDB 文件</strong>。</li>
<li>如果从节点开启了 AOF 持久化，那么加载完 RDB 后会立即执行 <strong>bgrewriteaof</strong> 操作进行持久化。</li>
</ul>
<p>全量复制是一个<strong>非常耗时</strong>的操作。主要<strong>时间开销</strong>有：</p>
<ul>
<li>主节点 bgsave 的时间。</li>
<li>RBD 文件网络传输时间。</li>
<li>从节点清空数据时间。</li>
<li>从节点加载 RDB 时间。</li>
<li>可能的 AOF 重写时间。</li>
</ul>
<p>除了<strong>第一次</strong>复制执行全量复制之外，其他的场景应该<strong>避免使用全量复制</strong>。</p>
<blockquote>
<p><strong>全量复制发生的场景</strong></p>
</blockquote>
<p>全量复制开销极大，需要规避。这里分析一下全量复制发生的场景。</p>
<ul>
<li><strong>第一次建立复制</strong>。不可避免，建议在<strong>低峰</strong>时进行。</li>
<li><strong>节点运行 Id 不匹配</strong>。主从复制关系建立后，从节点会保存主节点的运行 id，如果主节点故障重启，会造成 id 变化（因为是动态 Id），从节点发现 id 变化便会认为是一个<strong>新的</strong>节点从而进行全量复制。这种情况需要从架构上规避，如提供<strong>故障转移</strong>功能。当主节点发生故障之后，可以采用支持自动故障转移的<strong>哨兵或集群</strong>方案，让<strong>从节点成为主节点</strong>。</li>
<li><strong>复制积压缓冲区不足</strong>。在进行部分复制时，如果 <strong>offset 不在复制积压缓冲区中</strong>，比如主从断开的时间过长，复制积压缓冲区记录的命令早就<strong>超过</strong>了默认的 1MB，这时候为了保证数据一致性就会把部分复制<strong>退化</strong>为全量复制。所以大流量的场景需要<strong>增大复制积压缓冲区</strong>。</li>
</ul>
<h6 id="2-部分复制"><a href="#2-部分复制" class="headerlink" title="(2) 部分复制"></a>(2) 部分复制</h6><p>使用如下命令实现部分复制，可以优化全量复制带来的开销。如果出现<strong>网络闪断或者命令丢</strong>失等异常情况，从节点会向主节点要求<strong>补发</strong>丢失的命令数据，如果主节点的<strong>复制积压缓冲区</strong>内存在这部分数据则可以直接发送给从节点。大大降低了开销。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psync &#123;runId&#125; &#123;offset&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>部分复制流程</strong></p>
</blockquote>
<p>部分复制流程如下：</p>
<ul>
<li>主从节点如果出现网络中断，时间超过 <strong>repl-timeout</strong> 时就认为从节点故障并中断复制链接。</li>
<li>此时主节点依然可以响应指令，但是复制链接中断所以<strong>无法</strong>发送命令给从节点，不过主节点内部<strong>存在复制积压缓冲区</strong>，依然<strong>可以保存最近一段时间</strong>内的写命令数据。</li>
<li>当主从再次连接之后，两者通过<strong>偏移量 offset</strong> 在<strong>复制积压缓冲区</strong>寻找，如果 offset <strong>在缓冲区</strong>中，则<strong>直接根据这个偏移量补发</strong>数据即可。</li>
</ul>
<h5 id="4-心跳机制"><a href="#4-心跳机制" class="headerlink" title="4. 心跳机制"></a>4. 心跳机制</h5><p>主从结点在建立复制之后，它们之间维护着<strong>长连接</strong>并彼此发送<strong>心跳命令</strong>。心跳机制：</p>
<ul>
<li>主从节点都有心跳检查机制。</li>
<li>主节点默认每隔 <strong>10</strong> 秒对从节点发送 ping 命令，判断从节点的状态。</li>
<li>从节点在主线程中每隔 1 秒发送 <strong>replconf ack {offset}</strong> 命令给主节点报告自己的 <strong>offset 信息</strong>。</li>
</ul>
<h5 id="5-异步复制"><a href="#5-异步复制" class="headerlink" title="5. 异步复制"></a>5. 异步复制</h5><p>主节点不但负责数据读写，而且还会把写命令同步给从节点。<strong>写命令的发送</strong>过程是<strong>异步</strong>完成的，也就是说主节点自身处理完读写命令后<strong>直接返回给客户端</strong>，并<strong>不等待从节点复制</strong>完成。</p>
<p><strong>由于主从复制是异步的，所以会造成从节点的数据相对主节点存在==延迟==，可能造成一定的数据不一致</strong>。具体延迟可以通过 <strong>info replication</strong> 中<strong>主从节点的复制偏移量</strong>计算出。</p>
<h5 id="6-复制过程Demo"><a href="#6-复制过程Demo" class="headerlink" title="6. 复制过程Demo"></a>6. 复制过程Demo</h5><p>在 Redis 中，用户可以通过执行 SLAVEOF 命令或者设置 slaveof 选项，让一个服务器去复制另一个服务器，以下三种方式是 <strong>完全等效</strong> 的：</p>
<ul>
<li><strong>配置文件</strong>：在从服务器的配置文件中加入：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>。</li>
<li><strong>启动命令</strong>：redis-server 启动命令后加入 <code>--slaveof &lt;masterip&gt; &lt;masterport&gt;</code>。</li>
<li><strong>客户端命令</strong>：Redis 服务器启动后，直接通过客户端执行命令：<code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code>，让该 Redis 实例成为从节点。</li>
</ul>
<p>需要注意的是：<strong>主从复制的开启，完全是在从节点发起的，不需要主节点做任何事情。</strong>这里模拟一下复制过程。</p>
<h6 id="1-第一步：本地启动两个节点"><a href="#1-第一步：本地启动两个节点" class="headerlink" title="(1) 第一步：本地启动两个节点"></a>(1) 第一步：本地启动两个节点</h6><p>在正确安装好 Redis 之后，我们可以使用 <strong>redis-server –port &lt;port&gt;</strong> 的方式指定创建两个不同端口的 Redis 实例，例如，下方我分别创建了一个 6379 和 6380 的两个 Redis 实例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个端口为 6379 的 Redis 实例</span></span><br><span class="line">redis-server --port 6379</span><br><span class="line"><span class="comment"># 创建一个端口为 6380 的 Redis 实例</span></span><br><span class="line">redis-server --port 6380</span><br></pre></td></tr></table></figure>

<p>此时两个 Redis 节点启动后，都默认为 <strong>主节点</strong>。</p>
<h6 id="2-第二步：建立复制"><a href="#2-第二步：建立复制" class="headerlink" title="(2) 第二步：建立复制"></a>(2) 第二步：建立复制</h6><p>在 6380 端口的节点中执行 <strong>slaveof</strong> 命令，使之变为从节点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 6380 端口的 Redis 实例中使用控制台</span></span><br><span class="line">redis-cli -p 6380</span><br><span class="line"><span class="comment"># 成为本地 6379 端口实例的从节点</span></span><br><span class="line">127.0.0.1:6380&gt; SLAVEOF 127.0.0.1ø 6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h6 id="3-第三步：观察效果"><a href="#3-第三步：观察效果" class="headerlink" title="(3) 第三步：观察效果"></a>(3) 第三步：观察效果</h6><p>下面验证一下，主节点的数据是否会复制到从节点之中：</p>
<ul>
<li>先在 <strong>从节点</strong> 中查询一个 <strong>不存在</strong> 的 key：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; GET mykey</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<ul>
<li>再在 <strong>主节点</strong> 中添加这个 key：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SET mykey myvalue</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<ul>
<li>此时再从 <strong>从节点</strong> 中查询，会发现已经从 <strong>主节点</strong> 同步到 <strong>从节点</strong>：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; GET mykey</span><br><span class="line"><span class="string">"myvalue"</span></span><br></pre></td></tr></table></figure>

<h6 id="4-第四步：断开复制"><a href="#4-第四步：断开复制" class="headerlink" title="(4) 第四步：断开复制"></a>(4) 第四步：断开复制</h6><p>通过 <strong>slaveof &lt;masterip&gt; &lt;masterport&gt;</strong> 命令建立主从复制关系以后，可以通过 <strong>slaveof no one</strong> 断开。需要注意的是，从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p>
<p>从节点执行 <strong>slaveof no one</strong> 之后，从节点和主节点分别打印日志如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从节点打印日志</span></span><br><span class="line">61496:M 17 Mar 2020 08:10:22.749 <span class="comment"># Connection with master lost.</span></span><br><span class="line">61496:M 17 Mar 2020 08:10:22.749 * Caching the disconnected master state.</span><br><span class="line">61496:M 17 Mar 2020 08:10:22.749 * Discarding previously cached master state.</span><br><span class="line">61496:M 17 Mar 2020 08:10:22.749 * MASTER MODE enabled (user request from <span class="string">'id=4 addr=127.0.0.1:55096 fd=8 name= age=1664 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=34 qbuf-free=32734 obl=0 oll=0 omem=0 events=r cmd=slaveof'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主节点打印日志</span></span><br><span class="line">61467:M 17 Mar 2020 08:10:22.749 <span class="comment"># Connection with replica 127.0.0.1:6380 lost.</span></span><br></pre></td></tr></table></figure>



<h4 id="开发与运维中的问题"><a href="#开发与运维中的问题" class="headerlink" title="开发与运维中的问题"></a>开发与运维中的问题</h4><h5 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h5><p>读写分离：对于<strong>读占比较高</strong>的场景，可以把一部分读流量分摊到<strong>从节点</strong>来减轻主节点的压力，同时需要<strong>==写操作永远只在主节点==</strong>进行。</p>
<img src="assets/image-20200426125508512.png" alt="image-20200426125508512" style="zoom:67%;" />

<p>当使用从节点响应读请求时，客户端可能存在<strong>复制数据延迟、读到过期数据、从节点故障</strong>等问题。</p>
<h6 id="1-数据延迟问题"><a href="#1-数据延迟问题" class="headerlink" title="(1) 数据延迟问题"></a>(1) 数据延迟问题</h6><p>Redis 复制数据的延迟是由于<strong>异步复制的特性</strong>决定无法改变的，延迟也取决于网络带宽和命令阻塞等情况。这会造成刚在主节点写入的数据从节点可能暂时<strong>读不到</strong>。</p>
<p>允许<strong>短暂延迟</strong>的场景还行，不行的话可以<strong>编写外部监控程序监听主从节点的复制偏移量，</strong>当延迟较大时触发报警或者通知客户端别去读取延迟过高的节点。具体延迟可以通过 <strong>info replication</strong> 中<strong>主从节点的复制偏移量</strong>计算出。</p>
<p>当延迟字节量过高时，可以采用 Zookeeper 的监听回调机制实现客户端通知。但是这种方式成本比较高。</p>
<h6 id="2-读到过期数据问题"><a href="#2-读到过期数据问题" class="headerlink" title="(2) 读到过期数据问题"></a>(2) 读到过期数据问题</h6><p>Redis 键过期删除策略有<strong>惰性删除和定时删除</strong>。如果主节点包含了大量<strong>会过期</strong>的数据，可能主节点数据<strong>已经过期</strong>，但是过期的命令可能还没有来得及发到从节点，从而导致在从节点读取到过期的数据。但是 Redis 3.2 之后的版本中，<strong>从节点读数据时也会检查过期时间</strong>，已经解决了这个问题。</p>
<h6 id="3-从节点故障问题"><a href="#3-从节点故障问题" class="headerlink" title="(3) 从节点故障问题"></a>(3) 从节点故障问题</h6><p>对于从节点故障问题，需要在客户端维护可用从节点列表。做 Redis 读写分离其实维护成本挺高，建议做之前考虑使用 <strong>Redis Cluster</strong> 等分布式解决方案。</p>
<h5 id="2-主从配置不一致问题"><a href="#2-主从配置不一致问题" class="headerlink" title="2. 主从配置不一致问题"></a>2. 主从配置不一致问题</h5><p><strong>主从配置不一致</strong>是一个容易忽视的问题，主从节点之间有的配置可以不一致，但是<strong>内存相关</strong>的配置最好是一致的，如 maxmemory。</p>
<h5 id="3-复制风暴问题"><a href="#3-复制风暴问题" class="headerlink" title="3. 复制风暴问题"></a>3. 复制风暴问题</h5><p><strong>复制风暴</strong>指的是<strong>大量从节点</strong>对同一主节点或者同一台机器的多个主节点在<strong>短时间内发起全量复制</strong>的过程，这会造成主节点开销极大，需要规避。</p>
<p>在一主多从的架构下，如果主节点故障重启，<strong>运行 id 改变</strong>，那么就会对<strong>各个从节点发起全量复制</strong>。主节点短时间内需要生成大量 RDB 文件，传输 RDB 文件也会造成短时间内带宽消耗巨大。</p>
<p>解决方案：<strong>减少</strong>单个主节点 挂载从节点数量，或者使用加入<strong>中间层的树状架构</strong>来保护主节点。如果是单机多个主节点，可以把主节点部署在不同的机器上。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>《Redis开发与运维》</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/I%20%E7%BC%93%E5%AD%98/E%20Redis%E5%93%A8%E5%85%B5/" rel="next" title="ShiftJava/I 缓存/E Redis哨兵">
                <i class="fa fa-chevron-left"></i> ShiftJava/I 缓存/E Redis哨兵
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/I%20%E7%BC%93%E5%AD%98/C%20Redis%E6%8C%81%E4%B9%85%E5%8C%96/" rel="prev" title="ShiftJava/I 缓存/C Redis持久化">
                ShiftJava/I 缓存/C Redis持久化 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis主从复制"><span class="nav-number">1.</span> <span class="nav-text">Redis主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主从复制基础"><span class="nav-number">1.1.</span> <span class="nav-text">主从复制基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-主从复制的作用"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 主从复制的作用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-复制建立与断开"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 复制建立与断开</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-建立复制"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">(1) 建立复制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-断开复制"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">(2) 断开复制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-只读"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">(3) 只读</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-复制拓扑关系"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. 复制拓扑关系</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-一主一从结构"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">(1) 一主一从结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-一主多从结构"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">(2) 一主多从结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-树状主从结构"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">(3) 树状主从结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制原理"><span class="nav-number">1.2.</span> <span class="nav-text">复制原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-复制过程"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 复制过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-psync"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. psync</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-复制偏移量"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">(1) 复制偏移量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-复制积压缓冲区"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">(2) 复制积压缓冲区</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-主节点运行id"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">(3) 主节点运行id</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-psync使用"><span class="nav-number">1.2.2.4.</span> <span class="nav-text">(4) psync使用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-数据同步流程"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 数据同步流程</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-全量复制"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">(1) 全量复制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-部分复制"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">(2) 部分复制</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-心跳机制"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. 心跳机制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-异步复制"><span class="nav-number">1.2.5.</span> <span class="nav-text">5. 异步复制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-复制过程Demo"><span class="nav-number">1.2.6.</span> <span class="nav-text">6. 复制过程Demo</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-第一步：本地启动两个节点"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">(1) 第一步：本地启动两个节点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-第二步：建立复制"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">(2) 第二步：建立复制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-第三步：观察效果"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">(3) 第三步：观察效果</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-第四步：断开复制"><span class="nav-number">1.2.6.4.</span> <span class="nav-text">(4) 第四步：断开复制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#开发与运维中的问题"><span class="nav-number">1.3.</span> <span class="nav-text">开发与运维中的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-读写分离"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 读写分离</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-数据延迟问题"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">(1) 数据延迟问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-读到过期数据问题"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">(2) 读到过期数据问题</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-从节点故障问题"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">(3) 从节点故障问题</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-主从配置不一致问题"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 主从配置不一致问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-复制风暴问题"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 复制风暴问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.4.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
