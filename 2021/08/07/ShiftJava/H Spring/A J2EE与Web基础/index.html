<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] J2EESpring 之前还是了解一下之前的老东西，而且 Servlet 也是非常重要的。 JSP1. 概述JSP 是一种 Servlet，但是与 HttpServlet 的工作方式不太一样。HttpServlet 是先由源代码编译为 class 文件后部署到服务器下，为先编译后部署。而 JSP 则是先部署后编译。JSP 会在客户端第一次请求 JSP 文件时被编译为 HttpJspPa">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;H Spring&#x2F;A J2EE与Web基础">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;A%20J2EE%E4%B8%8EWeb%E5%9F%BA%E7%A1%80&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] J2EESpring 之前还是了解一下之前的老东西，而且 Servlet 也是非常重要的。 JSP1. 概述JSP 是一种 Servlet，但是与 HttpServlet 的工作方式不太一样。HttpServlet 是先由源代码编译为 class 文件后部署到服务器下，为先编译后部署。而 JSP 则是先部署后编译。JSP 会在客户端第一次请求 JSP 文件时被编译为 HttpJspPa">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;A%20J2EE%E4%B8%8EWeb%E5%9F%BA%E7%A1%80&#x2F;assets&#x2F;1535532891036.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;A%20J2EE%E4%B8%8EWeb%E5%9F%BA%E7%A1%80&#x2F;assets&#x2F;1535535812505.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;A%20J2EE%E4%B8%8EWeb%E5%9F%BA%E7%A1%80&#x2F;assets&#x2F;servlet-tomcat.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;A%20J2EE%E4%B8%8EWeb%E5%9F%BA%E7%A1%80&#x2F;assets&#x2F;1535532891036.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/H Spring/A J2EE与Web基础/"/>





  <title>ShiftJava/H Spring/A J2EE与Web基础 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/H%20Spring/A%20J2EE%E4%B8%8EWeb%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/H Spring/A J2EE与Web基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h3><p>Spring 之前还是了解一下之前的老东西，而且 Servlet 也是非常重要的。</p>
<h4 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>JSP 是一种 Servlet，但是与 HttpServlet 的工作方式<strong>不太一样</strong>。HttpServlet 是先由<strong>源代码编译</strong>为 <strong>class 文件</strong>后部署到服务器下，为<strong>先编译后部署</strong>。而 JSP 则是<strong>先部署后编译</strong>。JSP 会在客户端第一次请求 JSP 文件时被编译为 HttpJspPage 类（Servlet 接口的一个子类）。该类会被服务器临时存放在服务器工作目录里面。 </p>
<p>由于 JSP 只会在客户端<strong>第一次请求的时候被编译</strong> ，因此第一次请求 JSP 时会感觉比较<strong>慢</strong>，之后就会快很多。如果把服务器保存的 class 文件删除，服务器也会重新编译 JSP。</p>
<p>开发 Web 程序时经常需要修改 JSP。Tomcat 能够自动检测到 JSP 程序的改动。如果检测到 JSP 源代码发生了改动。Tomcat 会在下次客户端请求 JSP 时重新编译 JSP，而不需要重启 Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署 Web 应用的时候可以在 web.xml 中将它关掉。</p>
<p>参考：《Javaweb 整合开发王者归来》P97</p>
<h5 id="2-四种作用域"><a href="#2-四种作用域" class="headerlink" title="2. 四种作用域"></a>2. 四种作用域</h5><p>JSP 中的四种作用域包括 page、request、session 和 application，具体来说：</p>
<ul>
<li><strong>page</strong>：代表与一个页面相关的对象和属性。</li>
<li><strong>request</strong>：代表与 Web 客户端发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个 Web 组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li><strong>session</strong>：代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li>
<li><strong>application</strong>：代表与整个 Web 应用程序相关的对象和属性，它实质上是跨越整个 Web 应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h5 id="3-JSP内置对象"><a href="#3-JSP内置对象" class="headerlink" title="3. JSP内置对象"></a>3. JSP内置对象</h5><p>JSP 有 9 个内置对象：</p>
<ul>
<li>request：封装客户端的请求，其中包含来自 GET 或 POST 请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web 应用的配置对象；</li>
<li>page：JSP 页面本身（相当于 Java 程序中的 this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<h4 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>Servlet 是在<strong>服务器</strong>上运行的小程序。一个 servlet 就是一个 Java 类，并且可以通过 “请求—响应” 编程模式来访问的这个驻留在服务器内存里的 servlet 程序。  </p>
<p>类的继承关系如下：</p>
<img src="assets/1535532891036.png" style="zoom:56%;" />

<p>Servlet 三种<strong>实现方式</strong>：</p>
<ul>
<li><p>实现 javax.servlet.<strong>Servlet</strong> 接口。</p>
</li>
<li><p>继承 javax.servlet.<strong>GenericServlet</strong> 类。</p>
</li>
<li><p>继承 javax.servlet.http.<strong>HttpServlet</strong> 类。通常会去继承 HttpServlet 类来完成 Servlet。</p>
</li>
</ul>
<p>在 JavaWeb 程序中，Servlet 主要负责<strong>接收用户请求 HttpServletRequest</strong>，在 <strong>doGet()，doPost()</strong> 中做相应的处理，并将回应 <strong>HttpServletResponse</strong> 反馈给用户。Servlet 可以设置初始化参数，供 Servlet 内部使用。一个 Servlet 类只会有<strong>一个实例</strong>，在它初始化时调用 <strong>init</strong>() 方法，销毁时调用 <strong>destroy</strong>() 方法。Servlet 需要在 <strong>web.xml</strong> 中配置，一个 Servlet 可以设置多个 URL 访问。<strong>Servlet 不是线程安全</strong>，因此要谨慎使用类变量。</p>
<h5 id="2-Servlet的优点"><a href="#2-Servlet的优点" class="headerlink" title="2. Servlet的优点"></a>2. Servlet的优点</h5><p>优点如下：</p>
<ul>
<li>只需要启动一个操作系统进程以及加载<strong>一个 JVM</strong>，大大降低了系统的开销。如果多个请求需要做同样处理的时候，这时候只需要<strong>加载一个类</strong>，这也大大降低了开销。</li>
<li>所有<strong>动态加载</strong>的类可以实现对网络协议以及请求解码的<strong>共享</strong>，大大降低了工作量。</li>
<li>Servlet 能直接和 Web 服务器交互，而普通的 CGI 程序不能。Servlet 还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</li>
</ul>
<h5 id="3-Servlet接口与生命周期"><a href="#3-Servlet接口与生命周期" class="headerlink" title="3. Servlet接口与生命周期"></a>3. Servlet接口与生命周期</h5><p>Servlet 接口定义了 5 个方法，其中<strong>前三个方法与 Servlet 生命周期相关</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse resp)</span> <span class="keyword">throws</span> ServletException, java.io.IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">java.lang.<span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>Servlet 生命周期如下：</p>
<ul>
<li>Web 容器加载 Servlet 并将其实例化后，Servlet 生命周期开始，容器运行其 <strong>init() 方法</strong>进行 Servlet 的<strong>初始化</strong>。</li>
<li><strong>请求到达</strong>时调用 Servlet 的 <strong>service</strong>() 方法，service() 方法会根据需要调用与请求对应的 <strong>doGet 或 doPost</strong> 等方法。</li>
<li>当服务器<strong>关闭</strong>或项目被卸载时服务器会将 Servlet 实例销毁，此时会调用 Servlet 的 <strong>destroy</strong>() 方法。</li>
</ul>
<p>init 方法和 destroy 方法<strong>只会执行一次</strong>，service 方法客户端每次请求 Servlet 都会执行。Servlet 中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入 init 方法中，销毁资源的代码放入 destroy 方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p>
<ul>
<li>Servlet 类由自己编写，但<strong>对象由服务器</strong>来创建，并由服务器来调用相应的方法。　</li>
<li>服务器<strong>启动</strong>时 ( web.xml 中配置 load-on-startup=1，默认为 0 ) 或者<strong>第一次请求该 servlet</strong> 时，就会<strong>初始化</strong>一个 Servlet 对象，也就是<strong>会执行初始化方法 init</strong>(ServletConfig conf)。</li>
<li>该 servlet 对象去处理所有<strong>客户端请求</strong>，在 <strong>service</strong>(ServletRequest req，ServletResponse res) 方法中执行。</li>
<li>最后服务器<strong>关闭</strong>时，才会销毁这个 servlet 对象，执行 <strong>destroy</strong>() 方法。</li>
</ul>
<img src="assets/1535535812505.png" style="zoom:42%;" />

<h5 id="4-线程安全性"><a href="#4-线程安全性" class="headerlink" title="4. 线程安全性"></a>4. 线程安全性</h5><p><strong>Servlet 不是线程安全的，多线程并发的读写会导致数据不同步的问题</strong>。</p>
<p>解决的办法是<strong>尽量不要定义 name 属性</strong>，而是要把 name 变量分别定义在 doGet() 和 doPost() 方法内。虽然使用synchronized(name){} 语句块可以解决问题，但是会造成线程的等待。 注意：<strong>多线程的并发的读写 Servlet 类属性会导致数据不同步</strong>。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此 Servlet 里的<strong>只读属性</strong>最好定义为 final 类型的。</p>
<h5 id="5-Tomcat和Servlet的联系"><a href="#5-Tomcat和Servlet的联系" class="headerlink" title="5. Tomcat和Servlet的联系"></a>5. Tomcat和Servlet的联系</h5><p>Tomcat 是 Web 应用服务器，是一个 Servlet/JSP <strong>容器</strong>。Tomcat 作为 <strong>Servlet 容器</strong>，负责处理客户请求，把请求传送给 Servlet，并将 Servlet 的<strong>响应传送回给客户</strong>。而 Servlet 是一种运行在支持 Java 语言的服务器上的组件。Servlet 最常见的用途是扩展 Java Web 服务器功能，提供非常安全的，可移植的，易于使用的 CGI 替代品。</p>
<p>从 HTTP 协议中的请求和响应可以得知，浏览器发出的请求是一个<strong>请求文本</strong>，而浏览器接收到的也应该是一个响应文本。但是在下面这个图中，并不知道是如何转变的，只知道浏览器发送过来的请求也就是 request，我们响应回去的就用 response。忽略了其中的细节，现在就来探究一下。</p>
<img src="assets/servlet-tomcat.png" alt="servlet-tomcat" style="zoom:45%;" />

<p>(1) Tomcat 将 HTTP 请求文本接收<strong>并解析</strong>，然后封装成 <strong>HttpServletRequest</strong> 类型的 <strong>request 对象</strong>，所有的 HTTP <strong>头数据</strong>读可以通过 request 对象调用对应的方法查询到。</p>
<p>(2) Tomcat 同时会要<strong>响应的信息封装为 HttpServletResponse 类型的 response 对象</strong>，通过设置 response 属性就可以控制要输出到浏览器的内容，然后将 response 交给 Tomcat，Tomcat 就会将其变成响应文本的格式发送给浏览器。</p>
<p>Java Servlet API 是 <strong>Servlet 容器(Tomcat) 和 servlet 之间的接口</strong>，它定义了 serlvet 的各种方法，还定义了 Servlet 容器传送给 Servlet 的对象类，其中最重要的就是 <strong>ServletRequest</strong> 和 <strong>ServletResponse</strong>。所以在编写 servlet 时，需要实现 Servlet 接口，按照其规范进行操作。</p>
<h5 id="6-Tomcat装载Servlet的三种情况"><a href="#6-Tomcat装载Servlet的三种情况" class="headerlink" title="6. Tomcat装载Servlet的三种情况"></a>6. Tomcat装载Servlet的三种情况</h5><p>(1) Servlet 容器<strong>启动时</strong>自动装载某些 Servlet，实现它只需要在 web.xml 文件中的 <code>&lt;servlet&gt;&lt;/servlet&gt;</code> 之间添加以下代码：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，数字越小表示优先级越高。例如在 web.xml 中设置 TestServlet2 的优先级为 1，而 TestServlet1 的优先级为 2，启动和关闭 Tomcat：优先级高的先启动也先关闭。　　</p>
<p>(2) 客户端首次向某个 Servlet <strong>发送请求</strong>。</p>
<p>(3) Servlet 类被<strong>修改</strong>后，Tomcat 容器会重新装载 Servlet。</p>
<h4 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h4><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<p><strong>转发（Forward）</strong> 通过 <strong>RequestDispatcher</strong> 对象的 forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher 可以通过 HttpServletRequest 的 getRequestDispatcher() 方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"login_success.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure>

<p><strong>重定向（Redirect）</strong> 是利用<strong>服务器返回的状态码</strong>来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 <strong>HttpServletResponse</strong> 的 <code>setStatus(int status)</code> 方法<strong>设置状态码</strong>。如果服务器返回 301 或者 302，则浏览器会到<strong>新的网址</strong>重新请求该资源。</p>
<ul>
<li><p><strong>地址栏显示</strong>：forward 是服务器请求资源，服务器直接访问目标地址的 URL，把那个 URL 的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本<strong>不知道</strong>服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。 redirect 是服务端根据逻辑，发送一个状态码，告诉浏览器重新去请求那个地址，所以<strong>地址栏显示的是新的 URL</strong>。</p>
</li>
<li><p><strong>数据共享</strong>：forward 转发页面和转发到的页面可以<strong>共享</strong> request 里面的数据。redirect 不能共享数据。</p>
</li>
<li><p><strong>使用场景</strong>：forward一般用于<strong>用户登陆</strong>的时候，根据角色转发到相应的模块。 redirect 一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</p>
</li>
<li><p><strong>效率</strong>：forward 效率高，redirect 效率低。</p>
</li>
</ul>
<h4 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h4><h5 id="1-使用Cookie"><a href="#1-使用Cookie" class="headerlink" title="1. 使用Cookie"></a>1. 使用Cookie</h5><p>向客户端发送 Cookie。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie c = <span class="keyword">new</span> Cookie(<span class="string">"name"</span>,<span class="string">"value"</span>); <span class="comment">// 创建Cookie </span></span><br><span class="line">c.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>);   <span class="comment">// 设置最大时效，此处设置的最大时效为一天</span></span><br><span class="line">response.addCookie(c);   <span class="comment">// 把Cookie放入到HTTP响应中</span></span><br></pre></td></tr></table></figure>

<p>从客户端读取 Cookie。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">"name"</span>; </span><br><span class="line">Cookie[]cookies = request.getCookies(); </span><br><span class="line"><span class="keyword">if</span>(cookies != <span class="keyword">null</span>)&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; cookies.length; i++)&#123; </span><br><span class="line">        Cookie cookie = cookies[i]; </span><br><span class="line">        <span class="keyword">if</span>(name.equals(cookis.getName())) </span><br><span class="line">            <span class="comment">//something is here. </span></span><br><span class="line">            <span class="comment">//you can get the value </span></span><br><span class="line">            cookie.getValue(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点:</strong> 数据可以持久保存，不需要服务器资源，简单，基于文本的 Key-Value。</p>
<p><strong>缺点:</strong> 大小受到限制，用户可以禁用 Cookie 功能，由于保存在本地，有一定的安全风险。</p>
<h5 id="2-URL重写"><a href="#2-URL重写" class="headerlink" title="2. URL重写"></a>2. URL重写</h5><p>在 URL 中添加<strong>用户会话的信息</strong>作为<strong>请求的参数</strong>，或者将唯一的<strong>会话 ID 添加到 URL 结尾</strong>以标识一个会话。</p>
<p><strong>优点：</strong> 在 Cookie 被禁用的时候依然可以使用。</p>
<p><strong>缺点：</strong> 必须对网站的 URL 进行编码，所有页面必须动态生成，不能用预先记录下来的 URL 进行访问。</p>
<h5 id="3-隐藏的表单域"><a href="#3-隐藏的表单域" class="headerlink" title="3. 隐藏的表单域"></a>3. 隐藏的表单域</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;hidden&quot; name =&quot;session&quot; value=&quot;...&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong> Cookie 被禁时可以使用。</p>
<p><strong>缺点：</strong> 所有页面必须是表单提交之后的结果。</p>
<h5 id="4-HttpSession"><a href="#4-HttpSession" class="headerlink" title="4. HttpSession"></a>4. HttpSession</h5><p>在所有会话跟踪技术中，HttpSession 对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 <strong>HttpSession</strong>，每个用户可以访问其自己的 HttpSession。可以通过 HttpServletRequest 对象的 getSession 方法获得HttpSession，通过 HttpSession 的 <strong>setAttribute</strong> 方法可以将一个<strong>值</strong>放在 HttpSession 中，通过调用 HttpSession 对象的 <strong>getAttribute</strong> 方法，同时传入属性名就可以获取保存在 HttpSession 中的对象。</p>
<p>与上面三种方式不同的是，HttpSession 放在服务器的<strong>内存</strong>中，因此不要将过大的对象放在里面，即使目前的 Servlet 容器可以在内存将满时将 HttpSession 中的对象移到其他存储设备中，但是这样会影响性能。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/G%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/B%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="next" title="ShiftJava/G 设计模式/B 设计模式面试题">
                <i class="fa fa-chevron-left"></i> ShiftJava/G 设计模式/B 设计模式面试题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/H%20Spring/C%20Spring%20IOC/" rel="prev" title="ShiftJava/H Spring/C Spring IOC">
                ShiftJava/H Spring/C Spring IOC <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#J2EE"><span class="nav-number">1.</span> <span class="nav-text">J2EE</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JSP"><span class="nav-number">1.1.</span> <span class="nav-text">JSP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-四种作用域"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 四种作用域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-JSP内置对象"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. JSP内置对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Servlet"><span class="nav-number">1.2.</span> <span class="nav-text">Servlet</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-1"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Servlet的优点"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. Servlet的优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Servlet接口与生命周期"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. Servlet接口与生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-线程安全性"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. 线程安全性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Tomcat和Servlet的联系"><span class="nav-number">1.2.5.</span> <span class="nav-text">5. Tomcat和Servlet的联系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-Tomcat装载Servlet的三种情况"><span class="nav-number">1.2.6.</span> <span class="nav-text">6. Tomcat装载Servlet的三种情况</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转发-Forward-和重定向-Redirect-的区别"><span class="nav-number">1.3.</span> <span class="nav-text">转发(Forward)和重定向(Redirect)的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#会话跟踪技术"><span class="nav-number">1.4.</span> <span class="nav-text">会话跟踪技术</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-使用Cookie"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 使用Cookie</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-URL重写"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. URL重写</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-隐藏的表单域"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 隐藏的表单域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-HttpSession"><span class="nav-number">1.4.4.</span> <span class="nav-text">4. HttpSession</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
