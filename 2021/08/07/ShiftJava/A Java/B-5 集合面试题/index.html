<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] 集合面试题HashMapQ：HashMap的数据结构？A：哈希表结构（数组+链表）实现（Java7）。Java8 之后当链表长度超过 8 时，链表转换为红黑树。  Q：HashMap的工作原理？A：HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry&amp;lt;K,V&amp;gt;接口）实现，HashMap 通过 put">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;A Java&#x2F;B-5 集合面试题">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;B-5%20%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] 集合面试题HashMapQ：HashMap的数据结构？A：哈希表结构（数组+链表）实现（Java7）。Java8 之后当链表长度超过 8 时，链表转换为红黑树。  Q：HashMap的工作原理？A：HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry&amp;lt;K,V&amp;gt;接口）实现，HashMap 通过 put">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;B-5%20%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;assets&#x2F;1567084676248.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;B-5%20%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;assets&#x2F;hash-to-badlink.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;B-5%20%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;assets&#x2F;1567084676248.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/A Java/B-5 集合面试题/"/>





  <title>ShiftJava/A Java/B-5 集合面试题 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/A%20Java/B-5%20%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/A Java/B-5 集合面试题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="集合面试题"><a href="#集合面试题" class="headerlink" title="集合面试题"></a>集合面试题</h3><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><h5 id="Q：HashMap的数据结构？"><a href="#Q：HashMap的数据结构？" class="headerlink" title="Q：HashMap的数据结构？"></a>Q：HashMap的数据结构？</h5><p>A：<strong>哈希表结构（数组+链表）</strong>实现（Java7）。Java8 之后当链表长度超过 <strong>8</strong> 时，链表转换为<strong>红黑树</strong>。</p>
<p><img src="assets/1567084676248.png" alt="1567084676248"></p>
<h5 id="Q：HashMap的工作原理？"><a href="#Q：HashMap的工作原理？" class="headerlink" title="Q：HashMap的工作原理？"></a>Q：HashMap的工作原理？</h5><p>A：HashMap 底层是 <strong>hash 数组</strong>和<strong>单向链表</strong>实现，数组中的每个元素都是<strong>链表</strong>，由 <strong>Node 内部类（实现 Map.Entry&lt;K,V&gt;接口）</strong>实现，HashMap 通过 put &amp; get 方法存储和获取。</p>
<p><strong>存储对象</strong>时，将 K/V 键值传给 put() 方法：1、调用 hash(K) 方法<strong>计算 K 的 hash 值</strong>，然后结合数组长度，计算得数组下标；2、<strong>调整数组大小</strong>（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；3、①.如果 <strong>K 的 hash 值</strong>在 HashMap 中<strong>不存在</strong>，则执行<strong>插入</strong>，若存在，则发生<strong>碰撞</strong>；<br> ② 如果 K 的 hash 值在 HashMap 中<strong>存在</strong>，且它们两者 <strong>equals 返回 true</strong>，则<strong>更新键值对</strong>；<br> ③ 如果 K 的 hash 值在 HashMap 中<strong>存在</strong>，且它们两者 <strong>equals 返回 false</strong>，则<strong>插入链表的尾部（尾插法）或者红黑树中（树的添加方式）</strong>。</p>
<p>（<strong>JDK 1.7</strong> 之前使用<strong>头插法</strong>、<strong>JDK 1.8</strong> 使用<strong>尾插法</strong>） （注意：当碰撞导致链表大于 TREEIFY_THRESHOLD =  8 且元素个数大于 64 时，就把链表转换成红黑树）</p>
<p><strong>获取对象</strong>时，将 K 传给 get() 方法：①、调用 hash(K) 方法（<strong>计算 K 的 hash 值</strong>）从而<strong>获取该键值所在链表的数组下标</strong>；②、顺序遍历链表，equals()方法查找<strong>相同 Node 链表中 K 值</strong>对应的 V 值。</p>
<p>hashCode 是定位的，<strong>存储位置</strong>；equals是定性的，<strong>比较两者是否相等</strong>。</p>
<h5 id="Q：当两个对象的hashCode相同会发生什么？"><a href="#Q：当两个对象的hashCode相同会发生什么？" class="headerlink" title="Q：当两个对象的hashCode相同会发生什么？"></a>Q：当两个对象的hashCode相同会发生什么？</h5><p>A：因为 hashCode 相同，不一定就是相等的（equals 方法比较），所以两个对象所在数组的下标相同，就会发生<strong>“哈希碰撞”</strong>。因为 HashMap 使用<strong>链表</strong>存储对象，这个 Node 会存储到链表中。</p>
<h5 id="Q：知道HashMap中hash方法的实现吗？为什么要这样实现？"><a href="#Q：知道HashMap中hash方法的实现吗？为什么要这样实现？" class="headerlink" title="Q：知道HashMap中hash方法的实现吗？为什么要这样实现？"></a>Q：知道HashMap中hash方法的实现吗？为什么要这样实现？</h5><p>A：JDK 1.8 中，是通过 hashCode() 的<strong>==高 16 位异或低 16 位==</strong>实现的：<strong>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</strong>，主要是从速度，功效和质量来考虑的，<strong>减少系统的开销</strong>，也不会造成<strong>因为高位没有参与</strong>下标的计算，从而引起的<strong>碰撞</strong>。而且也是让高位和低位<strong>都参与</strong>哈希运算，减少哈希碰撞。</p>
<h5 id="Q：hash方法为什么要用异或运算符？"><a href="#Q：hash方法为什么要用异或运算符？" class="headerlink" title="Q：hash方法为什么要用异或运算符？"></a>Q：hash方法为什么要用异或运算符？</h5><p>A：保证了对象的 hashCode 的 32 位值只要有一位发生改变，整个 hash() 返回值就会改变。尽可能的<strong>减少碰撞</strong>。</p>
<h5 id="Q：HashMap的table的容量如何确定？loadFactor是什么？-该容量如何变化？这种变化会带来什么问题？"><a href="#Q：HashMap的table的容量如何确定？loadFactor是什么？-该容量如何变化？这种变化会带来什么问题？" class="headerlink" title="Q：HashMap的table的容量如何确定？loadFactor是什么？ 该容量如何变化？这种变化会带来什么问题？"></a>Q：HashMap的table的容量如何确定？loadFactor是什么？ 该容量如何变化？这种变化会带来什么问题？</h5><p>A：1、<strong>table 数组大小</strong>是由 <strong>capacity</strong> 这个参数确定的，默认是<strong>16</strong>，也可以构造时传入，最大限制是 1&lt;&lt;30；且必须为 2 的幂次方。<br> 2、<strong>loadFactor 是装载因子</strong>，主要目的是用来<strong>确认table 数组是否需要动态扩展</strong>，默认值是 <strong>0.75</strong>，比如 table 数组大小为 16，装载因子为 0.75 时，<strong>threshold</strong> 就是12，当 table 的实际大小超过 12 时，table 就需要<strong>动态扩容</strong>；<br> 3、扩容时，调用 resize() 方法，将 <strong>table 长度变为原来的两倍</strong>（注意是 <strong>table 长度</strong>，而不是 threshold）<br> 4、如果数据很大的情况下，扩展时将会带来性能的损失，在性能要求很高的地方，这种损失很可能很致命。</p>
<h5 id="Q：HashMap和HashTable有什么区别？"><a href="#Q：HashMap和HashTable有什么区别？" class="headerlink" title="Q：HashMap和HashTable有什么区别？"></a>Q：HashMap和HashTable有什么区别？</h5><p>A：1、<strong>HashMap</strong> 是线程不安全的，<strong>HashTable</strong> 是<strong>线程安全</strong>的；<br> 2、由于线程安全，所以 HashTable 的效率比不上 HashMap；<br> 3、<strong>HashMap</strong>最多只允许<strong>一条记录的键为null</strong>，允许<strong>多条记录的值为null</strong>，而 <strong>HashTable</strong> 不允许；<br> 4、<strong>HashMap</strong> 默认初始化数组的大小为<strong>16</strong>，<strong>HashTable</strong> 为 <strong>11</strong>，前者扩容时，扩大<strong>两倍</strong>，后者<strong>扩大两倍+1</strong>；<br> 5、HashMap 扩容时需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode。</p>
<h5 id="Q：Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，它与HashTable在线程同步上有什么不同？"><a href="#Q：Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，它与HashTable在线程同步上有什么不同？" class="headerlink" title="Q：Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，它与HashTable在线程同步上有什么不同？"></a>Q：Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，它与HashTable在线程同步上有什么不同？</h5><p>A：<strong>ConcurrentHashMap</strong> 类（是 Java并发包 java.util.concurrent 中提供的一个<strong>线程安全且高效</strong>的 HashMap 实现）。<br> <strong>HashTable</strong> 是使用 <strong>synchronize</strong> 关键字加锁的原理（就是对<strong>对象</strong>加锁）； 而 <strong>ConcurrentHashMap</strong> 在 <strong>JDK 1.7</strong> 中采用 <strong>分段锁</strong>的方式；<strong>JDK 1.8</strong> 中直接采用了<strong>CAS（无锁算法）+ synchronized</strong>。</p>
<h5 id="Q：HashMap-amp-ConcurrentHashMap的区别？"><a href="#Q：HashMap-amp-ConcurrentHashMap的区别？" class="headerlink" title="Q：HashMap&amp;ConcurrentHashMap的区别？"></a>Q：HashMap&amp;ConcurrentHashMap的区别？</h5><p>A：除了<strong>加锁</strong>，原理上无太大区别。ConcurrentHashMap 是<strong>线程安全</strong>的。不过在进行扩容的时候，多余的线程会帮助进行数据转移。</p>
<p>另外，<strong>HashMap 的键值对允许有 null，但是 ConCurrentHashMap 都不允许</strong>。</p>
<h5 id="Q：为什么ConcurrentHashMap比HashTable效率要高？"><a href="#Q：为什么ConcurrentHashMap比HashTable效率要高？" class="headerlink" title="Q：为什么ConcurrentHashMap比HashTable效率要高？"></a>Q：为什么ConcurrentHashMap比HashTable效率要高？</h5><p>A：<strong>HashTable</strong> 使用<strong>一把锁（锁住整个链表结构）</strong>处理并发问题，多个线程竞争一把锁，容易<strong>阻塞</strong>；HashTable <strong>锁的粒度太大了。</strong></p>
<p><strong>ConcurrentHashMap</strong>：<strong>JDK 1.7</strong> 中使用<strong>分段锁（ReentrantLock + Segment + HashEntry）</strong>，相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：<strong>基于 Segment</strong>，包含多个 HashEntry。<br> <strong>JDK 1.8</strong> 中使用 <strong>CAS + synchronized + Node + 红黑树</strong>。锁粒度：<strong>Node（首结点）</strong>（实现 Map.Entry&lt;K,V&gt;）。锁粒度降低了。</p>
<h5 id="Q：Java1-7和1-8的HashMap的不同点？"><a href="#Q：Java1-7和1-8的HashMap的不同点？" class="headerlink" title="Q：Java1.7和1.8的HashMap的不同点？"></a>Q：Java1.7和1.8的HashMap的不同点？</h5><p>A：1、JDK1.7 用的是<strong>头插法</strong>，而 JDK1.8 及之后使用的都是<strong>尾插法</strong>，那么为什么要这样做呢？因为 JDK1.7 是用单链表进行的纵向延伸，当采用头插法就是能够提高插入的效率，但是也会容易出现<strong>逆序且环形链表死循环</strong>问题。但是在 JDK1.8 之后是因为加入了<strong>红黑树使用尾插法</strong>，能够避免<strong>出现逆序且链表死循环</strong>的问题。</p>
<p>2、<strong>扩容</strong>后<strong>数据存储位置</strong>的计算方式也不一样：</p>
<p>① 在 JDK1.7 的时候是<strong>直接用 hash 值</strong>和需要扩容的二进制数进行 &amp;（这里就是为什么扩容的时候为啥一定必须是 2 的多少次幂的原因所在，因为如果只有 2 的 n 次幂的情况时最后一位二进制数才一定是 1，这样能最大程度减少hash 碰撞）（hash 值 &amp; length-1） 。</p>
<p>② 而在 JDK1.8 的时候直接用了 JDK1.7 的时候<strong>计算的规律</strong>，也就是扩容前的原始位置 + 扩容的大小值 = JDK1.8 的计算方式，而不再是 JDK1.7 的那种异或的方法。但是这种方式就相当于只需要判断 Hash 值的新增参与运算的位是 0 还是 1 就直接迅速计算出了扩容后的储存方式。</p>
<p>3、JDK1.7 的时候使用的是<strong>数组 + 单链表</strong>的数据结构。但是在 JDK1.8 及之后时，使用的是<strong>数组 + 链表 + 红黑树</strong>的数据结构（当链表的深度达到 8 的时候，也就是默认阈值，就会<strong>自动扩容把链表转成红黑树的数据结构</strong>来把时间复杂度从O（N）变成O（<strong>logN</strong>）提高了效率）。</p>
<h5 id="Q：JDK7-HashMap多线程操作导致死循环问题？"><a href="#Q：JDK7-HashMap多线程操作导致死循环问题？" class="headerlink" title="Q：JDK7 HashMap多线程操作导致死循环问题？"></a>Q：JDK7 HashMap多线程操作导致死循环问题？</h5><p>主要原因在于<strong>并发</strong>下的 <strong>Rehash</strong> 可能会造成元素之间会<strong>形成一个循环链表</strong>。不过，JDK1.8 <strong>后解决了这个问题</strong>，但是还是不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如<strong>数据丢失</strong>。并发环境下推荐使用 ConcurrentHashMap 。</p>
<p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a></p>
<h5 id="Q：构造相同Hash的字符串进行攻击，这种情况应该怎么处理？"><a href="#Q：构造相同Hash的字符串进行攻击，这种情况应该怎么处理？" class="headerlink" title="Q：构造相同Hash的字符串进行攻击，这种情况应该怎么处理？"></a>Q：构造相同Hash的字符串进行攻击，这种情况应该怎么处理？</h5><p><strong>攻击原理：</strong></p>
<p>当客户端发送一个请求到服务器，如果该请求中带有<strong>参数</strong>，服务器端会将 <strong>参数名-参数值</strong> 作为 key-value 保存在 <strong>HashMap</strong> 中。如果有人恶意构造请求，在请求中加入<strong>大量相同</strong> hash 值的 String 参数名（key），那么在服务器端用于存储这些 key-value 对的 HashMap 会被强行退化成链表，如图：</p>
<img src="assets/hash-to-badlink.png" alt="1567478530282"  />

<p>如果数据量足够大，那么在查找，插入时会占用大量 CPU，达到拒绝服务攻击的目的。</p>
<p> <strong>怎么处理</strong></p>
<ol>
<li>限制 POST 和 GET 请求的参数个数。</li>
<li>限制 POST 请求的请求体大小。</li>
<li>Web Application FireWall（WAF）。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/C-1%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/" rel="next" title="ShiftJava/A Java/C-1 多线程基础">
                <i class="fa fa-chevron-left"></i> ShiftJava/A Java/C-1 多线程基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/C%20%E5%B9%B6%E5%8F%91/" rel="prev" title="ShiftJava/A Java/C 并发">
                ShiftJava/A Java/C 并发 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#集合面试题"><span class="nav-number">1.</span> <span class="nav-text">集合面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap"><span class="nav-number">1.1.</span> <span class="nav-text">HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：HashMap的数据结构？"><span class="nav-number">1.1.1.</span> <span class="nav-text">Q：HashMap的数据结构？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：HashMap的工作原理？"><span class="nav-number">1.1.2.</span> <span class="nav-text">Q：HashMap的工作原理？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：当两个对象的hashCode相同会发生什么？"><span class="nav-number">1.1.3.</span> <span class="nav-text">Q：当两个对象的hashCode相同会发生什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：知道HashMap中hash方法的实现吗？为什么要这样实现？"><span class="nav-number">1.1.4.</span> <span class="nav-text">Q：知道HashMap中hash方法的实现吗？为什么要这样实现？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：hash方法为什么要用异或运算符？"><span class="nav-number">1.1.5.</span> <span class="nav-text">Q：hash方法为什么要用异或运算符？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：HashMap的table的容量如何确定？loadFactor是什么？-该容量如何变化？这种变化会带来什么问题？"><span class="nav-number">1.1.6.</span> <span class="nav-text">Q：HashMap的table的容量如何确定？loadFactor是什么？ 该容量如何变化？这种变化会带来什么问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：HashMap和HashTable有什么区别？"><span class="nav-number">1.1.7.</span> <span class="nav-text">Q：HashMap和HashTable有什么区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，它与HashTable在线程同步上有什么不同？"><span class="nav-number">1.1.8.</span> <span class="nav-text">Q：Java中的另一个线程安全的与HashMap极其类似的类是什么？同样是线程安全，它与HashTable在线程同步上有什么不同？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：HashMap-amp-ConcurrentHashMap的区别？"><span class="nav-number">1.1.9.</span> <span class="nav-text">Q：HashMap&amp;ConcurrentHashMap的区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：为什么ConcurrentHashMap比HashTable效率要高？"><span class="nav-number">1.1.10.</span> <span class="nav-text">Q：为什么ConcurrentHashMap比HashTable效率要高？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：Java1-7和1-8的HashMap的不同点？"><span class="nav-number">1.1.11.</span> <span class="nav-text">Q：Java1.7和1.8的HashMap的不同点？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：JDK7-HashMap多线程操作导致死循环问题？"><span class="nav-number">1.1.12.</span> <span class="nav-text">Q：JDK7 HashMap多线程操作导致死循环问题？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Q：构造相同Hash的字符串进行攻击，这种情况应该怎么处理？"><span class="nav-number">1.1.13.</span> <span class="nav-text">Q：构造相同Hash的字符串进行攻击，这种情况应该怎么处理？</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
