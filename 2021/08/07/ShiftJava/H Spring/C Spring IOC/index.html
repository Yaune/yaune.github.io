<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] Spring IOC在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。而 bean 的定义以及 bean 相互间的依赖关系将通过配置元数据来描述。 控制反转IOC1. 谈谈对IOC的理解？IoC（Inv">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;H Spring&#x2F;C Spring IOC">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] Spring IOC在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。而 bean 的定义以及 bean 相互间的依赖关系将通过配置元数据来描述。 控制反转IOC1. 谈谈对IOC的理解？IoC（Inv">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;ioc1.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;ioc2.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;ioc3.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;1573547101474.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;image-20200803144915470.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;image-20200803145712274.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;1564994604731.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;1564994754829.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;image-20200528144152364.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;JavaNotes&#x2F;H%20Spring&#x2F;assets&#x2F;image-20200528144205341.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;1573540627894.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;1573545313232.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;H%20Spring&#x2F;C%20Spring%20IOC&#x2F;assets&#x2F;ioc1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/H Spring/C Spring IOC/"/>





  <title>ShiftJava/H Spring/C Spring IOC | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/H%20Spring/C%20Spring%20IOC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/H Spring/C Spring IOC</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:17+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><p>在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 <strong>bean</strong>。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。而 bean 的定义以及 bean 相互间的依赖关系将通过配置元数据来描述。</p>
<h4 id="控制反转IOC"><a href="#控制反转IOC" class="headerlink" title="控制反转IOC"></a>控制反转IOC</h4><h5 id="1-谈谈对IOC的理解？"><a href="#1-谈谈对IOC的理解？" class="headerlink" title="1. 谈谈对IOC的理解？"></a>1. 谈谈对IOC的理解？</h5><p>IoC（Inverse of Control 控制反转）是一种<strong>设计思想</strong>，就是<strong>将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</strong>IoC 在其他语言中也有应用并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象</strong>。</p>
<p><strong>控制</strong>就是开发人员本来可以<strong>控制</strong>对象的<strong>创建、管理</strong>过程，<strong>反转</strong>就是将这个<strong>权利交给外部的环境</strong>去实现，比如 IOC 容器。反转之后失去了创建管理对象的权利，但是可以<strong>不用再考虑对象的创建、管理等一系列的事情</strong>。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。</p>
<p>将对象之间的<strong>相互依赖关系</strong>交给 IoC 容器来管理，并由 IoC 容器完成对象的<strong>注入</strong>。  <strong>IoC 容器就像是一个工厂一样，当需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如需要实例化这个 Service，可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，就只需要<strong>完成配置然后在需要的地方引用</strong>就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>例如：现有类 A 依赖于类 B：</p>
<ul>
<li><strong>传统的开发方式</strong> ：在类 A 中手动 new 出一个 B 的对象出来。</li>
<li><strong>使用 IoC 思想的开发方式</strong> ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来生成实例化对象。需要哪个对象，<strong>直接从 IoC 容器里面获取</strong>即可。</li>
</ul>
<h5 id="2-控制反转的好处"><a href="#2-控制反转的好处" class="headerlink" title="2. 控制反转的好处"></a>2. 控制反转的好处</h5><p>IoC 的思想就是两方之间<strong>不互相依赖</strong>，由第三方容器来管理相关资源。这样做的好处在于：</p>
<ol>
<li>对象之间的<strong>耦合度</strong>或者说依赖程度降低；</li>
<li>资源变的<strong>容易管理</strong>；</li>
<li>降低了项目的开发难度并增加了可维护性。</li>
</ol>
<h5 id="3-IOC与DI的关系"><a href="#3-IOC与DI的关系" class="headerlink" title="3. IOC与DI的关系"></a>3. IOC与DI的关系</h5><ul>
<li><p>IOC 是一种<strong>设计思想</strong>，这个设计思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p>
</li>
<li><p>DI 是<strong>依赖注入</strong>，向<strong>类里面属性注入值</strong>。<strong>依赖注入</strong>是 IOC 最常见以及最合理的<strong>实现方式</strong>。<strong>依赖注入不能单独存在，需要在 IOC 基础上完成操作</strong>。</p>
</li>
</ul>
<h5 id="4-依赖倒置原则"><a href="#4-依赖倒置原则" class="headerlink" title="4. 依赖倒置原则"></a>4. 依赖倒置原则</h5><p>假设设计一辆汽车：先设计轮子，然后根据轮子大小设计底盘，接着根据底盘设计车身，最后根据车身设计好整个汽车。这里就出现了一个<strong>“依赖”关系</strong>：汽车依赖车身，车身依赖底盘，底盘依赖轮子。</p>
<img src="assets/ioc1.jpg"/>

<p>这样设计看起来没问题，但是可维护性却很低。假设设计完工之后上司却突然说根据市场需求的变动，要把车子的轮子设计都改大一码。这下就蛋疼了：因为是根据轮子的尺寸设计的底盘，轮子的尺寸一改，底盘的设计就得修改；同样因为是根据底盘设计的车身，那么车身也得改，同理汽车设计也得改：整个设计几乎都得改！</p>
<p>现在换一种思路。先设计汽车的<strong>大概样子</strong>，然后根据汽车的样子来设计车身，根据车身来设计底盘，最后根据底盘来设计轮子。这时候，<strong>依赖关系就倒置</strong>过来了：轮子依赖底盘， 底盘依赖车身， 车身依赖汽车。</p>
<img src="assets/ioc2.jpg"/>

<p>这时候上司再说要改动轮子的设计，<strong>就只需要改动轮子的设计</strong>，而不需要动底盘，车身，汽车的设计了。</p>
<p>这就是依赖倒置原则：<strong>把原本的高层建筑依赖底层建筑“倒置”过来，变成底层建筑依赖高层建筑</strong>。高层建筑决定需要什么，底层去实现这样的需求，但是高层并不用管底层是怎么实现的。这样就不会出现前面的“牵一发动全身”的情况。</p>
<p>这几种概念的关系如下：</p>
<img src="assets/ioc3.jpg" style="zoom:50%;" />

<h4 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h4><p><strong>Scope</strong> 用来声明容器中的<strong>对象</strong>所应该处的限定场景或者说该<strong>对象的存活时间</strong>，即容器在对象进入其相应的 scope 之前，生成并装配这些对象，在该对象不再处于这些 scope 的限定之后，容器通常会销毁 Spring 的 IoC 容器这些对象。</p>
<p><strong>Spring 的单例是基于 BeanFactory 也就是 Spring 容器的，单例 Bean 在此容器内只有一个，Java 的单例是基于 JVM，每个 JVM 内只有一个实例</strong>。</p>
<p>在大多数情况下单例 bean 是很理想的方案，不过有时候使用的类是<strong>易变</strong>的，它们<strong>会保持一些状态</strong>，因此重用是不安全的。在这种情况下将 class 声明为单例的就不是那么明智了。因为对象会被污染，所以 Spring 定义了多种作用域的bean。</p>
<h5 id="1-作用域分类"><a href="#1-作用域分类" class="headerlink" title="1. 作用域分类"></a>1. 作用域分类</h5><table>
<thead>
<tr>
<th align="center">Scope</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>singleton</strong></td>
<td align="center">（<strong>默认的</strong>）在每个 Spring IoC 容器中，一个 bean 定义对应只会有唯一一个 bean 实例</td>
</tr>
<tr>
<td align="center"><strong>prototype</strong></td>
<td align="center">一个 bean 定义可以有多个 bean 实例</td>
</tr>
<tr>
<td align="center"><strong>request</strong></td>
<td align="center">一个 bean 定义对应于单个 <strong>HTTP 请求</strong>的生命周期，仅适用于 <strong>WebApplicationContext</strong> 环境。</td>
</tr>
<tr>
<td align="center"><strong>session</strong></td>
<td align="center">一个 bean 定义对应于单个 <strong>HTTP Session</strong> 的生命周期。</td>
</tr>
<tr>
<td align="center">global session</td>
<td align="center">仅仅在基于 portlet 的 web 应用中才有意义</td>
</tr>
</tbody></table>
<p>五种作用域中，<strong>request、session</strong> 和 <strong>global session</strong> 三种作用域仅在基于 web 的应用中使用，只能用在基于 web 的 Spring ApplicationContext 环境。</p>
<h5 id="2-singleton"><a href="#2-singleton" class="headerlink" title="2. singleton"></a>2. singleton</h5><p>在 Spring 的 IoC 容器中只存在<strong>一个实例</strong>，所有对该对象的引用将<strong>共享</strong>这个实例。该实例从容器<strong>启动</strong>，并因为第一次被请求而初始化之后，将一直存活到容器退出，它与 IoC 容器“几乎”拥有相同的生命周期。标记为 singleton 的 bean 是由容器来保证这种类型的 bean 在<strong>同一个容器中</strong>只存在一个共享实例；而 Singleton 模式则是保证在同一个 <strong>Classloader</strong> <strong>中</strong>只存在一个这种类型的实例。</p>
<p>在<strong>不指定 @Scope</strong> 的情况下，<strong>所有</strong>的 bean 都是<strong>单实例</strong>的 bean, 而且是<strong>==饿汉加载==</strong>，也就是容器启动就进行实例创建。</p>
<p>如果对 singleton 的 bean 指定为 <strong>@Lazy 懒加载</strong>，那么容器启动的时候就<strong>不创建对象</strong>，而在<strong>第一次使用</strong>的时候才会创建该对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Spring中的单例bean的线程安全问题</strong></p>
</blockquote>
<p>单例 bean <strong>存在线程问题</strong>，主要是因为当<strong>多个</strong>线程操作<strong>同一个对象</strong>的时候，对这个对象的<strong>非静态成员变量的写操作</strong>会存在线程安全问题。常见的有两种解决办法：</p>
<ol>
<li><p>在 Bean 对象中尽量避免定义可变的成员变量（不太现实）。</p>
</li>
<li><p>在<strong>类</strong>中定义一个 <strong>ThreadLocal</strong> 成员变量，将需要的<strong>==可变成员变量==保存在 ThreadLocal 中</strong>（推荐的一种方式）。</p>
</li>
</ol>
<h5 id="3-prototype"><a href="#3-prototype" class="headerlink" title="3. prototype"></a>3. prototype</h5><p>当一个 bean 的作用域为 prototype 时，表示一个 bean <strong>定义</strong>对应<strong>多个对象实例</strong>。 prototype 作用域的 bean 会导致在每次对该 bean 请求（将其<strong>注入</strong>到另一个 bean 中，或者以程序的方式调用容器的 getBean() 方法）时都会<strong>创建一个新</strong>的 bean 实例。prototype 是原型类型，在<strong>创建容器的时候并没有实例化</strong>，而是<strong>当获取 bean 的时候才会去创建一个对象</strong>，而且每次获取到的对象是一个<strong>新的对象</strong>。</p>
<p>虽然这种类型的对象的<strong>实例化以及属性设置</strong>等工作都是由<strong>容器负责</strong>的，但是只要准备完毕，并且对象实例返回给请求方之后，<strong>容器就不再拥有当前返回对象的引用</strong>，请求方需要<strong>自己负责</strong>当前返回对象的后继生命周期的管理工作，包括该对象的销毁。</p>
<p>根据经验，对<strong>==有状态的== bean 应该使用 prototype 作用域</strong>（比如保存每个顾客信息的对象），而对无状态的 bean 则应该使用 singleton 作用域。  在 XML 中将 bean 定义成 prototype ，可以这样配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"account"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.foo.DefaultAccount"</span> scope=<span class="string">"prototype"</span>/&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"account"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.foo.DefaultAccount"</span> singleton=<span class="string">"false"</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>也可通过 <strong>@Scope 注解</strong>进行配置。</p>
<p>singleton 与 prototype 用法最大区别：<strong>有无状态</strong>。</p>
<h5 id="4-request"><a href="#4-request" class="headerlink" title="4. request"></a>4. request</h5><p>每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP request 内有效。<strong>request 只适用于 Web 程序，每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP request 内有效，当请求结束后，该对象的生命周期即告结束。</strong> 在 XML 中将 bean 定义成 request ，可以这样配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"loginAction"</span> <span class="class"><span class="keyword">class</span></span>=cn.csdn.LoginAction<span class="string">" scope="</span>request<span class="string">"/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="5-session"><a href="#5-session" class="headerlink" title="5. session"></a>5. session</h5><p><strong>会话</strong>：用户打开浏览器会话开始，直到关闭浏览器会话才会结束。一次会话期间只会创建一个 session 对象。服务器会为每个会话创建一个 session 对象，所以 session 中的数据可供当前会话中所有 servlet 共享。</p>
<p>每一次 HTTP 请求都会产生一个新的 bean，该 bean 仅在当前 HTTP session 内有效。session 只适用于 Web 程序，session 作用域表示该针对每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在<strong>当前 HTTP session 内有效</strong>。与 request 作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的 HTTP session 中根据 userPreferences 创建的实例，将不会看到这些特定于某个 HTTP session 的状态变化。当 HTTP session 最终被废弃的时候，在该 HTTP session 作用域内的 bean 也会被废弃掉。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userPreferences"</span> <span class="attr">class</span>=<span class="string">"com.foo.UserPreferences"</span> <span class="attr">scope</span>=<span class="string">"session"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="6-globalSession"><a href="#6-globalSession" class="headerlink" title="6. globalSession"></a>6. globalSession</h5><p>global session 作用域类似于标准的 HTTP session 作用域，不过仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session  作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.foo.Preferences "</span><span class="attr">scope</span>=<span class="string">"globalSession"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="7-Scope注解"><a href="#7-Scope注解" class="headerlink" title="7. @Scope注解"></a>7. @Scope注解</h5><p>如下所示为一个 POJO 类使用 @Scope 注解。使用 <strong>ConfigurableBeanFactory</strong> 只能提供单例 (SCOPE_SINGLETON) 和原型 (SCOPE_PROTOTYPE)。在 <strong>MVC</strong> 中，还可以使用 WebApplicationContext 去提供 MVC 下特有的<strong>作用域</strong>形式，如请求（SCOPE_REQUEST），会话（SCOPE_SESSION）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Profile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_SINGLETON)  	<span class="comment">// 设置bean作用域</span></span><br><span class="line"><span class="comment">// @Scope(WebApplicationContext.SCOPE_REQUSET)  	// 设置bean作用域(For MVC)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Bean的装配与注册"><a href="#Bean的装配与注册" class="headerlink" title="Bean的装配与注册"></a>Bean的装配与注册</h4><p>Spring 为实现 Bean 的信息定义，提供了<strong>基于注解、基于配置类、基于 XML、基于 Groovy</strong> 这几种 bean <strong>装配方式</strong>，各种配置方式可混合使用。基于 XML 与 Groovy 配置这里就不涉及了。 </p>
<h5 id="1-基于配置类的装配"><a href="#1-基于配置类的装配" class="headerlink" title="1. 基于配置类的装配"></a>1. 基于配置类的装配</h5><p>通过<strong>配置类</strong>对一个 bean 进行装配。</p>
<ul>
<li>@<strong>Configuration</strong> 说明为一个<strong>配置类</strong>。</li>
<li>@<strong>ComponentScan</strong> 标明采用何种策略去<strong>扫描装配</strong> Bean，默认扫描配置类当前所在的包及其子包。可以自定义扫描路径。</li>
<li>将 <strong>@Bean</strong> 标注方法返回的 bean 装配到 IOC 容器中。</li>
</ul>
<p>看一个关于数据源的 Bean 装配的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.springboot.chapter3.*"</span>) </span><br><span class="line"><span class="meta">@ImportResource</span>(value = &#123;<span class="string">"classpath:spring-other.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Bean</span>(name = <span class="string">"dataSource"</span>, destroyMethod = <span class="string">"close"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">getDevDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">		props.setProperty(<span class="string">"driver"</span>, <span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">		props.setProperty(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://localhost:3306/dev_spring_boot"</span>);</span><br><span class="line">		props.setProperty(<span class="string">"username"</span>, <span class="string">"root"</span>);</span><br><span class="line">		props.setProperty(<span class="string">"password"</span>, <span class="string">"123456"</span>);</span><br><span class="line">		DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			dataSource = BasicDataSourceFactory.createDataSource(props);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-基于注解的装配"><a href="#2-基于注解的装配" class="headerlink" title="2. 基于注解的装配"></a>2. 基于注解的装配</h5><p>定义一个 POJO 类，直接在此类里面<strong>注入属性</strong>。</p>
<ul>
<li>@<strong>Component</strong> 标明这个类被装配到容器中。</li>
<li>@<strong>Value</strong> 字段中注入<strong>属性值</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定user为bean名称 如果不指定则把类名首字母小写当做类名称</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"user"</span>)      </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @Value注入属性值</span></span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"1"</span>)         </span><br><span class="line">	<span class="keyword">private</span> Long id;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"user_name_1"</span>)</span><br><span class="line">	<span class="keyword">private</span> String userName;</span><br><span class="line">	<span class="meta">@Value</span>(<span class="string">"note_1"</span>)</span><br><span class="line">	<span class="keyword">private</span> String note;</span><br><span class="line">	<span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-装配方式对比"><a href="#3-装配方式对比" class="headerlink" title="3. 装配方式对比"></a>3. 装配方式对比</h5><p>几种配置方式对比：</p>
<p><img src="assets/1573547101474.png" alt="1573547101474"></p>
<h5 id="4-Conditional条件装配Bean"><a href="#4-Conditional条件装配Bean" class="headerlink" title="4. @Conditional条件装配Bean"></a>4. @Conditional条件装配Bean</h5><p><strong>满足一定条件才装配 Bean 否则不装配</strong>，比如数据库配置信息不全就不装配。@Conditional 注解用于条件装配 Bean，需要<strong>配合 Condition 接口</strong>使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"com.springboot.chapter3.*"</span>)</span><br><span class="line"><span class="meta">@ImportResource</span>(value = &#123;<span class="string">"classpath:spring-other.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Bean</span>(name = <span class="string">"dataSource"</span>, destroyMethod = <span class="string">"close"</span>)</span><br><span class="line">    <span class="comment">// 传入的类需实现Condition接口</span></span><br><span class="line">	<span class="meta">@Conditional</span>(DatabaseConditional<span class="class">.<span class="keyword">class</span>)      </span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">DataSource</span> <span class="title">getDataSource</span>(            </span></span><br><span class="line"><span class="class">        // 使用@<span class="title">Value</span>去取配置文件中的值并注入</span></span><br><span class="line">			@Value("$&#123;database.driverName&#125;") String driver,</span><br><span class="line">			<span class="meta">@Value</span>(<span class="string">"$&#123;database.url&#125;"</span>) String url,</span><br><span class="line">			<span class="meta">@Value</span>(<span class="string">"$&#123;database.username&#125;"</span>) String username, </span><br><span class="line">			<span class="meta">@Value</span>(<span class="string">"$&#123;database.password&#125;"</span>) String password</span><br><span class="line">		) &#123;</span><br><span class="line">		Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">		props.setProperty(<span class="string">"driver"</span>, driver);</span><br><span class="line">		props.setProperty(<span class="string">"url"</span>, url);</span><br><span class="line">		props.setProperty(<span class="string">"username"</span>, username);</span><br><span class="line">		props.setProperty(<span class="string">"password"</span>, password);</span><br><span class="line">		DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			dataSource = BasicDataSourceFactory.createDataSource(props);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> dataSource;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的 <strong>@Conditional(DatabaseConditional.class)</strong> 传入了 DatabaseConditional 类，传入 @Conditional 注解的<strong>类需要实现 Condition 接口</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Condition;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ConditionContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.type.AnnotatedTypeMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseConditional</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 数据库装配条件 不符合条件的就不装配</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context 条件上下文</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">		Environment env = context.getEnvironment();</span><br><span class="line">        <span class="comment">// 此处是判断条件</span></span><br><span class="line">		<span class="keyword">return</span> env.containsProperty(<span class="string">"database.driverName"</span>) &amp;&amp; env.containsProperty(<span class="string">"database.url"</span>) </span><br><span class="line">				&amp;&amp; env.containsProperty(<span class="string">"database.username"</span>) &amp;&amp; env.containsProperty(<span class="string">"database.password"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有满足了<strong>上述自定义的条件</strong>，才会<strong>装配</strong> DataSource 。</p>
<h5 id="5-装配导入组件的注解"><a href="#5-装配导入组件的注解" class="headerlink" title="5. 装配导入组件的注解"></a>5. 装配导入组件的注解</h5><p>往 IOC 容器<strong>添加组件</strong>的注解主要有下面。</p>
<p><strong>(1)</strong> 通过 <strong>@ComponentScan + @Controller @Service @Respository @Component</strong>。适用场景: 将<strong>自己写的组件</strong>加载到容器中。</p>
<p>一般使用 <strong>@Autowired</strong> 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类，采用以下注解可实现：</p>
<ul>
<li>@<strong>Component</strong> ：通用的注解，可标注<strong>任意类</strong>为 Spring 组件。如果一个 Bean <strong>不知道</strong>属于哪个层，可以使用@Component 注解标注。</li>
<li>@<strong>Repository</strong> : 对应<strong>持久层</strong>即 Dao 层，主要用于数据库相关操作。</li>
<li>@<strong>Service</strong> : 对应<strong>服务层</strong>，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li>@<strong>Controller</strong> : 对应 Spring MVC <strong>控制层</strong>，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<p><strong>(2)</strong> 通过 <strong>@Bean</strong> 的方式来导入组件(适用于导入<strong>第三方组件</strong>的类)。</p>
<blockquote>
<p><strong>@Component和@Bean的区别是什么？</strong></p>
</blockquote>
<ul>
<li>作用对象不同：@Component 注解作用于<strong>类</strong>，而 @Bean 注解作用于<strong>方法</strong>。</li>
<li>@Component 通常是通过<strong>类路径扫描</strong>来自动侦测以及自动装配到 Spring 容器中（可以使用 @ComponentScan 注解定义要扫描的路径从中找出<strong>标识了需要装配的类</strong>自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是在标有该注解的方法中<strong>定义产生这个 bean</strong>，@Bean告诉了 Spring 这是某个类的示例，当需要用它的时候还给我。</li>
<li>@Bean 注解比 Component 注解的自定义性更强，而且很多地方只能通过 <strong>@Bean 注解来注册 bean</strong>。比如引用<strong>第三方库</strong>中的类需要装配到 Spring 容器时，则只能通过 @Bean 来实现。</li>
</ul>
<p><strong>(3)</strong> 通过 <strong>@Import</strong> 来<strong>导入组件</strong> （导入组件的 id 为全类名路径），也可以导入<strong>第三方</strong>组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(value = &#123;Person<span class="class">.<span class="keyword">class</span>, <span class="title">Car</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <strong>@Import 的 ImportSeletor 类</strong>实现组件的导入 (导入组件的 id 为全类名路径)  。<strong>自动装配</strong>原理经常使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TulingImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以获取导入类的注解信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"com.tuling.testimport.compent.Dog"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用这个 TulingImportSelector。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(value = &#123;Person<span class="class">.<span class="keyword">class</span>, <span class="title">Car</span>.<span class="title">class</span>, <span class="title">TulingImportSelector</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 @Import 的 <strong>ImportBeanDefinitionRegister</strong> 导入组件 (可以指定 bean 的名称）。Bean <strong>定义注册器</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TulingBeanDefinitionRegister</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个bean定义对象</span></span><br><span class="line">        RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(Cat<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 把bean定义对象导入到容器中</span></span><br><span class="line">        registry.registerBeanDefinition(<span class="string">"cat"</span>, rootBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//@Import(value = &#123;Person.class, Car.class&#125;)</span></span><br><span class="line"><span class="comment">//@Import(value = &#123;Person.class, Car.class, TulingImportSelector.class&#125;)</span></span><br><span class="line"><span class="meta">@Import</span>(value = &#123;Person<span class="class">.<span class="keyword">class</span>, <span class="title">Car</span>.<span class="title">class</span>, <span class="title">TulingImportSelector</span>.<span class="title">class</span>, <span class="title">TulingBeanDefinitionRegister</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(4)</strong> 通过实现 <strong>FacotryBean 接口</strong>来实现添加组件。整合<strong>第三方的复杂初始化对象</strong>。典型的是 <strong>SqlSessionFactoryBean</strong> 组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 返回bean的对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 返回bean的类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Car<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 是否为单例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入这个组件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(locations = &#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CarFactoryBean <span class="title">carFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CarFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h4><h5 id="1-Value注解设置属性"><a href="#1-Value注解设置属性" class="headerlink" title="1. @Value注解设置属性"></a>1. @Value注解设置属性</h5><p>使用 <strong>@Value 注解</strong>可以注入为 <strong>bean 设置属性</strong>，@Value 内可以直接设置属性值，也可以使用 Spring 表达式，也可以引用配置文件中的属性值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过普通的方式</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"Tom"</span>)</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="comment">// spel方式来赋值</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;28-8&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// 通过读取外部配置文件的值</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.lastName&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-属性配置文件"><a href="#2-属性配置文件" class="headerlink" title="2. 属性配置文件"></a>2. 属性配置文件</h5><h6 id="1-application-properties"><a href="#1-application-properties" class="headerlink" title="(1) application.properties"></a>(1) application.properties</h6><p>是<strong>默认</strong>的配置文件，<strong>yml 文件</strong>也是类似的效果。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># application.properties中</span></span><br><span class="line"><span class="meta">database.url</span> = <span class="string">jdbc:mysql://localhost:3306/test_db</span></span><br><span class="line"><span class="meta">database.username</span> = <span class="string">root</span></span><br><span class="line"><span class="meta">database.password</span> = <span class="string">123456</span></span><br></pre></td></tr></table></figure>

<p>可以在类中注入属性文件中的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseProperties</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;database.url&#125;"</span>)   <span class="comment">// 此处引用配置文件中的属性并注入</span></span><br><span class="line">    <span class="keyword">private</span> String url = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果都用上述的方法可能需要写很多次，因此可以用如下方法直接指定属性文件中的值，如 database，然后用<strong>全限定名</strong>去定位值，如 database.url。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"database"</span>)    <span class="comment">// 使用此注解传入字符串database，会去配置文件寻找对应的属性自动注入</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseProperties</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String url = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-自定义属性配置文件"><a href="#2-自定义属性配置文件" class="headerlink" title="(2) 自定义属性配置文件"></a>(2) 自定义属性配置文件</h6><p>如把数据库连接信息放入 <strong>jdbc.properties</strong> 中，然后使用 <strong>@PropertySource</strong> 去定义对应的<strong>属性配置文件</strong>, <strong>@PropertySource</strong> 注解需要在配置类中标注，value 值可以有多个。ignoreResourceNotFound 指示找不到文件就忽略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"com.springboot.chapter"</span>&#125;)</span><br><span class="line"> <span class="comment">// 指定配置文件路径</span></span><br><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:jdbc.properties"</span>&#125;, ignoreResourceNotFound = ture) </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IoCTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(IoCTest<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="依赖注入DI"><a href="#依赖注入DI" class="headerlink" title="依赖注入DI"></a>依赖注入DI</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p><strong>定义</strong>：在依赖注入的模式下，创建被调用者得工作不再由调用者来完成，创建被调用者实例的工作通常由 Spring 容器完成，然后注入调用者。<strong>创建对象时，向类里的属性设置值</strong>。</p>
<p>所谓依赖注入，就是把底层类作为参数传入上层类，实现上层类对下层类的控制。DI 依赖注入，向类里面属性注入值 ，依赖注入不能单独存在，需要在 IOC 基础上完成操作。</p>
<h5 id="2-依赖注入方式"><a href="#2-依赖注入方式" class="headerlink" title="2. 依赖注入方式"></a>2. 依赖注入方式</h5><p>一般而言，依赖注入可以分为 3 种方式。</p>
<ul>
<li><strong>构造器</strong>注入。</li>
<li><strong>setter</strong> 注入。</li>
<li>接口注入。</li>
<li><strong>注解</strong>注入(@Autowired) </li>
</ul>
<p><strong>构造器注入和 setter 注入和注解注入</strong>是主要的方式，而接口注入是从别的地方注入的方式。</p>
<h6 id="1-构造器注入"><a href="#1-构造器注入" class="headerlink" title="(1) 构造器注入"></a>(1) 构造器注入</h6><p>构造器注入<strong>依赖于构造方法</strong>实现，而构造方法可以是<strong>有参数的或者是无参数</strong>的。平时一般是通过类的构造方法来创建类对象，Spring 也可以采用<strong>反射的方式</strong>通过使用构造方法来完成注入，这就是构造器注入的原理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Role</span><span class="params">(String roleName, String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roleName = roleName;</span><br><span class="line">        <span class="keyword">this</span>.note = note;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/******** setter and getter *******/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候是<strong>没有办法利用无参数的构造方法</strong>去创建对象的，为了使 Spring 能够正确创建这个对象。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role1"</span> <span class="attr">class</span>=<span class="string">"com.nano.pojo.Role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"总经理"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"公司管理者"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>constructor-arg</strong> 元素用于定义类构造方法的<strong>参数</strong>，其中 <strong>index</strong> 用于定义参数的<strong>位置</strong>，而 value 则是<strong>设置值</strong>，通过这样的定义 Spring 便知道使用 Role(String,String) 这样的<strong>构造方法</strong>去创建对象了。这样注入比较简单的，但是缺点也很明显，如果参数很多，那么这种构造方法就比较复杂了，这个时候应该考虑 setter 注入。</p>
<h6 id="2-setter注入"><a href="#2-setter注入" class="headerlink" title="(2) setter注入"></a>(2) setter注入</h6><p>setter 注入利用 JavaBean 规范所定义的 setter 方法来完成注入，灵活且可读性高。它消除了使用构造器注入时出现<strong>多个参数的可能性</strong>，首先可以把构造方法声明为<strong>无参数</strong>的，然后使用 setter 注入为其设置对应的值，其实也是通过 Java <strong>反射技术得以现实</strong>的。这里假设先在代码清单中为 Role 类加入一个没有参数的构造方法，然后做代码清单的配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role2"</span> <span class="attr">class</span>=<span class="string">"com.nano.pojo.Role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"roleName"</span> <span class="attr">value</span>=<span class="string">"高级工程师"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">value</span>=<span class="string">"重要人员"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span></span></span><br></pre></td></tr></table></figure>

<p>这样 Spring 就会通过<strong>反射调用无参构造方法生成对象</strong>，同时通过反射对应的 setter 注入配置的值了。这种方式是基于 xml 配置时 Spring 最为主要的注入方式。</p>
<h6 id="3-接口注入"><a href="#3-接口注入" class="headerlink" title="(3) 接口注入"></a>(3) 接口注入</h6><p>有些时候资源<strong>并非来自于自身系统</strong>，而是来自于外界，比如数据库连接资源完全可以在 Tomcat 下配置，然后通过 JNDI 的形式去获取它，这样数据库连接资源是属于开发工程外的资源，这个时候可以采用接口注入的形式来获取它。</p>
<p>比如在 Web 工程中，配置的数据源往往是通过服务器（比如Tomcat）去配置的，这个时候可以用 JNDI 的形式通过接口将它注入 Spring IoC 容器中来。</p>
<h6 id="4-注解注入-Autowired与-Resource"><a href="#4-注解注入-Autowired与-Resource" class="headerlink" title="(4) 注解注入@Autowired与@Resource"></a>(4) 注解注入@Autowired与@Resource</h6><p>现在一般都用这个了吧。</p>
<blockquote>
<p><strong>注解@Autowired</strong></p>
</blockquote>
<p>getBean() 方法支持根据类型和名称来获取对应的 bean。@Autowired 注解首先根据类型去<strong>寻找对应的 bean</strong>，找不到再根据<strong>属性名称和 bean 名称</strong>来寻找 bean。默认必须找到对应 Bean，否则报错（可以使用 required = false 关闭必须装配）。</p>
<p>@Autowired 可以标注在<strong>属性</strong>上，也可以标注在方法上，还可以标注在入参上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span>	</span><br><span class="line"><span class="keyword">private</span> Animal animal = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnimal</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animal = animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BussinessPerson</span><span class="params">(@Autowired Animal animal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.animal = animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用@Primary与@Qualifier消除歧义问题</strong></p>
</blockquote>
<p>两个接口：动物与人接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnimal</span><span class="params">(Animal animal)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现接口：</p>
<p><strong>狗类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println("狗【" + Dog.class.getSimpleName()+"】是看门用的。");</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BussinessPerson</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="comment">// 自动注入实现了动物接口的类</span></span><br><span class="line">    <span class="meta">@Autowired</span>	</span><br><span class="line">    <span class="keyword">private</span> Animal animal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.animal.use();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnimal</span><span class="params">(Animal animal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.animal = animal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述 BussinessPerson 中自动注入实现了 Animal 接口的类，此时容器中实现了 Animal 接口的<strong>只有 Dog 类</strong>，因此成功注入 Dog 的实例。如果再实现一个动物类。</p>
<p><strong>猫类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println("猫【" + Cat.class.getSimpleName()+"】是抓老鼠。");</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 Dog 类和 Cat 类都实现了 Animal 接口。BussinessPerson 的自动注入会报错，因为<strong>不知道注入哪一个</strong>实例。产生注入失败是因为<strong>按类型查找</strong>，动物 Animal 接口有多个类型，这就是存在歧义。</p>
<p><strong>注解 @Primary</strong> 可以修改<strong>优先权</strong>。比如在 Cat 类上使用此注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Animal</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>此时容器会<strong>优先</strong>注入 Cat 实例到 <strong>Animal</strong> 中。@Primary 也可以用在多个类上，此时也会有歧义，可以使用 <strong>@Qualifier 注解</strong>。@Qualifier 注解的配置项 <strong>value</strong> 需要一个字符串去定义，它可以与 @Autowired 一起去通过<strong>类型域名称一起寻找 Bean</strong>。如下。此时注入的就是 Dog 类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"dog"</span>)</span><br><span class="line">Animal animal = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>@autowire和@resourse的区别？</strong></p>
</blockquote>
<p>@Resource 和 @Autowired 都是做 bean 的<strong>注入</strong>时使用，其实 @Resource 并不是 Spring 的注解，它的包是 javax.annotation.Resource。 </p>
<p>1、<strong>共同点</strong></p>
<p>两者都可以写在字段和 setter 方法上。两者如果都写在字段上，那么就不需要再写 setter 方法。</p>
<p>2、<strong>不同点</strong></p>
<p><strong>@Resource 的作用相当于 @Autowired，只不过 @Autowired 按照 byType 自动注入。</strong></p>
<p><strong>(1) @Autowired</strong></p>
<p>@Autowired 为 Spring 提供的注解，需要导入包 org.springframework.beans.factory.annotation.Autowired; 只按照 byType 注入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面两种@Autowired只要使用一种即可</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserDao</span><span class="params">(UserDao userDao)</span> </span>&#123; <span class="comment">// 用于属性的方法上</span></span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Autowired 注解是按照<strong>类型</strong>（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果需要允许 null 值，可以设置它的 required 属性为 false。如果想使用<strong>按照名称</strong>（byName）来装配，可以结合 @Qualifier 注解一起使用。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"userDao"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>(2) @Resource</strong></p>
<p>@Resource 默认按照 <strong>ByName 自动注入</strong>，由 J2EE 提供，需要导入包 javax.annotation.Resource。@Resource 有两个重要的属性：name 和 type，而 Spring 将 @Resource 注解的 name 属性解析为 bean 的名字，而 type 属性则解析为 bean 的类型。所以如果使用 name 属性，则使用 byName 的自动注入策略，而使用 type 属性时则使用 byType 自动注入策略。如果既不制定 name 也不制定 type 属性，这时将通过反射机制使用 byName 自动注入策略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面两种@Resource只要使用一种即可</span></span><br><span class="line">    @Resource(name=<span class="string">"userDao"</span>)</span><br><span class="line">    private UserDao userDao; <span class="comment">// 用于字段上</span></span><br><span class="line">    </span><br><span class="line">    @Resource(name=<span class="string">"userDao"</span>)</span><br><span class="line">    public <span class="keyword">void</span> setUserDao(UserDao userDao) &#123; <span class="comment">// 用于属性的setter方法上</span></span><br><span class="line">        <span class="keyword">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：最好是将 @Resource 放在 setter 方法上，因为这样更符合面向对象的思想，通过 set、get 去操作属性，而不是直接去操作属性。</p>
<p><strong>@Resource 装配顺序：</strong></p>
<ol>
<li><p>如果<strong>同时指定了 name 和 type</strong>，则从 Spring 上下文中找到唯一匹配的 bean 进行装配，找不到则抛出异常。</p>
</li>
<li><p>如果指定了 <strong>name</strong>，则从上下文中查找名称（id）匹配的 bean 进行装配，找不到则抛出异常。</p>
</li>
<li><p>如果指定了 <strong>type</strong>，则从上下文中找到类似匹配的唯一 bean 进行装配，找不到或是找到多个，都会抛出异常。</p>
</li>
<li><p>如果既没有指定 name，又没有指定 type，则自动按照 byName 方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p>
</li>
</ol>
<h4 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><p><strong>循环依赖：就是N个类循环(嵌套)引用</strong>。通俗的讲就是多个 Bean 互相引用对方，最终形成闭环。用一副经典的图示可以表示成这样（A、B、C都代表对象，虚线代表引用关系）：</p>
<img src="assets/image-20200803144915470.png" alt="image-20200803144915470" style="zoom:50%;" />

<p>这里指的循环引用不是方法之间的循环调用，<strong>而是对象的相互依赖关系</strong>。</p>
<p>比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServiceImpl</span> <span class="keyword">implements</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BServiceImpl</span> <span class="keyword">implements</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-三大循环依赖场景"><a href="#2-三大循环依赖场景" class="headerlink" title="2. 三大循环依赖场景"></a>2. 三大循环依赖场景</h5><h6 id="1-构造器注入循环依赖"><a href="#1-构造器注入循环依赖" class="headerlink" title="(1) 构造器注入循环依赖"></a>(1) 构造器注入循环依赖</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：项目启动失败抛出异常 <strong>BeanCurrentlyInCreationException</strong>。</p>
<p><strong>构造器注入</strong>构成的循环依赖问题是<strong>无法解决</strong>的，只能抛出 BeanCurrentlyInCreationException <strong>异常</strong>表示循环依赖。这也是构造器注入的最大劣势（但它也有很多独特的优势）。</p>
<p><strong>根本原因</strong>：Spring 解决循环依赖依靠的是 Bean 的“<strong>中间态</strong>”这个概念，这个<strong>中间态指的是已经实例化，但还没初始化的状态</strong>。而构造器是需要完成实例化的对象，所以构造器的循环依赖无法解决。</p>
<h6 id="2-setter方法注入循环依赖"><a href="#2-setter方法注入循环依赖" class="headerlink" title="(2) setter方法注入循环依赖"></a>(2) setter方法注入循环依赖</h6><p>这种方式是<strong>最最最最</strong>为常用的依赖注入方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：项目启动成功，一切正常</strong>。</p>
<h6 id="3-prototype字段属性注入循环依赖"><a href="#3-prototype字段属性注入循环依赖" class="headerlink" title="(3) prototype字段属性注入循环依赖"></a>(3) prototype字段属性注入循环依赖</h6><p>也就是指定 bean 的作用域为 prototype。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prototype 字段属性注入循环依赖问题也是<strong>无法解决</strong>的。</p>
<h5 id="3-原理分析"><a href="#3-原理分析" class="headerlink" title="3. 原理分析"></a>3. 原理分析</h5><h6 id="1-Bean创建流程"><a href="#1-Bean创建流程" class="headerlink" title="(1) Bean创建流程"></a>(1) Bean创建流程</h6><p>Spring 创建 Bean 的流程大致如下：</p>
<p><img src="assets/image-20200803145712274.png" alt="image-20200803145712274"></p>
<p>对 Bean 的创建最为核心的<strong>三个方法</strong>解释如下：</p>
<ul>
<li><strong>createBeanInstance</strong>：<strong>对象实例化</strong>，其实也就是调用对象的构造方法实例化对象。</li>
<li><strong>populateBean</strong>：<strong>填充属性</strong>，这一步主要是对 bean 的依赖属性进行注入(@Autowired)。</li>
<li><strong>initializeBean</strong>：回调一些形如 initMethod、InitializingBean 等方法。</li>
</ul>
<p>从对单例 Bean 的初始化可以看出，<strong>循环依赖主要发生在第二步（populateBean）</strong>，也就是 field <strong>属性注入</strong>的处理。</p>
<h6 id="2-三级缓存"><a href="#2-三级缓存" class="headerlink" title="(2) 三级缓存"></a>(2) 三级缓存</h6><p>在 Spring 容器的整个生命周期中，<strong>单例 Bean 有且仅有一个对象</strong>，这很容易让人想到可以用缓存来加速访问。<br>Spring 大量运用了 Cache 的手段，在循环依赖问题的解决过程中甚至使用了“<strong>三级缓存</strong>”。</p>
<p>三级缓存其实它更像是 Spring 容器工厂的内的术语，<strong>采用三级缓存模式来解决循环依赖问题</strong>，这三级缓存分别指：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 从上至下 分表代表这“三级缓存”</span></span><br><span class="line">    <span class="comment">//一级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>); 	   <span class="comment">// 二级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>); </span><br><span class="line">    <span class="comment">// 三级缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>); </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line">    <span class="comment">// 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~</span></span><br><span class="line">    <span class="comment">// 它在Bean开始创建时放值，创建完成时会将其移出~</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Names of beans that have already been created at least once. */</span></span><br><span class="line">    <span class="comment">// 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复</span></span><br><span class="line">    <span class="comment">// 至少被创建了一次的  都会放进这里~~~~</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：AbstractBeanFactory 继承自 DefaultSingletonBeanRegistry。</p>
<ol>
<li><strong>singletonObjects</strong>：用于存放<strong>完全初始化好的 bean</strong>，从该缓存中取出的 bean 可以<strong>直接使用</strong>。</li>
<li><strong>earlySingletonObjects</strong>：存放<strong>提前曝光的单例对象</strong>的缓存，存放原始的 bean 对象（<strong>尚未填充属性</strong>），用于解决循环依赖。</li>
<li><strong>singletonFactories</strong>：单例对象工厂的 cache，<strong>存放 bean 工厂对象</strong>，用于解决循环依赖。</li>
</ol>
<p><strong>获取单例 Bean 的源码如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                    ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        singletonObject = singletonFactory.getObject();</span><br><span class="line">                        <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingletonCurrentlyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.singletonsCurrentlyInCreation.contains(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isActuallyInCreation</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSingletonCurrentlyInCreation(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>先从<strong>一级缓存 singletonObjects 中去获取</strong>，如果获取到就直接 return。</li>
<li>如果<strong>获取不到</strong>或者对象正在创建中（isSingletonCurrentlyInCreation()），那就再从<strong>二级缓存</strong> earlySingletonObjects 中获取，如果获取到就直接 return。</li>
<li>如果还是获取不到，且允许 <strong>singletonFactories</strong>（allowEarlyReference=true）通过 getObject() 获取。就从<strong>三级缓存 singletonFactory.getObject() 获取</strong>。（如果获取到了就从 singletonFactories 中<strong>移除</strong>，并且<strong>放进 earlySingletonObjects</strong>。其实也就是<strong>从三级缓存移动到了二级缓存</strong>。</li>
</ol>
<p>加入 singletonFactories 三级缓存的<strong>前提是执行了构造器</strong>，所以<strong>构造器的循环依赖没法解决</strong>。</p>
<p>getSingleton() 从缓存里获取单例对象步骤分析可知，Spring 解决循环依赖的诀窍就在于 <strong>singletonFactories 这个三级缓存</strong>。这个 Cache 里面都是 <strong>ObjectFactory</strong>，它是解决问题的关键。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 它可以将创建对象的步骤封装到ObjectFactory中 交给自定义的Scope来选择是否需要创建对象来灵活的实现scope。具体参见Scope接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 <strong>ObjectFactory.getObject</strong>() 后，此时放进了<strong>二级缓存 earlySingletonObjects 内</strong>。这个时候对象已经<strong>实例化</strong>了，虽然还不完美，但是<strong>对象已经可以被其它引用</strong>了。</p>
<p>此处说一下二级缓存 earlySingletonObjects 它里面的数据<strong>什么时候添加什么移除</strong>？？?</p>
<p><strong>添加</strong>：向里面添加数据只有一个地方，就是上面说的 getSingleton() 里从<strong>三级缓存里挪过来</strong>。</p>
<p><strong>移除</strong>：addSingleton、addSingletonFactory、removeSingleton 从语义中可以看出<strong>添加单例、添加单例工厂</strong> ObjectFactory 的时候都会删除二级缓存里面对应的缓存值，是<strong>互斥</strong>的。</p>
<h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>Bean<strong>定义</strong>、Bean<strong>初始化</strong>、Bean<strong>生存期</strong>、Bean<strong>销毁</strong>。</p>
<h5 id="1-Spring初始化Bean流程"><a href="#1-Spring初始化Bean流程" class="headerlink" title="1. Spring初始化Bean流程"></a>1. Spring初始化Bean流程</h5><ul>
<li><strong>资源定位</strong>(例如 @ComponentScan 所定义的扫描包)。</li>
<li>Bean 定义(将 Bean 的定义保存到 BeanDefinition 的实例中)。</li>
<li>发布 Bean 定义( IOC 容器装载 Bean 的定义)。</li>
<li>实例化(创建 Bean 的实例对象)。</li>
<li>依赖注入(例如 @Autowired 类的各类资源)。</li>
</ul>
<p><img src="assets/1564994604731.png" alt="1564994604731"></p>
<h5 id="2-Spring-Bean的生命周期"><a href="#2-Spring-Bean的生命周期" class="headerlink" title="2. Spring Bean的生命周期"></a>2. Spring Bean的生命周期</h5><p><img src="assets/1564994754829.png" alt="1564994754829"></p>
<ul>
<li><p>Bean 容器找到<strong>配置文件</strong>中 Spring Bean 的定义。</p>
</li>
<li><p>Bean 容器利用<strong>反射</strong>创建一个 Bean 的<strong>实例</strong>。</p>
</li>
<li><p>如果涉及到一些属性值，利用 set 方法<strong>设置一些属性值</strong>，这里也是解决依赖注入。下面基本上都是调用回调方法了。</p>
</li>
<li><p>如果 Bean 实现了 <strong>BeanNameAware</strong> 接口，调用 setBeanName() 方法，传入 <strong>Bean 的名字</strong>。</p>
</li>
<li><p>如果 Bean 实现了 <strong>BeanClassLoaderAware</strong> 接口，调用 setBeanClassLoader() 方法，传入 ClassLoader 对象的实例。</p>
</li>
<li><p>如果 Bean 实现了 <strong>BeanFactoryAware</strong> 接口，调用 setBeanFactory() 方法，传入 <strong>BeanFactory 对象</strong>的实例。</p>
</li>
<li><p>与上面的类似，如果实现了<strong>其他 *Aware 接口</strong>，就调用相应的方法。</p>
</li>
<li><p>如果有和加载这个 Bean 的 Spring 容器相关的 <strong>BeanPostProcessor</strong> 对象，执行 <strong>postProcessBeforeInitialization</strong>() 方法。</p>
</li>
<li><p>如果 Bean 实现了 <strong>InitializingBean</strong> 接口，执行 <strong>afterPropertiesSet</strong>() 方法。</p>
</li>
<li><p>如果 Bean 在配置文件中的定义包含 <strong>init-method</strong> 属性，执行指定的方法。</p>
</li>
<li><p>如果有和加载这个 Bean 的 Spring 容器相关的 <strong>BeanPostProcessor</strong> 对象，执行 <strong>postProcessAfterInitialization</strong>() 方法。</p>
</li>
<li><p>当要销毁 Bean 的时候，如果 Bean 实现了 <strong>DisposableBean</strong> 接口，执行 <strong>destroy</strong>() 方法。</p>
</li>
<li><p>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 <strong>destroy-method</strong> 属性，执行指定的方法。</p>
</li>
</ul>
<p><img src="assets/image-20200528144152364.png" alt="image-20200528144152364"></p>
<img src="../../JavaNotes/H Spring/assets/image-20200528144205341.png" alt="image-20200528144205341" style="zoom:90%;" />

<p>若容器注册了以上各种<strong>接口</strong>，程序那么将会按照以上的流程进行。</p>
<p>再来一张流程图。</p>
<p> <img src="assets/1573540627894.png" alt="1573540627894"></p>
<p>【Spring bean 的生命周期】面试的时候的回答：</p>
<ol>
<li><strong>实例化</strong>一个 Bean，也就是通常说的 new；</li>
<li>按照 Spring 上下文对实例化的 Bean 进行配置，也就是 <strong>IOC 注入</strong>；</li>
<li>如果这个 Bean 实现了 <strong>BeanNameAware 接口</strong>，会调用它实现的 <strong>setBeanName</strong>(String beanId) 方法，此处传递的是 Spring 配置文件中 Bean 的 ID；</li>
<li>如果这个 Bean 实现了 <strong>BeanFactoryAware 接口</strong>，会调用它实现的 <strong>setBeanFactory</strong>()，传递的是 Spring <strong>工厂本身</strong>（可以用这个方法获取到其他 Bean）；</li>
<li>如果这个 Bean 实现了 <strong>ApplicationContextAware接口</strong>，会调用 <strong>setApplicationContext</strong>(ApplicationContext)方法，传入 <strong>Spring 上下文</strong>，该方式同样可以实现步骤 4，但<strong>比 4 更好</strong>，以为 ApplicationContext 是 BeanFactory 的子接口，有更多的<strong>实现方法</strong>；</li>
<li>如果这个 Bean 关联了 <strong>BeanPostProcessor 接口</strong>，将会调用 <strong>postProcessBeforeInitialization</strong>(Object obj,  String s)方法，BeanPostProcessor 经常被<strong>用作是 Bean 内容的更改</strong>，并且由于这个是在 Bean 初始化<strong>结束时</strong>调用 After 方法，也可用于<strong>内存或缓存技术</strong>；</li>
<li>如果这个 Bean 在 Spring 配置文件中配置了 <strong>init-method 属性</strong>会自动调用其配置的初始化方法；</li>
<li>如果这个 Bean 关联了 <strong>BeanPostProcessor 接口</strong>，将会调用 <strong>postAfterInitialization</strong>(Object obj, String s) 方法；</li>
</ol>
<p>注意：以上工作完成以后就可以<strong>使用这个 Bean 了</strong>，这是一个 singleton 的 bean，所以一般情况下调用同一个 ID 获取的 Bean 会是在内容<strong>地址相同</strong>的实例。</p>
<ol>
<li>当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 <strong>DisposableBean 接口</strong>，会调用其实现的 <strong>destroy 方法</strong>。</li>
<li>最后，如果这个 Bean 的 Spring 配置中配置了 <strong>destroy-method 属性</strong>，会自动调用其配置的<strong>销毁方法</strong>。</li>
</ol>
<p>这 10 个步骤可以作为面试模板，另外这里描述的是应用 Spring 上下文 Bean 的生命周期，如果应用 Spring 的工厂也就是 BeanFactory 的话去掉第 5 步就 Ok 了。</p>
<p>下面将仔细讲解各接口作用。</p>
<h5 id="3-各个接口方法分类"><a href="#3-各个接口方法分类" class="headerlink" title="3. 各个接口方法分类"></a>3. 各个接口方法分类</h5><p>Bean 的完整生命周期经历了各种<strong>方法调用</strong>，这些方法可以划分为以下几类：</p>
<ul>
<li><p><strong>Bean 自身的方法</strong>：这个包括了 Bean 本身调用的方法和通过配置文件中 <strong>&lt;bean&gt;</strong> 的 <strong>init-method</strong> 和 <strong>destroy-method</strong> 指定的<strong>初始化以及销毁</strong>方法。</p>
</li>
<li><p><strong>Bean 级生命周期接口方法</strong>：这个包括了 BeanNameAware、BeanFactoryAware、InitializingBean 和DiposableBean 这些接口的方法。</p>
</li>
<li><p><strong>容器级生命周期接口方法</strong>：这个包括了 <strong>InstantiationAwareBeanPostProcessor</strong> 和 <strong>BeanPostProcessor</strong> 这两个接口实现，一般称它们的实现类为“<strong>后处理器</strong>”。</p>
</li>
<li><p><strong>工厂后处理器接口方法</strong>：这个包括了 AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer 等等非常有用的<strong>工厂后处理器接口</strong>的方法。工厂后处理器也是<strong>容器级</strong>的。在应用上下文装配配置文件之后立即调用。</p>
</li>
</ul>
<h5 id="4-初始化initialization和销毁destroy方法"><a href="#4-初始化initialization和销毁destroy方法" class="headerlink" title="4. 初始化initialization和销毁destroy方法"></a>4. 初始化initialization和销毁destroy方法</h5><p>有时需要在 Bean 属性值 set 好之后和 Bean 销毁之前做一些事情，比如检查 Bean 中某个属性是否被正常的设置好值了。Spring 框架提供了多种方法让我们可以在 Spring Bean 的生命周期中执行 <strong>initialization 和 pre-destroy</strong> 方法。</p>
<p><strong>1. 实现InitializingBean和DisposableBean接口</strong></p>
<p>这两个接口都只包含<strong>一个方法</strong>。通过实现 <strong>InitializingBean</strong> 接口的 <strong>afterPropertiesSet</strong>() 方法可以在 Bean <strong>属性值设置好之后</strong>做一些操作，实现 <strong>DisposableBean</strong> 接口的 <strong>destroy</strong>() 方法可以在销毁 Bean 之前做一些操作。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiraffeService</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行InitializingBean接口的afterPropertiesSet方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行DisposableBean接口的destroy方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法比较简单，但是<strong>不建议使用</strong>。因为这样会将 Bean 的实现和 Spring 框架<strong>耦合在一起</strong>。</p>
<p><strong>2. 在bean的配置文件中指定init-method和destroy-method方法</strong></p>
<p>Spring 允许用户创建自己的 <strong>init 方法和 destroy 方法</strong>，只要在 Bean 的配置文件中指定 init-method 和 destroy-method 的值就可以在 Bean 初始化时和销毁之前执行一些操作。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiraffeService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过&lt;bean&gt;的destroy-method属性指定的销毁方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行配置的destroy-method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过&lt;bean&gt;的init-method属性指定的初始化方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行配置的init-method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置文件中的配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"giraffeService"</span> <span class="attr">class</span>=<span class="string">"com.giraffe.spring.service.GiraffeService"</span> <span class="attr">init-method</span>=<span class="string">"initMethod"</span> <span class="attr">destroy-method</span>=<span class="string">"destroyMethod"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是自定义的 init-method 和 post-method 方法可以抛异常但是不能有参数。这种方式比较推荐，因为可以自己创建方法，无需将 Bean 的实现直接依赖于 Spring 的框架。</p>
<p><strong>3. 使用@PostConstruct和@PreDestroy注解</strong></p>
<p>除了 xml 配置的方式，Spring 也支持用 <strong>@PostConstruct</strong> 和 <strong>@PreDestroy</strong> 注解来指定 init 和 destroy 方法。这两个注解均在 javax.annotation 包中。例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiraffeService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPostConstruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行PostConstruct注解标注的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行preDestroy注解标注的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了注解可以生效，需要在<strong>配置文件</strong>中定义org.springframework.context.annotation.<strong>CommonAnnotationBeanPostProcessor</strong>  或 context:annotation-config。配置文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="5-实现-Aware接口在Bean中使用Spring框架的一些对象"><a href="#5-实现-Aware接口在Bean中使用Spring框架的一些对象" class="headerlink" title="5. 实现*Aware接口在Bean中使用Spring框架的一些对象"></a>5. 实现*Aware接口在Bean中使用Spring框架的一些对象</h5><p>有些时候需要在 <strong>Bean 的初始化</strong>中使用 <strong>Spring ==框架自身==的一些对象</strong>来执行一些操作，比如获取 ServletContext 的一些参数，获取 ApplicaitionContext 中的 BeanDefinition 的名字，获取 Bean 在容器中的名字等等。<strong>==为了让 Bean 可以获取到框架自身的一些对象，Spring 提供了一组名为 *Aware 的接口。==</strong></p>
<p>这些接口均继承于 org.springframework.beans.factory.<strong>Aware 标记接口</strong>，并提供一个将由 <strong>Bean 实现的 set* 方法</strong>， Spring 通过基于 <strong>setter 的依赖注入方式</strong>使相应的对象可以被 Bean 使用。</p>
<p>介绍一些<strong>重要的 Aware 接口</strong>：</p>
<ul>
<li><strong>ApplicationContextAware</strong>：获得 <strong>ApplicationContext</strong> 对象，可以用来获取<strong>所有 BeanDefinition</strong> 的名字。</li>
<li><strong>BeanFactoryAware</strong>：获得 <strong>BeanFactory</strong> 对象，可以用来检测 Bean 的作用域。</li>
<li><strong>BeanNameAware</strong>：获得 Bean 在<strong>配置文件</strong>中定义的名字。</li>
<li><strong>ResourceLoaderAware</strong>：获得 ResourceLoader 对象，可以获得 <strong>classpath</strong> 中某个文件。</li>
<li><strong>ServletContextAware</strong>：在一个 MVC 应用中可以获取 <strong>ServletContext</strong> 对象，可以读取 context 中的参数。</li>
<li><strong>ServletConfigAware</strong>：在一个 MVC 应用中可以获取 <strong>ServletConfig</strong> 对象，可以读取 config 中的参数。</li>
</ul>
<p>以下是实现上述接口的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiraffeService</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>,</span></span><br><span class="line"><span class="class"><span class="title">ApplicationEventPublisherAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>,</span></span><br><span class="line"><span class="class"><span class="title">BeanNameAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">ImportAware</span>, <span class="title">ResourceLoaderAware</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行setBeanClassLoader,ClassLoader Name = "</span> + classLoader.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行setBeanFactory,setBeanFactory:: giraffe bean singleton="</span> +  beanFactory.isSingleton(<span class="string">"giraffeService"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行setBeanName:: Bean Name defined in context="</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行setApplicationContext:: Bean Definition Names="</span></span><br><span class="line">                           + Arrays.toString(applicationContext.getBeanDefinitionNames()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行setApplicationEventPublisher"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行setEnvironment"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        Resource resource = resourceLoader.getResource(<span class="string">"classpath:spring-beans.xml"</span>);</span><br><span class="line">        System.out.println(<span class="string">"执行setResourceLoader:: Resource File Name="</span></span><br><span class="line">                           + resource.getFilename());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行setImportMetadata"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-BeanPostProcessor"><a href="#6-BeanPostProcessor" class="headerlink" title="6. BeanPostProcessor"></a>6. BeanPostProcessor</h5><p>上面的 <strong>*Aware</strong> 接口是针对<strong>==某个==实现这些接口的 Bean 定制初始化</strong>的过程，Spring 同样可以针对容器中的<strong>==所有 Bean==</strong>，或者<strong>==某些== Bean</strong> 定制初始化过程，只需<strong>提供一个实现 BeanPostProcessor 接口的类</strong>即可。 该接口中包含两个方法， <strong>postProcessBeforeInitialization</strong> 和 <strong>postProcessAfterInitialization</strong>。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postProcessBeforeInitialization 方法会在容器中的 <strong>Bean 初始化之前执行，</strong> postProcessAfterInitialization 方法在容器中的 <strong>Bean 初始化之后</strong>执行。</p>
<p>例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行BeanPostProcessor的postProcessBeforeInitialization方法,beanName="</span> + beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行BeanPostProcessor的postProcessAfterInitialization方法,beanName="</span> + beanName);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要将 BeanPostProcessor 的 Bean 像其他 Bean 一样定义在配置文件中配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.giraffe.spring.service.CustomerBeanPostProcessor"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="7-单例与非单例对象生命周期例子"><a href="#7-单例与非单例对象生命周期例子" class="headerlink" title="7. 单例与非单例对象生命周期例子"></a>7. 单例与非单例对象生命周期例子</h5><p>其实很多时候并不会真的去实现上面说描述的那些接口，那么下面就除去那些接口，针对 bean 的单例和非单例来描述下 bean 的生命周期：</p>
<h6 id="1-单例管理的对象"><a href="#1-单例管理的对象" class="headerlink" title="(1) 单例管理的对象"></a>(1) 单例管理的对象</h6><p>当 scope = “singleton”，即默认情况下，会在<strong>启动容器时（即实例化容器时）时实例化</strong>。但可以指定 Bean 的 <strong>lazy-init= “true”</strong> 来延迟初始化 bean，这时候只有在第一次获取 bean 时才会初始化 bean，即第一次请求该 bean 时才初始化。如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"ServiceImpl"</span> <span class="attr">class</span>=<span class="string">"cn.csdn.service.ServiceImpl"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果想对<strong>所有的</strong>默认单例 bean 都应用延迟初始化，可以在根节点 beans 设置 default-lazy-init 属性为 true，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">default-lazy-init</span>=<span class="string">"true"</span> …&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，Spring 在读取 xml 文件的时候，就会<strong>创建对象</strong>。在创建对象的时候先<strong>调用构造</strong>器，然后调用 <strong>init-method 属性值</strong>中所指定的方法。对象在被销毁的时候，会调用 <strong>destroy-method 属性值</strong>中所指定的方法（例如调用 Container.destroy() 方法的时候）。写一个测试类，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LifeBean</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"LifeBean()构造函数"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"setName()"</span>);  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"this is init of lifeBean"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"this is destory of lifeBean "</span> + <span class="keyword">this</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>life.xml 配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"life_singleton"</span> <span class="attr">class</span>=<span class="string">"com.bean.LifeBean"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destory"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractApplicationContext container = </span><br><span class="line">        <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"life.xml"</span>);</span><br><span class="line">        LifeBean life1 = (LifeBean)container.getBean(<span class="string">"life"</span>);</span><br><span class="line">        System.out.println(life1);</span><br><span class="line">        container.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LifeBean()构造函数</span><br><span class="line">this is init of lifeBean</span><br><span class="line">com.bean.LifeBean@573f2bb1</span><br><span class="line">……</span><br><span class="line">this is destory of lifeBean com.bean.LifeBean@573f2bb1</span><br></pre></td></tr></table></figure>

<h6 id="2-非单例管理的对象"><a href="#2-非单例管理的对象" class="headerlink" title="(2) 非单例管理的对象"></a>(2) 非单例管理的对象</h6><p>当 scope=”prototype” 时，容器也会<strong>延迟初始化</strong> bean，Spring 读取 xml 文件的时候，并<strong>不会立刻创建对象</strong>，而是在<strong>第一次请求该 bean 时才初始化</strong>（如调用 getBean 方法时）。在第一次请求每一个 prototype 的 bean 时，Spring 容器都会调用其<strong>构造器创建这个对象</strong>，然后调用 <strong>init-method</strong> 属性值中所指定的方法。对象销毁的时候，Spring 容器<strong>不会</strong>帮我们调用任何方法（<strong>不会调用 destroy 方法</strong>），因为是非单例，这个类型的对象有<strong>很多个</strong>，Spring 容器一旦把这个对象交给你之后，就<strong>不再管理</strong>这个对象了。</p>
<p>测试 prototype bean 的生命周期 life.xml 配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"life_prototype"</span> <span class="attr">class</span>=<span class="string">"com.bean.LifeBean"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"destory"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取容器</span></span><br><span class="line">        AbstractApplicationContext container </span><br><span class="line">            = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"life.xml"</span>);</span><br><span class="line">        LifeBean life1 = (LifeBean)container.getBean(<span class="string">"life_singleton"</span>);</span><br><span class="line">        System.out.println(life1);</span><br><span class="line"></span><br><span class="line">        LifeBean life3 = (LifeBean)container.getBean(<span class="string">"life_prototype"</span>);</span><br><span class="line">        System.out.println(life3);</span><br><span class="line">        container.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LifeBean()构造函数</span><br><span class="line">this is init of lifeBean</span><br><span class="line">com.bean.LifeBean@573f2bb1</span><br><span class="line">LifeBean()构造函数</span><br><span class="line">this is init of lifeBean</span><br><span class="line">com.bean.LifeBean@5ae9a829</span><br><span class="line">……</span><br><span class="line">this is destory of lifeBean com.bean.LifeBean@573f2bb1</span><br></pre></td></tr></table></figure>

<p>可以发现对于作用域为 <strong>prototype</strong> 的 bean ，其 destroy 方法<strong>并没有被调用</strong>。如果 bean 的 scope 设为 prototype 时，当容器<strong>关闭时，destroy 方法不会被调用</strong>。对于 prototype 作用域的 bean，有一点非常重要，那就是 Spring <strong>不能对一个 prototype bean 的整个生命周期负责</strong>：容器在初始化、配置、装饰或者是装配完一个 prototype 实例后，将它交给客户端，随后就对该 prototype 实例<strong>不闻不问</strong>了。 不管何种作用域，容器都会调用所有对象的初始化生命周期回调方法。但对 prototype 而言，<strong>任何配置好的析构生命周期回调方法都将不会被调用</strong>。清除 prototype 作用域的对象并释放任何 prototype bean 所持有的昂贵资源，都是<strong>客户端代码的职责</strong>（让 Spring 容器释放被 prototype 作用域 bean 占用资源的一种可行方式是，通过使用 bean 的后置处理器，该处理器持有要被清除的 bean 的引用）。谈及 prototype 作用域的 bean 时，在某些方面你可以将 Spring 容器的角色看作<strong>普通 new 操作</strong>的替代者，任何迟于该时间点的生命周期事宜都得交由客户端来处理。</p>
<p>Spring 容器可以管理 <strong>singleton</strong> 作用域下 bean 的生命周期，在此作用域下，Spring 能够<strong>精确地知道 bean 何时被创建，何时初始化完成，以及何时被销毁</strong>。而对于 prototype 作用域的 bean，<strong>Spring 只负责创建</strong>，当容器创建了 bean 的实例后，bean 的实例就交给了客户端的代码管理，Spring 容器将不再跟踪其生命周期，并且不会管理那些被配置成 prototype 作用域的 bean 的生命周期。</p>
<h4 id="BeanFactory与ApplicationContext"><a href="#BeanFactory与ApplicationContext" class="headerlink" title="BeanFactory与ApplicationContext"></a>BeanFactory与ApplicationContext</h4><h5 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1.BeanFactory"></a>1.BeanFactory</h5><p>BeanFactory 是 Spring 里面最顶层的接口，提供了最简单的<strong>容器</strong>的功能，只提供了实例化对象和获取对象的功能。它在启动的时候<strong>不会去实例化 Bean</strong>，中有从容器中获取 Bean 的时候才会去实例化；</p>
<h5 id="2-ApplicationContext"><a href="#2-ApplicationContext" class="headerlink" title="2.ApplicationContext"></a>2.ApplicationContext</h5><p>ApplicationContext 是 BeanFactory 的<strong>实现类</strong>，除了提供 BeanFactory 所支持的<strong>所有功能</strong>外，ApplicationContext 还有额外的功能：</p>
<ul>
<li><strong>默认初始化所有</strong>的 Singleton 实例，也可以通过配置取消预初始化。</li>
<li>继承 MessageSource，因此支持<strong>国际化</strong>。</li>
<li><strong>资源访问</strong>，比如访问 URL 和文件（ResourceLoader）；</li>
<li><strong>事件机制</strong>，（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的 web 层；</li>
<li>同时加载<strong>多个配置文件</strong>。</li>
<li>消息发送、响应机制（ApplicationEventPublisher）；</li>
<li>以<strong>声明式</strong>方式创建并启动 Spring 容器。</li>
</ul>
<p>由于 ApplicationContext 会<strong>预先初始化所有的 Singleton Bean</strong>，于是在系统创建前期会有较大的<strong>系统开销</strong>，但一旦 ApplicationContext 初始化完成，程序后面获取 Singleton Bean 实例时候将有较好的性能。也可以为 bean 设置 <strong>lazy-init 属性</strong>为 true，即 Spring 容器将不会预先初始化该 bean。</p>
<p>ApplicationContext的三个实现类：</p>
<ul>
<li><strong>ClassPathXmlApplication</strong>：把上下文文件当成类路径资源。</li>
<li><strong>FileSystemXmlApplication</strong>：从文件系统中的 XML 文件载入上下文定义信息。</li>
<li><strong>XmlWebApplicationContext</strong>：从Web系统中的XML文件载入上下文定义信息。</li>
</ul>
<h5 id="3-延迟实例化与非延迟实例化的优缺点"><a href="#3-延迟实例化与非延迟实例化的优缺点" class="headerlink" title="3. 延迟实例化与非延迟实例化的优缺点"></a>3. 延迟实例化与非延迟实例化的优缺点</h5><p><strong>BeanFactory</strong> 延迟实例化的<strong>优点</strong>：应用启动的时候占用资源很少，对资源要求较高的应用，比较有优势。</p>
<p><strong>缺点</strong>：速度会相对来说慢一些。而且有可能会出现空指针异常的错误，而且通过 bean 工厂创建的 bean 生命周期会简单一些。</p>
<p><strong>ApplicationContext</strong> 不延迟实例化的<strong>优点</strong>：</p>
<ul>
<li>所有的 Bean 在启动的时候都加载，系统运行的速度快；且能在系统启动的时候，尽早的发现系统中的配置问题。</li>
<li>可以用于 web 场景，在启动的时候就把所有的 Bean 都加载了。</li>
</ul>
<p><strong>缺点</strong>：把费时的操作放到系统启动中完成，所有的对象都可以<strong>预加载</strong>，缺点就是消耗服务器的内存。</p>
<h4 id="BeanFactory与FactoryBean"><a href="#BeanFactory与FactoryBean" class="headerlink" title="BeanFactory与FactoryBean"></a>BeanFactory与FactoryBean</h4><p>这两个特别像，但是功能却千差万别。</p>
<p><strong>BeanFactory</strong> 是 Spring <strong>容器的基础实现类</strong>，它是负责<strong>生产和管理</strong> Bean 的一个<strong>工厂</strong>。当然 BeanFactory 只是一个<strong>接口</strong>，它的常用实现有 XmlBeanFactory、<strong>DefaultListableBeanFactory</strong>、*<em>ApplicationContext *</em>等。</p>
<p><img src="assets/1573545313232.png" alt="1573545313232"></p>
<p><strong>FactoryBean</strong> 是一个<strong>接口</strong>，具有三个方法如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"> 	<span class="comment">// 返回由 FactoryBean 创建的Bean实例</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> 	<span class="comment">// 返回 FactoryBean 创建Bean的类型</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line"> 	<span class="comment">// 返回是否是 singleton</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常规的 Bean 都是 Spring <strong>使用 Class 的反射</strong>获取具体<strong>实例</strong>，如果 Bean 的获取过程<strong>比较复杂</strong>，那么常规的 xml 配置需要配置<strong>大量属性值</strong>，这个时候就可以<strong>使用 FactoryBean</strong>，实现这个接口，在其 <strong>getObject() 方法中初始化这个 bean</strong>。 比如装配 MyBatis 中的 <strong>SqlSessionFactoryBean</strong> 或者<strong>数据库连接</strong>对象就可以用这个。</p>
<p>FactoryBean 使用实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">// 通过getObject方法返回实例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setAge(<span class="number">22</span>);</span><br><span class="line">        student.setName(<span class="string">"jj"</span>);</span><br><span class="line">        student.setId(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 对象具体类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 是否单例</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在<strong>配置类</strong>中添加该 bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加Bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentFactoryBean <span class="title">studentFactoryBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentFactoryBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStudentFactoryBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext</span><br><span class="line">        = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Student student = (Student) applicationContext.getBean(<span class="string">"studentFactoryBean"</span>);</span><br><span class="line">    System.out.println(student);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// res</span></span><br><span class="line">Student(id=<span class="number">10</span>, name=test:jj, age=<span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<ul>
<li><p><strong>BeanFactory：工厂类接口，Spring 容器的核心接口，用于实例化 bean 以及管理配置 bean 之间的依赖关系</strong>。</p>
</li>
<li><p><strong>FactoryBean：实例化 bean 过程比较复杂时可以考虑使用</strong>。</p>
</li>
</ul>
<h4 id="Bean相关"><a href="#Bean相关" class="headerlink" title="Bean相关"></a>Bean相关</h4><h5 id="1-id和name"><a href="#1-id和name" class="headerlink" title="1. id和name"></a>1. id和name</h5><p>每个 Bean 在 Spring 容器中都有一个<strong>唯一的名字</strong>（beanName）和 0 个或<strong>多个别名</strong>（aliases）。从 Spring 容器中获取 Bean 的时候，可以根据 <strong>beanName</strong>，也可以通过<strong>别名</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.getBean(<span class="string">"beanName or alias"</span>);</span><br></pre></td></tr></table></figure>

<p>在配置 &lt;bean /&gt; 的过程中，可以配置 id 和 name，看几个例子就知道是怎么回事了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">name</span>=<span class="string">"m1, m2, m3"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上配置的结果就是：beanName 为 <strong>messageService</strong>，别名有 3 个，分别为 m1、m2、m3。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"m1, m2, m3"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>beanName 为：com.javadoop.example.MessageServiceImpl#0，</p>
<p>别名 1 个，为： com.javadoop.example.MessageServiceImpl。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上配置的结果就是：beanName 为 messageService，没有别名。</p>
<h5 id="2-配置是否允许Bean覆盖、是否允许循环依赖"><a href="#2-配置是否允许Bean覆盖、是否允许循环依赖" class="headerlink" title="2. 配置是否允许Bean覆盖、是否允许循环依赖"></a>2. 配置是否允许Bean覆盖、是否允许循环依赖</h5><p>默认情况下，<strong>allowBeanDefinitionOverriding</strong> 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p>
<p>可是有些时候希望在系统启动的过程中就<strong>严格杜绝发生 Bean 覆盖</strong>，因为万一出现这种情况，会增加排查问题的成本。</p>
<p><strong>循环依赖</strong>说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 <strong>allowCircularReferences</strong> 也是 null。</p>
<p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p>
<h5 id="3-初始化Bean的回调"><a href="#3-初始化Bean的回调" class="headerlink" title="3. 初始化Bean的回调"></a>3. 初始化Bean的回调</h5><p>有以下四种方案：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-销毁Bean的回调"><a href="#4-销毁Bean的回调" class="headerlink" title="4. 销毁Bean的回调"></a>4. 销毁Bean的回调</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(destroyMethod = <span class="string">"cleanup"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Bar <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-ConversionService"><a href="#7-ConversionService" class="headerlink" title="7. ConversionService"></a>7. ConversionService</h5><p>ConversionService 最有用的场景就是用来将<strong>前端传过来的参数和后端的 Controller 方法上的参数进行绑定</strong>。</p>
<p>像前端传过来的字符串、整数要转换为后端的 <strong>String、Integer</strong> 很容易，但是如果 Controller 方法需要的是一个<strong>枚举值</strong>，或者是 <strong>Date</strong> 这些非基础类型（含基础类型包装类）值的时候，就可以考虑<strong>采用 ConversionService 来进行转换</strong>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.javadoop.learning.utils.StringToEnumConverterFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ConversionService 接口很简单，所以要<strong>自定义一个 convert</strong> 的话也很简单。</p>
<p>下面再说一个实现这种转换很简单的方式，那就是实现 <strong>Converter 接口</strong>。看一个很简单的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DateUtils.parseDate(source, <span class="string">"yyyy-MM-dd"</span>, <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, <span class="string">"yyyy-MM-dd HH:mm"</span>, <span class="string">"HH:mm:ss"</span>, <span class="string">"HH:mm"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要<strong>注册这个 Bean</strong> 就可以了。这样前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p>
<h5 id="8-Bean继承"><a href="#8-Bean继承" class="headerlink" title="8. Bean继承"></a>8. Bean继承</h5><p>在初始化 Bean 的地方，说过了这个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure>

<p>这里涉及到的就是  &lt;bean parent=”” /&gt;  中的 <strong>parent 属性</strong>，看看 Spring 中是用这个来干什么的。</p>
<p>首先要明白这里的继承和 Java 语法中的继承<strong>没有任何关系</strong>，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p>
<p>Spring 中提供了继承自 AbstractBeanDefinition 的 <strong>ChildBeanDefinition</strong> 来表示 child bean。</p>
<p>看如下一个例子：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.TestBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritsWithDifferentClass"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">parent</span>=<span class="string">"inheritedTestBean"</span> <span class="attr">init-method</span>=<span class="string">"initialize"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"override"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>parent bean 设置了 <code>abstract=&quot;true&quot;</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p>
<p>不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p>
<p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="attr">abstract</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"parent"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="9-方法注入"><a href="#9-方法注入" class="headerlink" title="9. 方法注入"></a>9. 方法注入</h5><p>一般应用中大多数的 Bean <strong>都是 singleton</strong> 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，<strong>直接设置属性依赖</strong>就可以了。</p>
<p>但是如果<strong>是 singleton 依赖 prototype</strong> 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，每次其实拿到的还是第一次初始化时候的 bean。</p>
<p>一种解决方案就是<strong>不要用属性依赖</strong>，每次<strong>获取依赖的 bean 的时候从 BeanFactory 中取</strong>。这个也是大家最常用的方式了。另一种解决方案就是这里要介绍的通过使用 Lookup method。</p>
<h6 id="1-lookup-method"><a href="#1-lookup-method" class="headerlink" title="(1) lookup-method"></a>(1) lookup-method</h6><p>来看一下 Spring Reference 中提供的一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>xml 配置  <strong>&lt;lookup-method /&gt;：</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCommand"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"myCommand"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring 采用 <strong>CGLIB 生成字节码</strong>的方式来生成一个<strong>子类</strong>。定义的类不能定义为 final class，抽象方法上也不能加 final。</p>
<p>lookup-method 上的配置也可以采用<strong>注解</strong>来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        MyCommand command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span>(<span class="string">"myCommand"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-replaced-method"><a href="#2-replaced-method" class="headerlink" title="(2) replaced-method"></a>(2) replaced-method</h6><p>记住它的功能，就是<strong>替换掉 bean 中的一些方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValueCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">computeValue</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some real code...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some other methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法覆写，注意要实现 <strong>MethodReplacer</strong> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">beans</span>.<span class="title">factory</span>.<span class="title">support</span>.<span class="title">MethodReplacer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></span><br><span class="line">        String input = (String) args[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置也很简单：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myValueCalculator"</span> <span class="attr">class</span>=<span class="string">"x.y.z.MyValueCalculator"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"computeValue"</span> <span class="attr">replacer</span>=<span class="string">"replacementComputeValue"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"replacementComputeValue"</span> <span class="attr">class</span>=<span class="string">"a.b.c.ReplacementComputeValue"</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="10-BeanPostProcessor"><a href="#10-BeanPostProcessor" class="headerlink" title="10. BeanPostProcessor"></a>10. BeanPostProcessor</h5><p>应该说 <strong>BeanPostProcessor</strong> 概念在 Spring 中也是比较重要的。看下接口定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Before</span></span><br><span class="line">    <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">	<span class="comment">// After</span></span><br><span class="line">    <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看这个接口中的两个方法名字大体上可以猜测 bean 在<strong>初始化之前</strong>会执行 <strong>postProcessBeforeInitialization</strong> 这个方法，初始化<strong>完成之后</strong>会执行 <strong>postProcessAfterInitialization</strong> 这个方法。但是这么理解是非常片面的。</p>
<p>首先要明白除了自己定义的 <strong>BeanPostProcessor</strong> 实现外，Spring 容器也在启动时<strong>自动给加了几个</strong>。如在获取 BeanFactory 的 <strong>obtainFactory</strong>() 方法结束后的 <strong>prepareBeanFactory</strong>(factory)，大家仔细看会发现，Spring 往容器中添加了这<strong>两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector</strong>。</p>
<p>回到这个接口本身，第一个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为<strong>新的 bean 实例</strong>，所以，没事的话这里不能随便返回个 null。所以这里可以对一些我们<strong>想要修饰的 bean 实例做一些事情</strong>。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p>
<p>如果自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？如果仔细看了代码分析的话，其实很容易知道了，<strong>在 bean 实例化完成、属性注入完成之后，会执行回调方法</strong>，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p>
<p>首先会回调几个<strong>实现了 Aware 接口的 bean</strong>，然后就<strong>开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法</strong>。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li>【Spring 依赖注入】<a href="https://www.cnblogs.com/ooo0/p/10962360.html" target="_blank" rel="noopener">https://www.cnblogs.com/ooo0/p/10962360.html</a></li>
<li>【Spring Bean的生命周期】<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="noopener">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></li>
<li>【Spring中bean的作用域与生命周期】<a href="https://blog.csdn.net/fuzhongmin05/article/details/73389779" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/73389779</a></li>
<li>【Spring如何解决循环依赖】<a href="https://blog.csdn.net/f641385712/article/details/92801300" target="_blank" rel="noopener">https://blog.csdn.net/f641385712/article/details/92801300</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/H%20Spring/A%20J2EE%E4%B8%8EWeb%E5%9F%BA%E7%A1%80/" rel="next" title="ShiftJava/H Spring/A J2EE与Web基础">
                <i class="fa fa-chevron-left"></i> ShiftJava/H Spring/A J2EE与Web基础
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/H%20Spring/F%20Spring%20MVC/" rel="prev" title="ShiftJava/H Spring/F Spring MVC">
                ShiftJava/H Spring/F Spring MVC <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-IOC"><span class="nav-number">1.</span> <span class="nav-text">Spring IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#控制反转IOC"><span class="nav-number">1.1.</span> <span class="nav-text">控制反转IOC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-谈谈对IOC的理解？"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 谈谈对IOC的理解？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-控制反转的好处"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 控制反转的好处</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-IOC与DI的关系"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. IOC与DI的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-依赖倒置原则"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. 依赖倒置原则</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean作用域"><span class="nav-number">1.2.</span> <span class="nav-text">Bean作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-作用域分类"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 作用域分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-singleton"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. singleton</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-prototype"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. prototype</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-request"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. request</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-session"><span class="nav-number">1.2.5.</span> <span class="nav-text">5. session</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-globalSession"><span class="nav-number">1.2.6.</span> <span class="nav-text">6. globalSession</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-Scope注解"><span class="nav-number">1.2.7.</span> <span class="nav-text">7. @Scope注解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean的装配与注册"><span class="nav-number">1.3.</span> <span class="nav-text">Bean的装配与注册</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-基于配置类的装配"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 基于配置类的装配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-基于注解的装配"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 基于注解的装配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-装配方式对比"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 装配方式对比</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Conditional条件装配Bean"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. @Conditional条件装配Bean</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-装配导入组件的注解"><span class="nav-number">1.3.5.</span> <span class="nav-text">5. 装配导入组件的注解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性设置"><span class="nav-number">1.4.</span> <span class="nav-text">属性设置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Value注解设置属性"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. @Value注解设置属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-属性配置文件"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 属性配置文件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-application-properties"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">(1) application.properties</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-自定义属性配置文件"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">(2) 自定义属性配置文件</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#依赖注入DI"><span class="nav-number">1.5.</span> <span class="nav-text">依赖注入DI</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-依赖注入方式"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. 依赖注入方式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-构造器注入"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">(1) 构造器注入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-setter注入"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">(2) setter注入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-接口注入"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">(3) 接口注入</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-注解注入-Autowired与-Resource"><span class="nav-number">1.5.2.4.</span> <span class="nav-text">(4) 注解注入@Autowired与@Resource</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#循环依赖"><span class="nav-number">1.6.</span> <span class="nav-text">循环依赖</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-1"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-三大循环依赖场景"><span class="nav-number">1.6.2.</span> <span class="nav-text">2. 三大循环依赖场景</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-构造器注入循环依赖"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">(1) 构造器注入循环依赖</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-setter方法注入循环依赖"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">(2) setter方法注入循环依赖</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-prototype字段属性注入循环依赖"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">(3) prototype字段属性注入循环依赖</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-原理分析"><span class="nav-number">1.6.3.</span> <span class="nav-text">3. 原理分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-Bean创建流程"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">(1) Bean创建流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-三级缓存"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">(2) 三级缓存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean的生命周期"><span class="nav-number">1.7.</span> <span class="nav-text">Bean的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Spring初始化Bean流程"><span class="nav-number">1.7.1.</span> <span class="nav-text">1. Spring初始化Bean流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Spring-Bean的生命周期"><span class="nav-number">1.7.2.</span> <span class="nav-text">2. Spring Bean的生命周期</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-各个接口方法分类"><span class="nav-number">1.7.3.</span> <span class="nav-text">3. 各个接口方法分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-初始化initialization和销毁destroy方法"><span class="nav-number">1.7.4.</span> <span class="nav-text">4. 初始化initialization和销毁destroy方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-实现-Aware接口在Bean中使用Spring框架的一些对象"><span class="nav-number">1.7.5.</span> <span class="nav-text">5. 实现*Aware接口在Bean中使用Spring框架的一些对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-BeanPostProcessor"><span class="nav-number">1.7.6.</span> <span class="nav-text">6. BeanPostProcessor</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-单例与非单例对象生命周期例子"><span class="nav-number">1.7.7.</span> <span class="nav-text">7. 单例与非单例对象生命周期例子</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-单例管理的对象"><span class="nav-number">1.7.7.1.</span> <span class="nav-text">(1) 单例管理的对象</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-非单例管理的对象"><span class="nav-number">1.7.7.2.</span> <span class="nav-text">(2) 非单例管理的对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanFactory与ApplicationContext"><span class="nav-number">1.8.</span> <span class="nav-text">BeanFactory与ApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-BeanFactory"><span class="nav-number">1.8.1.</span> <span class="nav-text">1.BeanFactory</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ApplicationContext"><span class="nav-number">1.8.2.</span> <span class="nav-text">2.ApplicationContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-延迟实例化与非延迟实例化的优缺点"><span class="nav-number">1.8.3.</span> <span class="nav-text">3. 延迟实例化与非延迟实例化的优缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanFactory与FactoryBean"><span class="nav-number">1.9.</span> <span class="nav-text">BeanFactory与FactoryBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean相关"><span class="nav-number">1.10.</span> <span class="nav-text">Bean相关</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-id和name"><span class="nav-number">1.10.1.</span> <span class="nav-text">1. id和name</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-配置是否允许Bean覆盖、是否允许循环依赖"><span class="nav-number">1.10.2.</span> <span class="nav-text">2. 配置是否允许Bean覆盖、是否允许循环依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-初始化Bean的回调"><span class="nav-number">1.10.3.</span> <span class="nav-text">3. 初始化Bean的回调</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-销毁Bean的回调"><span class="nav-number">1.10.4.</span> <span class="nav-text">4. 销毁Bean的回调</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-ConversionService"><span class="nav-number">1.10.5.</span> <span class="nav-text">7. ConversionService</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-Bean继承"><span class="nav-number">1.10.6.</span> <span class="nav-text">8. Bean继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-方法注入"><span class="nav-number">1.10.7.</span> <span class="nav-text">9. 方法注入</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-lookup-method"><span class="nav-number">1.10.7.1.</span> <span class="nav-text">(1) lookup-method</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-replaced-method"><span class="nav-number">1.10.7.2.</span> <span class="nav-text">(2) replaced-method</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-BeanPostProcessor"><span class="nav-number">1.10.8.</span> <span class="nav-text">10. BeanPostProcessor</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.11.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
