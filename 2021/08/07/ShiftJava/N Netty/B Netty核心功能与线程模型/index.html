<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] Netty核心功能与线程模型Netty 是一个异步的事件驱动的网络应用框架。 Netty基础1. 概述Java NIO 的类库和 API 繁杂，需要熟练掌握 Selector、 ServerSocketChannel、 SocketChannel、 ByteBuffer等，使用非常麻烦。 且开发工作量和难度都非常大： 例如客户端面临断线重连、 网络闪断、心跳处理、半包读写、 网络拥塞和">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;N Netty&#x2F;B Netty核心功能与线程模型">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] Netty核心功能与线程模型Netty 是一个异步的事件驱动的网络应用框架。 Netty基础1. 概述Java NIO 的类库和 API 繁杂，需要熟练掌握 Selector、 ServerSocketChannel、 SocketChannel、 ByteBuffer等，使用非常麻烦。 且开发工作量和难度都非常大： 例如客户端面临断线重连、 网络闪断、心跳处理、半包读写、 网络拥塞和">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;assets&#x2F;image-20200727213832939.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;assets&#x2F;image-20200727214255181.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;assets&#x2F;image-20200727214512299.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;assets&#x2F;image-20200727214601586.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;assets&#x2F;image-20200727210845658.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;assets&#x2F;image-20200727234357801.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;assets&#x2F;image-20200728000505451.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;assets&#x2F;image-20200727211346203.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;assets&#x2F;image-20200728132110796.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;assets&#x2F;image-20200727211530128.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;N%20Netty&#x2F;B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B&#x2F;assets&#x2F;image-20200727213832939.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/N Netty/B Netty核心功能与线程模型/"/>





  <title>ShiftJava/N Netty/B Netty核心功能与线程模型 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/N%20Netty/B%20Netty%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/N Netty/B Netty核心功能与线程模型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:17+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="Netty核心功能与线程模型"><a href="#Netty核心功能与线程模型" class="headerlink" title="Netty核心功能与线程模型"></a>Netty核心功能与线程模型</h3><p>Netty 是一个<strong>异步的事件驱动</strong>的<strong>网络</strong>应用<strong>框架</strong>。</p>
<h4 id="Netty基础"><a href="#Netty基础" class="headerlink" title="Netty基础"></a>Netty基础</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p><strong>Java NIO 的类库</strong>和 API 繁杂，需要熟练掌握 Selector、 ServerSocketChannel、 SocketChannel、 ByteBuffer等，使用非常麻烦。 且开发工作量和难度都非常大： 例如客户端面临断线重连、 网络闪断、心跳处理、半包读写、 网络拥塞和异常流的处理等等。</p>
<p><strong>Netty 对 JDK 自带的 NIO 的 API 进行了良好的封装</strong>，解决了上述问题。且 Netty 拥有高性能、 吞吐量更高，延迟更低，减少资源消耗，<strong>最小化不必要的内存复制</strong>等优点。Netty 现在都在用的是 <strong>4.x</strong>，5.x 版本已经废弃，Netty 4.x 需要 JDK 6 以上版本支持。</p>
<h5 id="2-Netty使用场景"><a href="#2-Netty使用场景" class="headerlink" title="2. Netty使用场景"></a>2. Netty使用场景</h5><ul>
<li><p><strong>RPC</strong>：在分布式系统中，各个节点之间需要<strong>远程服务调用</strong>，高性能的 <strong>RPC 框架</strong>必不可少，Netty 作为<strong>异步高性能的通信框架</strong>，往往作为基础通信组件被这些 RPC 框架使用。典型的应用有：阿里分布式服务框架 <strong>Dubbo</strong> 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现。各进程节点之间的内部通信。<strong>RocketMQ 底层</strong>也是用的 Netty 作为<strong>基础通信组件</strong>。经典的 <strong>Hadoop</strong> 的高性能通信和序列化组件 <strong>Avro 的 RPC 框架</strong>，默认采用 Netty 进行跨界点通信，它的 Netty Service 基于 Netty 框架二次封装实现。</p>
</li>
<li><p><strong>游戏服务器</strong>：无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用。Netty 作为高性能的基础通信组件，它本身提供了 TCP/UDP 和 HTTP 协议栈。</p>
</li>
</ul>
<p>Netty 相关开源项目：<a href="https://netty.io/wiki/related-projects.html" target="_blank" rel="noopener">https://netty.io/wiki/related-projects.html</a></p>
<h4 id="Netty线程模型"><a href="#Netty线程模型" class="headerlink" title="Netty线程模型"></a>Netty线程模型</h4><h5 id="1-线程模型架构图"><a href="#1-线程模型架构图" class="headerlink" title="1. 线程模型架构图"></a>1. 线程模型架构图</h5><p>可以先理解下《Scalable IO in Java》这篇文章里说的一些 IO 处理模式，Netty 的<strong>线程模型</strong>如下图所示：</p>
<p><img src="assets/image-20200727213832939.png" alt="image-20200727213832939"></p>
<p>对比 NIO 的线程模型，NIO 的模型其实就一个 <strong>Selector 同时需要处理连接事件和读写事件</strong>。如果读写事件太多造成积压，这就造成连接事件得不到及时处理。一种升级的模型其实可以理解成有<strong>两个 Selector</strong>，一个专门用于处理连接事件，一个专门用于处理读写事件。所以一个 Selector 连接建立后，获取<strong>通道并注册到另一个 Selector 上</strong>，专门用于读写事件，这样就舒服多了。这种就可以成为<strong>一主一从</strong>结构。</p>
<p>其实 Netty 一般情况是 <strong>一主多从</strong>架构。可以<strong>设置有多个 Selector</strong>。也可以是<strong>多主多从</strong>架构。</p>
<h5 id="2-线程模型解释"><a href="#2-线程模型解释" class="headerlink" title="2. 线程模型解释"></a>2. 线程模型解释</h5><p>Netty 抽象出<strong>两组线程池</strong> <strong>BossGroup</strong> 和 <strong>WorkerGroup</strong>，BossGroup 专门负责接收<strong>客户端的连接</strong>，WorkerGroup 专门<strong>负责网络的读写</strong>。</p>
<p>BossGroup 和 WorkerGroup 类型都是 <strong>NioEventLoopGroup</strong>。NioEventLoopGroup 相当于一个<strong>事件循环线程组</strong>，这个组中含有多个事件循环线程， 每一个事件循环线程是 <strong>NioEventLoop</strong>。一个 <strong>NioEventLoop 可以理解为一个线程</strong>。每个 NioEventLoop <strong>都有一个 selector</strong>，相当于一个线程就有一个 Selector，用于监听注册在其上的 socketChannel 的网络通讯。</p>
<p>每个 <strong>Boss  NioEventLoop 线程</strong>内部循环执行的步骤有 3 步：</p>
<ul>
<li>处理 <strong>==accept 事件==</strong> , 与 client 建立连接 , 生成 <strong>NioSocketChannel 通道</strong>。</li>
<li>将 <strong>NioSocketChannel</strong> <strong>注册到某个 Worker NioEventLoop 的 selector 之上</strong>。</li>
<li>处理<strong>任务队列</strong>的任务 ， 即 runAllTasks。</li>
</ul>
<p>每个 <strong>Worker  NioEventLoop</strong> 线程循环执行的步骤：</p>
<ul>
<li><strong>轮询注册</strong>到自己 <strong>Selector</strong> 上的所有 <strong>NioSocketChannel</strong> 的 <strong>read, write</strong> 事件（只处理读写事件）。</li>
<li>处理 I/O 事件， 即 <strong>read , write 事件</strong>， 并在对应 <strong>NioSocketChannel</strong> 处理业务。</li>
<li>runAllTasks 处理<strong>任务队列 TaskQueue 的任务</strong> ，一些耗时的业务处理一般可以放入 <strong>TaskQueue</strong> 中慢慢处理，这样不影响数据在 <strong>pipeline</strong> 中的流动处理。</li>
</ul>
<p>每个 Worker NIOEventLoop 处理 <strong>NioSocketChannel</strong> 业务时，会使用 <strong>pipeline</strong> (管道)，管道中维护了很多 <strong>handler</strong> 处理器用来处理 channel 中的数据。</p>
<p>注意：一个 NioEventLoop 就是一个<strong>线程池</strong>，只不过里面只有<strong>一个</strong>线程，<strong>每个线程</strong>都有一个 <strong>TaskQueue</strong>，用于执行比较耗时的任务。</p>
<h4 id="Netty模块组件"><a href="#Netty模块组件" class="headerlink" title="Netty模块组件"></a>Netty模块组件</h4><h5 id="1-Bootstrap、ServerBootstrap"><a href="#1-Bootstrap、ServerBootstrap" class="headerlink" title="1. Bootstrap、ServerBootstrap"></a>1. Bootstrap、ServerBootstrap</h5><p>Bootstrap 意思是<strong>引导类</strong>，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是<strong>配置整个 Netty 程序并串联各个组件</strong>。<strong>Bootstrap</strong> 类是<strong>客户端启动引导类</strong>，<strong>ServerBootstrap</strong> 是<strong>服务端启动引导类</strong>。</p>
<h5 id="2-Future、ChannelFuture"><a href="#2-Future、ChannelFuture" class="headerlink" title="2. Future、ChannelFuture"></a>2. Future、ChannelFuture</h5><p>Netty 中所有的 IO 操作都是<strong>异步</strong>的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <strong>Future 和 ChannelFutures</strong> 注册一个监听，当<strong>操作执行成功或失败时监听会自动触发注册的监听事件</strong>。</p>
<h5 id="3-Channel"><a href="#3-Channel" class="headerlink" title="3. Channel"></a>3. Channel</h5><p>Netty 网络通信的组件，能够用于执行网络 I/O 操作。Channel 为用户提供：</p>
<ul>
<li>当前网络连接的<strong>通道的状态</strong>（例如是否打开？是否已连接？）</li>
<li>网络连接的<strong>配置参数</strong> （例如接收缓冲区大小）</li>
<li>提供异步的<strong>网络 I/O 操作</strong>(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成。</li>
<li>调用立即返回一个 <strong>ChannelFuture</strong> 实例，通过注册监听器到 <strong>ChannelFuture</strong> 上，可以 I/O 操作成功、失败或取消时回调通知调用方。</li>
<li>支持关联 I/O 操作与对应的处理程序。</li>
</ul>
<p><strong>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。</strong></p>
<p>下面是一些常用的 Channel 类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NioSocketChannel <span class="comment">// 异步的客户端 TCP Socket连接</span></span><br><span class="line">NioServerSocketChannel 	<span class="comment">// 异步的服务器端TCP Socket连接</span></span><br><span class="line">NioDatagramChannel		<span class="comment">// 异步的UDP连接</span></span><br><span class="line">NioSctpChannel	<span class="comment">// 异步的客户端 Sctp 连接</span></span><br><span class="line">NioSctpServerChannel	<span class="comment">// 异步的Sctp服务器端连接，这些通道涵盖了UDP和TCP网络IO以及文件IO</span></span><br></pre></td></tr></table></figure>

<h5 id="4-Selector"><a href="#4-Selector" class="headerlink" title="4. Selector"></a>4. Selector</h5><p>Netty 基于 <strong>Selector 对象实现 I/O 多路复用</strong>，通过 <strong>Selector 一个线程可以监听多个连接的 Channel 事件</strong>。当向一个 <strong>Selector 中注册 Channel 后</strong>，Selector 内部的机制就可以<strong>自动不断地查询(Select) 这些注册的 Channel</strong> 是否有<strong>已就绪的 I/O 事件</strong>（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用<strong>一个线程</strong>高效地管理多个 Channel 。</p>
<h5 id="5-NioEventLoop"><a href="#5-NioEventLoop" class="headerlink" title="5. NioEventLoop"></a>5. NioEventLoop</h5><p>NioEventLoop 维护了<strong>一个线程和任务队列</strong>，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的 <strong>run 方法</strong>，执行 I/O 任务和非 I/O 任务：</p>
<ul>
<li><p><strong>IO 任务</strong>，即 <strong>selectionKey</strong> 中 ready 的事件，如 <strong>accept、connect、read、write</strong> 等，由 <strong>processSelectedKeys</strong> 方法触发。</p>
</li>
<li><p><strong>非 IO 任务</strong>，添加到 <strong>taskQueue</strong> 中的任务，如 <strong>register0、bind0</strong> 等任务，由 <strong>runAllTasks 方法触发</strong>。</p>
</li>
</ul>
<h5 id="6-NioEventLoopGroup"><a href="#6-NioEventLoopGroup" class="headerlink" title="6. NioEventLoopGroup"></a>6. NioEventLoopGroup</h5><p>NioEventLoopGroup 主要管理 <strong>EventLoop 的生命周期</strong>，可以理解为一个<strong>线程池</strong>，内部维护了<strong>一组线程</strong>，每个线程(NioEventLoop)负责处理<strong>多个 Channel 上的事件</strong>，而<strong>一个 Channel 只对应于一个线程</strong>。</p>
<h5 id="7-ChannelHandler"><a href="#7-ChannelHandler" class="headerlink" title="7. ChannelHandler"></a>7. ChannelHandler</h5><p><strong>ChannelHandler</strong> 是一个<strong>接口</strong>，<strong>处理 I/O 事件或拦截 I/O 操作</strong>，并将其<strong>转发到其 ChannelPipeline</strong>(业务处理链)中的下一个处理程序。</p>
<p>ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现。为了使用方便可以继承它的<strong>子类</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelInboundHandler 	<span class="comment">// 用于处理入站I/O事件</span></span><br><span class="line">ChannelOutboundHandler 	<span class="comment">// 用于处理出站I/O操作</span></span><br></pre></td></tr></table></figure>

<p>或者使用以下<strong>适配器</strong>类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelInboundHandlerAdapter  <span class="comment">// 用于处理入站I/O事件</span></span><br><span class="line">ChannelOutboundHandlerAdapter <span class="comment">// 用于处理出站I/O操作</span></span><br></pre></td></tr></table></figure>

<h5 id="8-ChannelHandlerContext"><a href="#8-ChannelHandlerContext" class="headerlink" title="8. ChannelHandlerContext"></a>8. ChannelHandlerContext</h5><p>保存 <strong>Channel 相关</strong>的<strong>所有上下文信息</strong>，同时关联一个 <strong>ChannelHandler 对象</strong>。</p>
<h5 id="9-ChannelPipline"><a href="#9-ChannelPipline" class="headerlink" title="9. ChannelPipline"></a>9. ChannelPipline</h5><p>用于<strong>保存 ChannelHandler 实现类的 List</strong>，用于<strong>处理或拦截 Channel 的入站事件和出站操作</strong>。ChannelPipeline 实现了一种<strong>高级形式的拦截过滤器模式</strong>，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何<strong>相互交互</strong>。</p>
<p>在 Netty 中<strong>每个 Channel 都有且仅有一个 ChannelPipeline 与之对应</strong>，它们的组成关系如下： </p>
<p><img src="assets/image-20200727214255181.png" alt="image-20200727214255181"></p>
<p>一个 Channel 包含了一个 <strong>ChannelPipeline</strong>，而 ChannelPipeline 中又维护了一个由 <strong>ChannelHandlerContext</strong> 组成的<strong>双向链表</strong>，并且每个 ChannelHandlerContext 中又<strong>关联着一个 ChannelHandler</strong>。</p>
<p><strong>read</strong> 事件(入站事件)和 <strong>write</strong> 事件(出站事件)在一个<strong>双向链表</strong>中，<strong>入站</strong>事件会从链表 <strong>head 往后传递</strong>到最后一个入站的 handler，<strong>出站</strong>事件会从链表 <strong>tail 往前传递</strong>到最前一个出站的 handler，<strong>两种类型的 handler 互不干扰</strong>。</p>
<h4 id="基于Netty的简单客户端服务器实现"><a href="#基于Netty的简单客户端服务器实现" class="headerlink" title="基于Netty的简单客户端服务器实现"></a>基于Netty的简单客户端服务器实现</h4><p>Netty 的 maven 依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.35.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>服务端代码</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建两个线程组bossGroup和workerGroup, 含有的子线程NioEventLoop的个数默认为cpu核数的两倍</span></span><br><span class="line">        <span class="comment">// bossGroup只是处理连接请求 ,真正的和客户端业务处理，会交给workerGroup完成</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 这里设置有10个Selector</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建服务器端的启动对象</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">// 使用链式编程来配置参数</span></span><br><span class="line">            <span class="comment">// 设置两个线程组</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                <span class="comment">// 使用NioServerSocketChannel作为服务器的通道实现</span></span><br><span class="line">                .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                // 初始化服务器连接队列大小，服务端处理客户端连接请求是顺序处理的,所以同一时间只能处理一个客户端连接。</span></span><br><span class="line"><span class="class">                // 多个客户端同时来的时候,服务端将不能处理的客户端连接请求放在队列中等待处理</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 1024)</span></span><br><span class="line"><span class="class">                // 创建通道初始化对象，设置初始化参数 这个<span class="title">SocketChannel</span>是<span class="title">Netty</span>里面的，不是<span class="title">NIO</span>里面那个</span></span><br><span class="line"><span class="class">                .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                    <span class="comment">// 可以把下面的理解为一个回调函数</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 对workerGroup的SocketChannel设置处理器</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            System.out.println(<span class="string">"netty server start。。"</span>);</span><br><span class="line">            <span class="comment">// 绑定一个端口并且同步, 生成了一个ChannelFuture异步对象，通过isDone()等方法可以判断异步事件的执行情况</span></span><br><span class="line">            <span class="comment">// 启动服务器(并绑定端口)，bind是异步操作，sync方法是等待异步操作执行完毕</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 给cf注册监听器，监听我们关心的事件</span></span><br><span class="line">            <span class="comment">/*cf.addListener(new ChannelFutureListener() &#123;</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void operationComplete(ChannelFuture future) throws Exception &#123;</span></span><br><span class="line"><span class="comment">                    if (cf.isSuccess()) &#123;</span></span><br><span class="line"><span class="comment">                        System.out.println("监听端口9000成功");</span></span><br><span class="line"><span class="comment">                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">                        System.out.println("监听端口9000失败");</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;);*/</span></span><br><span class="line">            <span class="comment">// 对通道关闭进行监听，closeFuture是异步操作，监听通道关闭</span></span><br><span class="line">            <span class="comment">// 通过sync方法同步等待通道关闭处理完毕，这里会阻塞等待通道关闭完成</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端 Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义Handler需要继承netty规定好的某个HandlerAdapter(规范)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端发送的数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象,含有通道channel,管道pipeline</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 就是客户端发送的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务器读取线程 "</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="comment">//Channel channel = ctx.channel();</span></span><br><span class="line">        <span class="comment">//ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站</span></span><br><span class="line">        <span class="comment">// 将msg转成一个ByteBuf，类似NIO的ByteBuffer</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"客户端发送消息是:"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕处理方法 说明上一个channelRead方法读完</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 上一个方法执行完之后写数据到客户端</span></span><br><span class="line">        ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"HelloClient"</span>.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">        ctx.writeAndFlush(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常, 一般是需要关闭通道</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause 异常原因</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Netty客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端需要一个事件循环组</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 创建客户端启动对象</span></span><br><span class="line">            <span class="comment">// 注意客户端使用的不是ServerBootstrap而是Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="comment">// 设置相关参数 // 设置线程组</span></span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    <span class="comment">// 使用NioSocketChannel作为客户端的通道实现</span></span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 加入处理器</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"netty client start。。"</span>);</span><br><span class="line">            <span class="comment">// 启动客户端去连接服务器端</span></span><br><span class="line">            ChannelFuture cf = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 对通道关闭进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端 Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端处理类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当客户端连接服务器完成就会触发该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"HelloServer"</span>.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">        ctx.writeAndFlush(buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时会触发，即服务端发送数据给客户端</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">"收到服务端的消息:"</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">"服务端的地址： "</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Netty 框架的目标就是让业务逻辑从网络基础应用编码中分离出来，因此可以专注业务的开发，而不需写一大堆类似 NIO 的网络处理操作。</p>
<h4 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h4><p>从结构上来说，ByteBuf 由一串<strong>字节数组</strong>构成，数组中每个<strong>字节用来存放信息</strong>。</p>
<p>ByteBuf 提供了<strong>两个索引</strong>，一个用于<strong>读取</strong>数据，一个用于<strong>写入</strong>数据。这两个索引通过在<strong>字节数组中移动</strong>，来定位需要读或者写信息的位置。</p>
<p>当从 ByteBuf 读取时，它的 <strong>readerIndex</strong>（读索引）将会根据读取的字节数<strong>递增</strong>。</p>
<p>当写 ByteBuf 时，它的 <strong>writerIndex</strong> 也会根据写入的字节数进行<strong>递增</strong>。</p>
<img src="assets/image-20200727214512299.png" alt="image-20200727214512299" style="zoom:45%;" />

<p>极限的<strong>情况是 readerIndex 刚好读到了 writerIndex 写入的地方</strong>。</p>
<p>如果 readerIndex 超过了 writerIndex 的时候，Netty 会抛出 IndexOutOfBoundsException 异常。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ByteBuf测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyByteBufTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建byteBuf对象，该对象内部包含一个字节数组byte[10]</span></span><br><span class="line">        <span class="comment">// 通过readerindex和writerIndex和capacity，将buffer分成三个区域</span></span><br><span class="line">        <span class="comment">// 已经读取的区域：[0,readerindex)</span></span><br><span class="line">        <span class="comment">// 可读取的区域：[readerindex, writerIndex)</span></span><br><span class="line">        <span class="comment">// 可写的区域: [writerIndex, capacity)</span></span><br><span class="line">        ByteBuf byteBuf = Unpooled.buffer(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// (ridx: 0, widx: 0, cap: 10)</span></span><br><span class="line">        System.out.println(<span class="string">"byteBuf="</span> + byteBuf);</span><br><span class="line">        <span class="comment">// 写入8个字节</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            byteBuf.writeByte(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (ridx: 0, widx: 8, cap: 10)这里writeIndex变成了8</span></span><br><span class="line">        System.out.println(<span class="string">"byteBuf="</span> + byteBuf);</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(byteBuf.getByte(i) + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (ridx: 0, widx: 8, cap: 10) readIndex没变，调用getByte()方法不会改变readIndex</span></span><br><span class="line">        System.out.println(<span class="string">"byteBuf="</span> + byteBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次调用读数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.print(byteBuf.readByte() + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// (ridx: 5, widx: 8, cap: 10),readIndex变化，调用readByte()方法会改变readIndex</span></span><br><span class="line">        System.out.println(<span class="string">"byteBuf="</span> + byteBuf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用Unpooled工具类创建ByteBuf</span></span><br><span class="line">        ByteBuf byteBuf2 = Unpooled.copiedBuffer(<span class="string">"hello,Cindy!"</span>, CharsetUtil.UTF_8);</span><br><span class="line">        <span class="comment">// 使用相关的方法</span></span><br><span class="line">        <span class="keyword">if</span> (byteBuf2.hasArray()) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] content = byteBuf2.array();</span><br><span class="line">            <span class="comment">// 将content转成字符串</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(content, CharsetUtil.UTF_8));</span><br><span class="line">            System.out.println(<span class="string">"byteBuf="</span> + byteBuf2);</span><br><span class="line">            System.out.println(byteBuf2.readerIndex()); <span class="comment">// 0</span></span><br><span class="line">            System.out.println(byteBuf2.writerIndex()); <span class="comment">// 12</span></span><br><span class="line">            System.out.println(byteBuf2.capacity());    <span class="comment">// 36</span></span><br><span class="line">			 <span class="comment">// 获取数组0这个位置的字符h的ascii码，h=104</span></span><br><span class="line">            System.out.println(byteBuf2.getByte(<span class="number">0</span>)); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = byteBuf2.readableBytes();         <span class="comment">// 可读的字节数  12</span></span><br><span class="line">            System.out.println(<span class="string">"len="</span> + len);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用for取出各个字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                System.out.print((<span class="keyword">char</span>) byteBuf2.getByte(i) + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 范围读取</span></span><br><span class="line">            System.out.println(byteBuf2.getCharSequence(<span class="number">0</span>, <span class="number">6</span>, CharsetUtil.UTF_8));</span><br><span class="line">            System.out.println(byteBuf2.getCharSequence(<span class="number">6</span>, <span class="number">6</span>, CharsetUtil.UTF_8));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">byteBuf=UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: <span class="number">0</span>, widx: <span class="number">0</span>, cap: <span class="number">10</span>)</span><br><span class="line">byteBuf=UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: <span class="number">0</span>, widx: <span class="number">8</span>, cap: <span class="number">10</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> byteBuf=UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: <span class="number">0</span>, widx: <span class="number">8</span>, cap: <span class="number">10</span>)</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> byteBuf=UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: <span class="number">5</span>, widx: <span class="number">8</span>, cap: <span class="number">10</span>)</span><br><span class="line">hello,Cindy!                        </span><br><span class="line">byteBuf=UnpooledByteBufAllocator$InstrumentedUnpooledUnsafeHeapByteBuf(ridx: <span class="number">0</span>, widx: <span class="number">12</span>, cap: <span class="number">36</span>)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">104</span></span><br><span class="line">len=<span class="number">12</span></span><br><span class="line">h e l l o , C i n d y ! hello,</span><br><span class="line">Cindy!</span><br></pre></td></tr></table></figure>



<h4 id="基于Netty的群聊系统"><a href="#基于Netty的群聊系统" class="headerlink" title="基于Netty的群聊系统"></a>基于Netty的群聊系统</h4><p>腾讯课堂聊天窗口就是一个聊天室（实现群聊）。</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 群聊服务器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 1024)</span></span><br><span class="line"><span class="class">                    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            <span class="comment">// 向pipeline加入解码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">// 向pipeline加入编码器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            <span class="comment">// 加入自己的业务处理handler</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> ChatServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            System.out.println(<span class="string">"聊天室server启动。。"</span>);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 关闭通道</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端 Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天室服务器处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * GlobalEventExecutor.INSTANCE是全局的事件执行器，是一个单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ChannelGroup channelGroup = <span class="keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);</span><br><span class="line"></span><br><span class="line">    SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示Channel处于就绪状态,提示上线</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">// 将该客户加入聊天的信息推送给其它在线的客户端</span></span><br><span class="line">        <span class="comment">// 该方法会将channelGroup中所有的channel遍历，并发送消息</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() + <span class="string">" 上线了 "</span> + sdf.format(<span class="keyword">new</span></span><br><span class="line">                                                                                            java.util.Date())+ <span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">// 将当前channel加入到channelGroup中</span></span><br><span class="line">        channelGroup.add(channel);</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" 上线了"</span>+ <span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示channel处于不活动状态,提示离线了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">// 将客户离开信息推送给当前在线的客户</span></span><br><span class="line">        channelGroup.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() + <span class="string">" 下线了"</span>+ <span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">" 下线了"</span>+ <span class="string">"\n"</span>);</span><br><span class="line">        System.out.println(<span class="string">"ChannelGroup size="</span> + channelGroup.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到当前channel</span></span><br><span class="line">        Channel channel = ctx.channel();</span><br><span class="line">        <span class="comment">// 这时我们遍历channelGroup里面所有的Channel,根据不同的情况,回送不同的消息</span></span><br><span class="line">        channelGroup.forEach(ch -&gt; &#123;</span><br><span class="line">            <span class="comment">// 不是当前的 channel,转发消息</span></span><br><span class="line">            <span class="keyword">if</span> (channel != ch) &#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">"[客户端]"</span> + channel.remoteAddress() + <span class="string">" 发送了消息："</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">                <span class="comment">// 回显自己发送的消息给自己</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ch.writeAndFlush(<span class="string">"[自己]发送了消息："</span> + msg + <span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 关闭通道</span></span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 群聊客户端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">// 添加客户端处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> ChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 得到channel</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">"========"</span> + channel.localAddress() + <span class="string">"========"</span>);</span><br><span class="line">            <span class="comment">// 客户端需要输入信息,创建一个扫描器</span></span><br><span class="line">            Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                String msg = scanner.nextLine();</span><br><span class="line">                <span class="comment">// 通过channel发送到服务器端</span></span><br><span class="line">                channel.writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端 Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收到数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 打印出接收到的数据</span></span><br><span class="line">        System.out.println(msg.trim());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Netty编解码"><a href="#Netty编解码" class="headerlink" title="Netty编解码"></a>Netty编解码</h4><h5 id="1-编解码组件"><a href="#1-编解码组件" class="headerlink" title="1. 编解码组件"></a>1. 编解码组件</h5><p>Netty 涉及到<strong>编解码的组件</strong>有 <strong>Channel、ChannelHandler、ChannelPipe</strong> 等，先大概了解下这几个组件的作用。</p>
<h6 id="1-ChannelHandler"><a href="#1-ChannelHandler" class="headerlink" title="(1) ChannelHandler"></a>(1) ChannelHandler</h6><p><strong>ChannelHandler</strong> 充当了<strong>处理入站和出站数据的应用程序逻辑容器</strong>。例如，实现 <strong>ChannelInboundHandler</strong> 接口（或 ChannelInboundHandlerAdapter），就可以接收<strong>入站事件</strong>和数据，这些数据随后会<strong>被应用程序的业务逻辑处理</strong>。当要给连接的客户端<strong>发送响应</strong>时，也可以从 ChannelInboundHandler <strong>冲刷</strong>数据。业务逻辑通常写在一个或者<strong>多个 ChannelInboundHandler</strong> 中。ChannelOutboundHandler 原理一样，只不过它是用来<strong>处理出站数据</strong>的。</p>
<h6 id="2-ChannelPipeline"><a href="#2-ChannelPipeline" class="headerlink" title="(2) ChannelPipeline"></a>(2) ChannelPipeline</h6><p>ChannelPipeline 是 <strong>ChannelHandler 链的容器</strong>。<strong>以客户端应用程序为例</strong>，如果事件的运动方向是从客户端到服务端的，那么称这些事件为<strong>出站的</strong>，即客户端发送给服务端的数据会通过 pipeline 中的一系列 <strong>ChannelOutboundHandler(ChannelOutboundHandler 调用是从 tail 到 head 方向逐个调用每个 handler 的逻辑)</strong>，并被这些 Handler 处理。反之则称为<strong>入站</strong>，入站只调用 pipeline 里的 <strong>ChannelInboundHandler</strong> 逻辑<strong>(ChannelInboundHandler 调用是从 head 到 tail 方向逐个调用每个 handler 的逻辑)</strong>。</p>
<p>ChannelHandler 链只有一个链，是一个<strong>双向链表</strong>。</p>
<p><img src="assets/image-20200727214601586.png" alt="image-20200727214601586"></p>
<h5 id="2-编码解码器"><a href="#2-编码解码器" class="headerlink" title="2. 编码解码器"></a>2. 编码解码器</h5><p>当通过 Netty 发送或者<strong>接受一个消息</strong>的时候，就将会发生一次<strong>数据转换</strong>，需要将数据转换为<strong>二进制字节流</strong>。入站收到二进制字节流消息会被<strong>解码</strong>：从<strong>字节</strong>转换为另一种格式（比如 Java 对象）；如果是<strong>出站</strong>消息，它会被<strong>编码成字节</strong>。</p>
<p>如果<strong>不注册编解码器</strong>的话，发送消息需要像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = Unpooled</span><br><span class="line">    .copiedBuffer(<span class="string">"HelloClient"</span>.getBytes(CharsetUtil.UTF_8));</span><br><span class="line">ctx.writeAndFlush(buf);</span><br></pre></td></tr></table></figure>

<p>如果直接发送字符串是<strong>不行</strong>的，发不出去，除非<strong>注册一个编解码器</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.writeAndFlush(<span class="string">"Test"</span>);</span><br></pre></td></tr></table></figure>

<p>Netty 提供了一系列实用的<strong>编码解码器</strong>，他们都实现了 ChannelInboundHandler 或者 ChannelOutboundHandler 接口。在这些类中，<strong>channelRead</strong> 方法已经被<strong>覆写</strong>了。以入站为例，对于每个从入站 Channel 读取的消息，这个方法会被调用。随后，它将调用由已知<strong>解码器</strong>所提供的 <strong>decode</strong>() 方法进行解码，并将<strong>已经解码的字节</strong>转发给 ChannelPipeline 中的下一个 ChannelInboundHandler。</p>
<p>Netty 提供了很多编解码器，比如<strong>编解码字符串的 StringEncoder 和 StringDecoder</strong>，编解码对象的 ObjectEncoder 和 ObjectDecoder 等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 1024)</span></span><br><span class="line"><span class="class">    .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            <span class="comment">// 向pipeline加入解码器</span></span><br><span class="line">            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">            <span class="comment">// 向pipeline加入编码器</span></span><br><span class="line">            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">            <span class="comment">// 加入自己的业务处理handler</span></span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> ChatServerHandler());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>这里往 PipeLine 中注册编解码器，其实 <strong>StringEncoder 其实也是一个 ChannelHandler</strong>，所以 StringEncoder 也就是<strong>被加入到处理事件的 ChannelHandler 链中</strong>。StringDecoder 是一个 <strong>ChannelInboundHandler</strong>，而 StringEncoder 是一个 <strong>ChannelOutboundHandler</strong>，所以对于出站与入站只会调用其中的一个。ChannelOutboundHandler 和 ChannelInboundHandler 都是 ChannelHandler。</p>
<p>对于出站与入站事件都会经历一条 ChannelHandler 链进行处理，然而会根据出站还是入站事件选择对应的 ChannelHandler 进行处理，不符合的不管。<strong>出站事件只关注 ChannelOutboundHandler 的一些列 Handler，而入站事件只关注 ChannelInboundHandler 的一些列的 Handler。</strong>所以<strong>出站只会执行 StringEncoder 进行编码</strong>，而<strong>入站只会执行 StringDecoder 进行解码</strong>。</p>
<p>这里不同的 ChannelHandler <strong>加入处理链的顺序</strong>是有讲究的，如果是同一类型的，比如都是 ChannelOutboundHandler  则会<strong>有先后调用</strong>的顺序。</p>
<p>Netty 中有许多内置编解码器。比如有对象的编解码器 ObjectEncoder。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(group).channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">            pipeline.addLast(<span class="keyword">new</span> ObjectEncoder());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="3-自定义编解码器"><a href="#3-自定义编解码器" class="headerlink" title="3. 自定义编解码器"></a>3. 自定义编解码器</h5><p>也可以通过继承 <strong>ByteToMessageDecoder 和 MessageToByteEncoder 自定义编解码器</strong>。比如直接通过上下文发送一个 <strong>Long 型</strong>的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.writeAndFlush(<span class="number">2000L</span>);</span><br></pre></td></tr></table></figure>

<p>这里就可以自定义一个编解码器。</p>
<p><strong>解码器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteToLongDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ByteToLongDecoder decode 被调用"</span>);</span><br><span class="line">        <span class="comment">// 因为long8个字节, 需要判断有8个字节，才能读取一个long</span></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">            out.add(in.readLong());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编码器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongToByteEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"LongToByteEncoder encode被调用"</span>);</span><br><span class="line">        System.out.println(<span class="string">"msg="</span> + msg);</span><br><span class="line">        out.writeLong(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Netty粘包拆包"><a href="#Netty粘包拆包" class="headerlink" title="Netty粘包拆包"></a>Netty粘包拆包</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>TCP 粘包拆包是指发送方发送的<strong>若干数据包</strong>到接收方接收时<strong>粘成一包</strong>或某个<strong>数据包被拆开接收</strong>。如下图所示，client 发了两个数据包 D1 和 D2，但是 server 端可能会收到如下几种情况的数据。</p>
<img src="assets/image-20200727210845658.png" alt="image-20200727210845658" style="zoom:50%;" />

<p>代码示例：</p>
<p>改变上述聊天室的客户端代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            <span class="comment">// 添加客户端处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> ChatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>).sync();</span><br><span class="line">            <span class="comment">// 得到channel</span></span><br><span class="line">            Channel channel = channelFuture.channel();</span><br><span class="line">            System.out.println(<span class="string">"========"</span> + channel.localAddress() + <span class="string">"========"</span>);</span><br><span class="line">			<span class="comment">// 此处连接成功后直接连续发200个字符串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200</span>; i++) &#123;</span><br><span class="line">                channel.writeAndFlush(<span class="string">"Hello!NanoJava!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即让客户端连接成功后直接连续发200个字符串。</p>
<p>这时候看看服务端接收的消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">63873</span> 上线了</span><br><span class="line"></span><br><span class="line">Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!</span><br><span class="line">Hello!NanoJava!Hello!NanoJava!</span><br><span class="line">/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">63873</span> 下线了</span><br><span class="line"></span><br><span class="line">ChannelGroup size=<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这里就很明显的发生了粘包，多个包粘在了一起。</p>
<p><strong>为什么出现粘包现象</strong>：TCP 是<strong>面向连接</strong>的， 面向流的， 提供高可靠性服务。 收发两端（客户端和服务器端） 都要有<strong>成对的 socket</strong>，发送端为了将多个包更有效的发给对方，使用了<strong>优化方法（Nagle 算法）</strong>，将<strong>多次间隔较小且数据量小</strong>的数据， <strong>合并成一个大的数据块， 然后进行封包</strong>。 这样做虽然提高了效率， 但是接收端就<strong>难于分辨出完整的数据包</strong>了， 因为面向流的通信是<strong>无消息保护边界</strong>的。</p>
<h5 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h5><h6 id="1-报文固定长度"><a href="#1-报文固定长度" class="headerlink" title="(1) 报文固定长度"></a>(1) 报文固定长度</h6><p>客户端在发送数据包的时候，每个包都<strong>固定长度</strong>，比如 1024 个字节大小，如果客户端发送的数据长度不足 1024 个字节，则通过<strong>补充空格的方式补全到指定长度</strong>。</p>
<h6 id="2-添加报文分隔符"><a href="#2-添加报文分隔符" class="headerlink" title="(2) 添加报文分隔符"></a>(2) 添加报文分隔符</h6><p>每条数据有<strong>固定的格式</strong>（开始符、结束符），这种方法简单易行，但选择开始符和结束符的时候一定要注意每条数据的<strong>内部一定不能出现</strong>开始符或结束符。</p>
<p>比如客户端在每个包的<strong>末尾使用固定的分隔符</strong>，例如 <strong>\r\n</strong>，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的 \r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行<strong>合并</strong>，这样就得到了一个完整的包。</p>
<h6 id="3-发送长度"><a href="#3-发送长度" class="headerlink" title="(3) 发送长度"></a>(3) 发送长度</h6><p>将<strong>消息分为头部和消息体</strong>，在<strong>头部</strong>中保存有当前<strong>整个消息的长度</strong>，只有在读取到足够长度的消息之后才算是读到了一个完整的消息。</p>
<p>发送每条数据的时候，将数据的<strong>长度一并发送</strong>，比如可以选择<strong>每条数据的前 4 位是数据的长度</strong>，<strong>应用层</strong>处理时可以根据长度来判断每条数据的开始和结束。示例代码如下：这里就是<strong>自定义消息体并配合自定义的编解码器进行</strong>。</p>
<p>首先<strong>封装自定义的消息体</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义协议包</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageProtocol</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一次发送包体长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一次发送包体内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义<strong>编码器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义消息体编码器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">MyMessageProtocol</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, MyMessageProtocol msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyMessageEncoder encode 方法被调用"</span>);</span><br><span class="line">        out.writeInt(msg.getLen());</span><br><span class="line">        out.writeBytes(msg.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义<strong>解码器</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义消息体解码器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMessageDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"MyMessageDecoder decode被调用"</span>);</span><br><span class="line">        <span class="comment">// 需要将得到二进制字节码-&gt; MyMessageProtocol 数据包(对象)</span></span><br><span class="line">        System.out.println(in);</span><br><span class="line">		<span class="comment">// 先收int类型的字节代表是长度</span></span><br><span class="line">        <span class="keyword">if</span>(in.readableBytes() &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (length == <span class="number">0</span>)&#123;</span><br><span class="line">                length = in.readInt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (in.readableBytes() &lt; length) &#123;</span><br><span class="line">                System.out.println(<span class="string">"当前可读数据不够，继续等待。。"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] content = <span class="keyword">new</span> <span class="keyword">byte</span>[length];</span><br><span class="line">            <span class="keyword">if</span> (in.readableBytes() &gt;= length)&#123;</span><br><span class="line">                in.readBytes(content);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 封装成MyMessageProtocol对象，传递到下一个handler业务处理</span></span><br><span class="line">                MyMessageProtocol messageProtocol = <span class="keyword">new</span> MyMessageProtocol();</span><br><span class="line">                messageProtocol.setLen(length);</span><br><span class="line">                messageProtocol.setContent(content);</span><br><span class="line">                out.add(messageProtocol);</span><br><span class="line">            &#125;</span><br><span class="line">            length = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-Netty提供的解决方案"><a href="#3-Netty提供的解决方案" class="headerlink" title="3. Netty提供的解决方案"></a>3. Netty提供的解决方案</h5><h6 id="1-FixedLengthFrameDecoder"><a href="#1-FixedLengthFrameDecoder" class="headerlink" title="(1) FixedLengthFrameDecoder"></a>(1) FixedLengthFrameDecoder</h6><p>对于使用<strong>固定长度的粘包和拆包场景</strong>，可以使用 FixedLengthFrameDecoder，该解码一器会<strong>每次读取固定长度的消息</strong>，如果当前读取到的消息不足指定长度，那么就会<strong>等待</strong>下一个消息到达后进行补足。其使用也比较简单，只需要在<strong>构造函数中指定每个消息的长度</strong>即可。这里需要注意的是，FixedLengthFrameDecoder 只是一个<strong>解码器</strong>，Netty 也只提供了一个解码器，这是因为对于解码是需要等待下一个包的进行补全的，代码相对复杂，而对于编码器，用户可以自行编写，因为编码时只需要将不足指定长度的部分进行补全即可。</p>
<p>下面的示例中展示了如何使用 FixedLengthFrameDecoder 来进行粘包和拆包处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BACKLOG</span>, 1024)</span></span><br><span class="line"><span class="class">                .<span class="title">handler</span>(<span class="title">new</span> <span class="title">LoggingHandler</span>(<span class="title">LogLevel</span>.<span class="title">INFO</span>))</span></span><br><span class="line"><span class="class">                .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 这里将FixedLengthFrameDecoder添加</span></span><br><span class="line">                        <span class="comment">// 到pipeline中，指定固定长度为20</span></span><br><span class="line">                        ch.pipeline()</span><br><span class="line">                            .addLast(<span class="keyword">new</span> FixedLengthFrameDecoder(<span class="number">20</span>));</span><br><span class="line">                        <span class="comment">// 将前一步解码得到的数据转码为字符串</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                        <span class="comment">// 这里FixedLengthFrameEncoder是自定义的，</span></span><br><span class="line">                        <span class="comment">// 用于将长度不足20的消息进行补全空格</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> FixedLengthFrameEncoder(<span class="number">20</span>));</span><br><span class="line">                        <span class="comment">// 最终的数据处理</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture future = bootstrap.bind(port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> EchoServer().bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 pipeline 中，对于入栈数据，这里主要添加了 FixedLengthFrameDecoder 和StringDecoder，前面一个用于处理固定长度的消息的粘包和拆包问题，第二个则是将处理之后的消息转换为字符串。最后由 EchoServerHandler 处理最终得到的数据，处理完成后，将处理得到的数据交由 FixedLengthFrameEncoder 处理，该编码器是自定义实现，主要作用是将长度不足 20 的消息进行空格补全。下面是自定义 FixedLengthFrameEncoder 的实现代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FixedLengthFrameEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FixedLengthFrameEncoder</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, String msg, ByteBuf out)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 对于超过指定长度的消息，这里直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (msg.length() &gt; length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(</span><br><span class="line">                <span class="string">"message length is too large, it's limited "</span> + length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果长度不足，则进行补全</span></span><br><span class="line">        <span class="keyword">if</span> (msg.length() &lt; length) &#123;</span><br><span class="line">            msg = addSpace(msg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer(msg.getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行空格补全</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">addSpace</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(msg);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - msg.length(); i++) &#123;</span><br><span class="line">            builder.append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 FixedLengthFrameEncode r实现了 <strong>decode</strong>() 方法，在该方法中，主要是将消息长度不足 20 的消息进行空格补全。</p>
<h6 id="2-LineBasedFrameDecoder与DelimiterBasedFrameDecoder"><a href="#2-LineBasedFrameDecoder与DelimiterBasedFrameDecoder" class="headerlink" title="(2) LineBasedFrameDecoder与DelimiterBasedFrameDecoder"></a>(2) LineBasedFrameDecoder与DelimiterBasedFrameDecoder</h6><p>对于通过<strong>分隔符进行粘包和拆包问题的处理</strong>，Netty 提供了两个编解码的类，LineBasedFrameDecoder 和 DelimiterBasedFrameDecoder。这里 LineBasedFrameDecoder 的作用主要是通过<strong>换行符</strong>，即 \n 或者 \r\n 对数据进行处理；而 DelimiterBasedFrameDecoder 的作用则是通过<strong>用户指定的分隔符</strong>对数据进行粘包和拆包处理。同样的，这两个类都是<strong>解码器类</strong>，而对于数据的编码，也即在每个数据包最后添加换行符或者指定分割符的部分需要用户自行进行处理。这里以 DelimiterBasedFrameDecoder 为例进行讲解，如下是 EchoServer 中使用该类的代码片段，其余部分与前面的例子中的完全一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String delimiter = <span class="string">"_$"</span>;</span><br><span class="line">    <span class="comment">// 将delimiter设置到DelimiterBasedFrameDecoder中，经过该解码一器进行处理之后，源数据将会</span></span><br><span class="line">    <span class="comment">// 被按照_$进行分隔，这里1024指的是分隔的最大长度，即当读取到1024个字节的数据之后，若还是未</span></span><br><span class="line">    <span class="comment">// 读取到分隔符，则舍弃当前数据段，因为其很有可能是由于码流紊乱造成的</span></span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">1024</span>,</span><br><span class="line">        Unpooled.wrappedBuffer(delimiter.getBytes())));</span><br><span class="line">    <span class="comment">// 将分隔之后的字节数据转换为字符串数据</span></span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">    <span class="comment">// 这是我们自定义的一个编码器，主要作用是在返回的响应数据最后添加分隔符</span></span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> DelimiterBasedFrameEncoder(delimiter));</span><br><span class="line">    <span class="comment">// 最终处理数据并且返回响应的handler</span></span><br><span class="line">    ch.pipeline().addLast(<span class="keyword">new</span> EchoServerHandler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 pipeline 的设置中，添加的解码一器主要有 DelimiterBasedFrameDecoder 和 StringDecoder，经过这两个处理器处理之后，接收到的<strong>字节流就会被分隔</strong>，并且转换为字符串数据，最终交由 EchoServerHandler 处理。这里 DelimiterBasedFrameEncoder 是<strong>自定义的编码器</strong>，其主要作用是在返回的响应数据之后添加分隔符。如下是该编码器的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelimiterBasedFrameEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String delimiter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelimiterBasedFrameEncoder</span><span class="params">(String delimiter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delimiter = delimiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, String msg, ByteBuf out)</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 在响应的数据后面添加分隔符</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.wrappedBuffer((msg + delimiter).getBytes()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-LengthFieldBasedFrameDecoder与LengthFieldPrepender"><a href="#3-LengthFieldBasedFrameDecoder与LengthFieldPrepender" class="headerlink" title="(3) LengthFieldBasedFrameDecoder与LengthFieldPrepender"></a>(3) LengthFieldBasedFrameDecoder与LengthFieldPrepender</h6><p>这里 LengthFieldBasedFrameDecoder 与 LengthFieldPrepende r需要<strong>配合</strong>起来使用，其实本质上来讲，这两者一个是解码，一个是编码的关系。它们<strong>处理粘拆包的主要思想是在生成的数据包中添加一个长度字段，用于记录当前数据包的长度</strong>。LengthFieldBasedFrameDecoder 会按照参数指定的包长度偏移量数据对接收到的数据进行解码，从而得到目标消息体数据；而 LengthFieldPrepender 则会在响应的数据前面添加指定的字节数据，这个字节数据中保存了当前消息体的整体字节数据长度。LengthFieldBasedFrameDecoder 的解码过程如下图所示：</p>
<img src="assets/image-20200727234357801.png" alt="image-20200727234357801" style="zoom:47%;" />



<h4 id="Netty心跳检测机制"><a href="#Netty心跳检测机制" class="headerlink" title="Netty心跳检测机制"></a>Netty心跳检测机制</h4><h5 id="1-心跳机制概述"><a href="#1-心跳机制概述" class="headerlink" title="1. 心跳机制概述"></a>1. 心跳机制概述</h5><p><strong>心跳</strong>即在 TCP <strong>长连接</strong>中，客户端和服务器之间<strong>定期发送的一种特殊的数据包</strong>，通知对方<strong>自己还在线</strong>，以确保 TCP 连接的有效性。这可以用于<strong>检测连接断开</strong>的情况，比如客户端<strong>直接断电</strong>，导致服务端并不知道已经断线的情况。</p>
<p>在 Netty 中, 实现心跳机制的关键是 <strong>IdleStateHandler</strong>, 看下它的构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">int</span> readerIdleTimeSeconds, <span class="keyword">int</span> writerIdleTimeSeconds, <span class="keyword">int</span> allIdleTimeSeconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>((<span class="keyword">long</span>)readerIdleTimeSeconds, (<span class="keyword">long</span>)writerIdleTimeSeconds, (<span class="keyword">long</span>)allIdleTimeSeconds, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释下<strong>三个参数</strong>的含义：</p>
<ul>
<li><strong>readerIdleTimeSeconds</strong>：读超时。即当在指定的时间间隔内没有从 Channel 读取到数据时，会触发一个 READER_IDLE 的 IdleStateEvent 事件。</li>
<li><strong>writerIdleTimeSeconds</strong>：写超时。即当在指定的时间间隔内没有数据写入到 Channel 时，会触发一个 WRITER_IDLE 的 IdleStateEvent 事件。</li>
<li><strong>allIdleTimeSeconds</strong>：读/写超时。即当在指定的时间间隔内<strong>没有读或写操作时</strong>，会触发一个 ALL_IDLE 的 IdleStateEvent 事件。</li>
</ul>
<p>注：这三个参数默认的时间单位是<strong>秒</strong>。若需要指定其他时间单位，可以使用另一个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IdleStateHandler(<span class="keyword">boolean</span> observeOutput, <span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime, TimeUnit unit)</span><br></pre></td></tr></table></figure>

<p>要实现 Netty <strong>服务端心跳检测机制</strong>需要在服务器端的 <strong>ChannelInitializer</strong> 中加入如下的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br></pre></td></tr></table></figure>

<p>这里 IdleStateHandler 是 Netty 提供的一种 <strong>ChannelHandler</strong>。</p>
<h5 id="2-心跳机制源码分析"><a href="#2-心跳机制源码分析" class="headerlink" title="2. 心跳机制源码分析"></a>2. 心跳机制源码分析</h5><p>初步地看下 IdleStateHandler 源码，先看下 IdleStateHandler 中的 <strong>channelRead 方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readerIdleTimeNanos &gt; <span class="number">0</span> || allIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        reading = <span class="keyword">true</span>;</span><br><span class="line">        firstReaderIdleEvent = firstAllIdleEvent = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里对消息进行透传</span></span><br><span class="line">    ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后一句代码其实表示该方法<strong>只是进行了透传</strong>，不做任何业务逻辑处理，让 channelPipe 中的<strong>下一个</strong> handler 处理 channelRead 方法。</p>
<p>再看看 <strong>channelActive</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// This method will be invoked only if this handler was added</span></span><br><span class="line">    <span class="comment">// before channelActive() event is fired.  If a user adds this handler</span></span><br><span class="line">    <span class="comment">// after the channelActive() event, initialize() will be called by beforeAdd().</span></span><br><span class="line">    <span class="comment">// 重要</span></span><br><span class="line">    initialize(ctx);</span><br><span class="line">    <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有个 <strong>initialize</strong> 的方法，这是 IdleStateHandler 的<strong>精髓</strong>，接着探究：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Avoid the case where destroy() is called before scheduling timeouts.</span></span><br><span class="line">    <span class="comment">// See: https://github.com/netty/netty/issues/143</span></span><br><span class="line">    <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state = <span class="number">1</span>;</span><br><span class="line">    initOutputChanged(ctx);</span><br><span class="line"></span><br><span class="line">    lastReadTime = lastWriteTime = ticksInNanos();</span><br><span class="line">    <span class="keyword">if</span> (readerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">new</span> ReaderIdleTimeoutTask(ctx),</span><br><span class="line">                                     readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        writerIdleTimeout = schedule(ctx, <span class="keyword">new</span> WriterIdleTimeoutTask(ctx),</span><br><span class="line">                                     writerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (allIdleTimeNanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        allIdleTimeout = schedule(ctx, <span class="keyword">new</span> AllIdleTimeoutTask(ctx),</span><br><span class="line">                                  allIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边会触发一个 <strong>Task</strong>，<strong>ReaderIdleTimeoutTask</strong>，这个 task 里的 <strong>run 方法源码</strong>是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nextDelay = readerIdleTimeNanos;</span><br><span class="line">    <span class="keyword">if</span> (!reading) &#123;</span><br><span class="line">        <span class="comment">// (1)当前时间减去最后一次channelRead方法调用的时间</span></span><br><span class="line">        nextDelay -= ticksInNanos() - lastReadTime;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// (2)说明超时了</span></span><br><span class="line">    <span class="keyword">if</span> (nextDelay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Reader is idle - set a new timeout and notify the callback.</span></span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> first = firstReaderIdleEvent;</span><br><span class="line">        firstReaderIdleEvent = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IdleStateEvent event = newIdleStateEvent(IdleState.READER_IDLE, first);</span><br><span class="line">            <span class="comment">// (3)触发下一个handler的userEventTriggered方法</span></span><br><span class="line">            channelIdle(ctx, event);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ctx.fireExceptionCaught(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Read occurred before the timeout - set a new timeout with shorter delay.</span></span><br><span class="line">        readerIdleTimeout = schedule(ctx, <span class="keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(1) 处代码是用当前时间<strong>减去最后一次 channelRead 方法调用的时间</strong>，假如这个结果是 6s，说明最后一次调用 channelRead 已经是 6s 之前的事情了，如果设置的是 5s，那么 nextDelay 则为 -1，说明<strong>超时了</strong>，那么 (3) 处代码则会触发下一个 handler 的 <strong>userEventTriggered</strong> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelIdle</span><span class="params">(ChannelHandlerContext ctx, IdleStateEvent evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireUserEventTriggered(evt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<strong>没有超时则不触发</strong> userEventTriggered 方法。</p>
<h5 id="3-心跳检测代码示例"><a href="#3-心跳检测代码示例" class="headerlink" title="3. 心跳检测代码示例"></a>3. 心跳检测代码示例</h5><p>Netty 心跳检测代码。服务端示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap.group(boss, worker)</span><br><span class="line">                .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 得到Pipeline</span></span><br><span class="line">                        ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                        <span class="comment">// 添加编解码器</span></span><br><span class="line">                        pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                        pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                        <span class="comment">// IdleStateHandler的readerIdleTime参数指定超过3秒</span></span><br><span class="line">                        <span class="comment">// 还没收到客户端的连接，会触发IdleStateEvent事件并且</span></span><br><span class="line">                        <span class="comment">// 交给下一个handler处理，下一个handler必须</span></span><br><span class="line">                        <span class="comment">// 实现userEventTriggered方法处理对应事件</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> HeartBeatServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            System.out.println(<span class="string">"netty server start。。"</span>);</span><br><span class="line">            ChannelFuture future = bootstrap.bind(<span class="number">9000</span>).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>服务端</strong>心跳处理器。这里主要对<strong>超时事件进行处理</strong>，如果超过三次超时，则会关闭通道。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器心跳处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> readIdleTimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">" ====== &gt; [server] message received : "</span> + s);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Heartbeat Packet"</span>.equals(s)) &#123;</span><br><span class="line">            ctx.channel().writeAndFlush(<span class="string">"ok"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"其他信息处理 ... "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IdleStateEvent event = (IdleStateEvent) evt;</span><br><span class="line"></span><br><span class="line">        String eventType = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (event.state()) &#123;</span><br><span class="line">            <span class="keyword">case</span> READER_IDLE:</span><br><span class="line">                eventType = <span class="string">"读空闲"</span>;</span><br><span class="line">                <span class="comment">// 读空闲的计数加1</span></span><br><span class="line">                readIdleTimes++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WRITER_IDLE:</span><br><span class="line">                eventType = <span class="string">"写空闲"</span>;</span><br><span class="line">                <span class="comment">// 不处理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ALL_IDLE:</span><br><span class="line">                eventType = <span class="string">"读写空闲"</span>;</span><br><span class="line">                <span class="comment">// 不处理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ctx.channel().remoteAddress() + <span class="string">"超时事件："</span> + eventType);</span><br><span class="line">        <span class="keyword">if</span> (readIdleTimes &gt; <span class="number">3</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"[server]读空闲超过3次，关闭连接，释放更多资源"</span>);</span><br><span class="line">            ctx.channel().writeAndFlush(<span class="string">"IDLE close"</span>);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">"==="</span> + ctx.channel().remoteAddress() + <span class="string">" is active ==="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端及其 <strong>Handler</strong> 如下。这里一直发送消息到服务端模拟心跳机制，同时会随机休眠，这个休眠时间可能超过服务端设置的超时时间，从而实现断线模拟。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带心跳机制的Client</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> cz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        EventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            bootstrap.group(eventLoopGroup).channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                    .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder());</span><br><span class="line">                            pipeline.addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder());</span><br><span class="line">                            <span class="comment">// 只添加心跳处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> HeartBeatClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"netty client start。。"</span>);</span><br><span class="line">            Channel channel = bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">9000</span>).sync().channel();</span><br><span class="line">            String text = <span class="string">"Heartbeat Packet"</span>;</span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="comment">// 一直发送心跳消息</span></span><br><span class="line">            <span class="keyword">while</span> (channel.isActive()) &#123;</span><br><span class="line">                <span class="comment">// 这里随机休眠几秒发送一次数据</span></span><br><span class="line">                <span class="keyword">int</span> num = random.nextInt(<span class="number">10</span>);</span><br><span class="line">                Thread.sleep(num * <span class="number">1000</span>);</span><br><span class="line">                channel.writeAndFlush(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatClientHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Client received :"</span> + msg);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"IDLE Close"</span>.equals(msg)) &#123;</span><br><span class="line">                System.out.println(<span class="string">" 服务端关闭连接，客户端也关闭"</span>);</span><br><span class="line">                ctx.channel().closeFuture();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">netty server start。。</span><br><span class="line">=== /<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58505</span> is active ===</span><br><span class="line"> ====== &gt; [server] message received : Heartbeat Packet</span><br><span class="line">/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58505</span>超时事件：读空闲</span><br><span class="line"> ====== &gt; [server] message received : Heartbeat Packet</span><br><span class="line">/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58505</span>超时事件：读空闲</span><br><span class="line">/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58505</span>超时事件：读空闲</span><br><span class="line"> ====== &gt; [server] message received : Heartbeat Packet</span><br><span class="line">/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58505</span>超时事件：读空闲</span><br><span class="line">[server]读空闲超过<span class="number">3</span>次，关闭连接，释放更多资源</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">netty client start。。</span><br><span class="line">Client received :ok</span><br><span class="line">Client received :ok</span><br><span class="line">Client received :ok</span><br><span class="line">Client received :IDLE close</span><br></pre></td></tr></table></figure>



<h4 id="Netty零拷贝"><a href="#Netty零拷贝" class="headerlink" title="Netty零拷贝"></a>Netty零拷贝</h4><h5 id="1-直接内存"><a href="#1-直接内存" class="headerlink" title="1. 直接内存"></a>1. 直接内存</h5><p><strong>直接内存（Direct Memory）</strong>并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，某些情况下这部分内存也会被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。Java 里用 <strong>DirectByteBuffer</strong> 可以分配一块<strong>直接内存(堆外内存)</strong>，<strong>元空间对应的内存也叫作直接内存</strong>，它们<strong>对应的都是机器的物理内存</strong>。<strong>DirectByteBuffer 对象</strong>是在<strong>堆内</strong>的，其<strong>存放有堆外内存的地址值</strong>，指向的<strong>直接内存是在堆外</strong>，其<strong>数据</strong>是存放在堆外的直接内存中的。</p>
<img src="assets/image-20200728000505451.png" alt="image-20200728000505451" style="zoom:60%;" />

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 直接内存与堆内存的区别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 分配堆内存</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                buffer.putInt(j);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                buffer.getInt();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"堆内存访问:"</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">directAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 分配直接内存</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                buffer.putInt(j);</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">200</span>; j++) &#123;</span><br><span class="line">                buffer.getInt();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"直接内存访问:"</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAllocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"堆内存申请:"</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">directAllocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            ByteBuffer.allocateDirect(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"直接内存申请:"</span> + (endTime - startTime) + <span class="string">"ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            heapAccess();</span><br><span class="line">            directAccess();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            heapAllocate();</span><br><span class="line">            directAllocate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">堆内存访问:44ms</span><br><span class="line">直接内存访问:29ms</span><br><span class="line">堆内存访问:33ms</span><br><span class="line">直接内存访问:19ms</span><br><span class="line">堆内存访问:55ms</span><br><span class="line">直接内存访问:38ms</span><br><span class="line">堆内存访问:39ms</span><br><span class="line">直接内存访问:20ms</span><br><span class="line">堆内存访问:38ms</span><br><span class="line">直接内存访问:18ms</span><br><span class="line">堆内存访问:36ms</span><br><span class="line">直接内存访问:19ms</span><br><span class="line">堆内存访问:34ms</span><br><span class="line">直接内存访问:19ms</span><br><span class="line">堆内存访问:40ms</span><br><span class="line">直接内存访问:20ms</span><br><span class="line">堆内存访问:37ms</span><br><span class="line">直接内存访问:24ms</span><br><span class="line">堆内存访问:59ms</span><br><span class="line">直接内存访问:25ms</span><br><span class="line"></span><br><span class="line">堆内存申请:11ms</span><br><span class="line">直接内存申请:36ms</span><br><span class="line">堆内存申请:13ms</span><br><span class="line">直接内存申请:52ms</span><br><span class="line">堆内存申请:62ms</span><br><span class="line">直接内存申请:40ms</span><br><span class="line">堆内存申请:2ms</span><br><span class="line">直接内存申请:37ms</span><br><span class="line">堆内存申请:1ms</span><br><span class="line">直接内存申请:81ms</span><br><span class="line">堆内存申请:2ms</span><br><span class="line">直接内存申请:23ms</span><br><span class="line">堆内存申请:1ms</span><br><span class="line">直接内存申请:31ms</span><br><span class="line">堆内存申请:2ms</span><br><span class="line">直接内存申请:32ms</span><br><span class="line">堆内存申请:7ms</span><br><span class="line">直接内存申请:41ms</span><br><span class="line">堆内存申请:8ms</span><br><span class="line">直接内存申请:142ms</span><br></pre></td></tr></table></figure>

<p>从程序运行结果看出<strong>==直接内存申请较慢，但访问效率高==</strong>。在虚拟机实现上，<strong>本地 IO</strong> 一般会<strong>直接操作直接内存</strong>（直接内存=&gt;系统调用=&gt;硬盘/网卡），而<strong>非直接内存</strong>则需要<strong>二次拷贝</strong>（堆内存=&gt;直接内存=&gt;系统调用=&gt;硬盘/网卡）。</p>
<p><strong>直接内存分配源码分析</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectByteBuffer(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">    <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">    <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// 判断是否有足够的直接内存空间分配，可通过-XX:MaxDirectMemorySize=&lt;size&gt;参数指定直接内存最大可分配空间，如果不指定默认为最大堆内存大小，</span></span><br><span class="line">    <span class="comment">// 在分配直接内存时如果发现空间不够会显示调用System.gc()触发一次full gc回收掉一部分无用的直接内存的引用对象，同时直接内存也会被释放掉</span></span><br><span class="line">    <span class="comment">// 如果释放完分配空间还是不够会抛出异常java.lang.OutOfMemoryError</span></span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base存放的就是分配的直接内存的地址</span></span><br><span class="line">    <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用unsafe本地方法分配直接内存</span></span><br><span class="line">        base = unsafe.allocateMemory(size);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        <span class="comment">// 分配失败，释放内存</span></span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Cleaner机制注册内存回收处理函数，当直接内存引用对象被GC清理掉时，</span></span><br><span class="line">    <span class="comment">// 会提前调用这里注册的释放直接内存的Deallocator线程对象的run方法</span></span><br><span class="line">    cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));</span><br><span class="line">    att = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请一块本地内存。内存空间是未初始化的，其内容是无法预期的。</span></span><br><span class="line"><span class="comment">// 使用freeMemory释放内存，使用reallocateMemory修改内存大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">long</span> <span class="title">allocateMemory</span><span class="params">(<span class="keyword">long</span> bytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// openjdk8/hotspot/src/share/vm/prims/unsafe.cpp</span></span><br><span class="line">UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory(JNIEnv *env, jobject unsafe, jlong size))</span><br><span class="line">    UnsafeWrapper(<span class="string">"Unsafe_AllocateMemory"</span>);</span><br><span class="line">size_t sz = (size_t)size;</span><br><span class="line"><span class="keyword">if</span> (sz != (julong)size || size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_IllegalArgumentException());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sz == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">sz = round_to(sz, HeapWordSize);</span><br><span class="line"><span class="comment">// 调用os::malloc申请内存，内部使用malloc这个C标准库的函数申请内存</span></span><br><span class="line"><span class="keyword">void</span>* x = os::malloc(sz, mtInternal);</span><br><span class="line"><span class="keyword">if</span> (x == NULL) &#123;</span><br><span class="line">    THROW_0(vmSymbols::java_lang_OutOfMemoryError());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Copy::fill_to_words((HeapWord*)x, sz / HeapWordSize);</span></span><br><span class="line"><span class="keyword">return</span> addr_to_java(x);</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure>

<p><strong>使用直接内存的优缺点：</strong></p>
<p><strong>优点</strong>：不占用堆内存空间，减少了 GC 发生；虚拟机实现上，本地 IO 会直接操作直接内存（直接内存=&gt;系统调用=&gt;硬盘/网卡），而非直接内存则需要<strong>二次拷贝</strong>（堆内存=&gt;直接内存=&gt;系统调用=&gt;硬盘/网卡）。</p>
<p><strong>缺点</strong>：直接内存的初始分配较慢；没有 JVM 直接帮助管理内存，容易发生内存溢出。为了避免一直没有 FULL GC，最终导致直接内存把物理内存被耗完。可以指定<strong>直接内存的最大值</strong>，通过-XX：MaxDirectMemorySize 来指定，当达到阈值的时候，调用 system.gc 来进行一次 FULL GC，间接把那些没有被使用的直接内存回收掉。</p>
<h5 id="2-零拷贝"><a href="#2-零拷贝" class="headerlink" title="2. 零拷贝"></a>2. 零拷贝</h5><p>Netty 的接收和发送 <strong>ByteBuffer</strong> 采用 <strong>DIRECT BUFFERS</strong>，使用堆外==<strong>直接内存</strong>==进行 <strong>Socket 读写</strong>，<strong>不需要进行字节缓冲区的二次拷贝</strong>。使用直接内存使得<strong>数据可以不用拷贝到 JVM 内存</strong>中，便可以<strong>直接写入 Socket 中，这样就减少了拷贝的次数，这就是零拷贝</strong>。</p>
<p>如果使用传统的 JVM 堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将<strong>堆内存</strong>中的数据<strong>拷贝</strong>一份到直接内存中，然后才能写入 Socket 中。JVM 堆内存的数据是<strong>不能直接写入</strong> Socket 中的。<strong>相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</strong> JVM 对操作系统来说就是<strong>用户态</strong>，所以零拷贝只是不用把 IO 放在<strong>内核态</strong>的数据再拷贝到引用进程 JVM 的内存中。</p>
<p>可以看下 Netty 的读写源码，比如 AbstractNioByteChannel 类中的内部类 NioByteUnsafe 的 read() 源码即 <strong>NioByteUnsafe</strong>.read()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class="line">        clearReadPending();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 分配内存</span></span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PooledUnsafeDirectByteBuf 类的 initMemoryAddress() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMemoryAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    memoryAddress = PlatformDependent.directBufferAddress(memory) + offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Netty高并发高性能架构设计精髓"><a href="#Netty高并发高性能架构设计精髓" class="headerlink" title="Netty高并发高性能架构设计精髓"></a>Netty高并发高性能架构设计精髓</h4><p>Netty 为什么这么牛？</p>
<ul>
<li><strong>主从 Reactor 线程模型</strong>。</li>
<li>NIO <strong>多路复用</strong>非阻塞。</li>
<li><strong>无锁串行化</strong>设计思想。</li>
<li>支持<strong>高性能序列化</strong>协议。</li>
<li><strong>零拷贝</strong>(直接内存的使用)。</li>
<li>ByteBuf <strong>内存池</strong>设计。</li>
<li>灵活的 TCP <strong>参数配置</strong>能力。</li>
<li>并发优化。</li>
</ul>
<h5 id="1-无锁串行化设计"><a href="#1-无锁串行化设计" class="headerlink" title="1. 无锁串行化设计"></a>1. 无锁串行化设计</h5><p>在大多数场景下，并行多线程处理可以提升系统的并发性能。但是，如果对于共享资源的并发访问处理不当，会带来严重的<strong>锁竞争</strong>，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过<strong>串行化设计</strong>，即<strong>消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁</strong>。</p>
<p>为了尽可能提升性能，Netty 采用了<strong>串行无锁化设计</strong>，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</p>
<p>Netty 的 <strong>NioEventLoop</strong> 读取到消息之后，<strong>直接调用 ChannelPipeline 的 fireChannelRead(Object msg)</strong>，只要用户不主动切换线程，一直会由 <strong>NioEventLoop 调用到用户的 Handler，期间不进行线程切换</strong>，这种串行化处理方式避免了多线程操作导致的锁的竞争，从性能角度看是最优的。</p>
<p>一个 Pipeline 中有<strong>多个 Handler 也会在一个线程内全部串行执行，不涉及线程切换等问题</strong>。</p>
<h5 id="2-ByteBuf内存池设计"><a href="#2-ByteBuf内存池设计" class="headerlink" title="2. ByteBuf内存池设计"></a>2. ByteBuf内存池设计</h5><p>随着 JVM 虚拟机和 JIT 即时编译技术的发展，<strong>对象的分配和回收</strong>是个非常轻量级的工作。但是对于<strong>缓冲区 Buffer</strong> (相当于一个内存块)，情况却稍有不同，特别是对于<strong>堆外直接内存的分配和回收，是一件耗时的操作</strong>。为了尽量重用缓冲区， Netty 提供了<strong>基于 ByteBuf 内存池的缓冲区重用机制</strong>。需要的时候直接从<strong>池子里获取 ByteBuf 使用</strong>即可，使用完毕之后就重新放回到池子里去。下面一起看下 Netty ByteBuf 的实现：</p>
<img src="assets/image-20200727211346203.png" alt="image-20200727211346203" style="zoom:75%;" />

<p>可以看下 Netty 的读写源码里面用到的 <strong>ByteBuf 内存池</strong>，看 ByteBufAllocator 接口的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ByteBuf <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br></pre></td></tr></table></figure>

<p>抽象类 AbstractByteBufAllocator 实现了这个接口并实现了这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">directBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity == <span class="number">0</span> &amp;&amp; maxCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> emptyBuf;</span><br><span class="line">    &#125;</span><br><span class="line">    validate(initialCapacity, maxCapacity);</span><br><span class="line">    <span class="comment">// 得到一个ByteBuf</span></span><br><span class="line">    <span class="keyword">return</span> newDirectBuffer(initialCapacity, maxCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续看 <strong>newDirectBuffer</strong> 方法，发现它是一个<strong>抽象方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span></span>;</span><br></pre></td></tr></table></figure>

<p>由 AbstractByteBufAllocator 的<strong>子类</strong> <strong>PooledByteBufAllocator</strong> 负责具体实现。代码跳转到 PooledByteBufAllocator 实现的 <strong>newDirectBuffer</strong> 方法，从 Cache 中获取内存区域 PoolArena，调用它的 <strong>allocate</strong> 方法进行<strong>内存分配</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ByteBuf <span class="title">newDirectBuffer</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PoolThreadCache cache = threadCache.get();</span><br><span class="line">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ByteBuf buf;</span><br><span class="line">    <span class="keyword">if</span> (directArena != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = PlatformDependent.hasUnsafe() ?</span><br><span class="line">            UnsafeByteBufUtil.newUnsafeDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity) :</span><br><span class="line">        <span class="keyword">new</span> UnpooledDirectByteBuf(<span class="keyword">this</span>, initialCapacity, maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> toLeakAwareBuffer(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PoolArena 的 allocate</strong> 方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PooledByteBuf&lt;T&gt; <span class="title">allocate</span><span class="params">(PoolThreadCache cache, <span class="keyword">int</span> reqCapacity, <span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledByteBuf&lt;T&gt; buf = newByteBuf(maxCapacity);</span><br><span class="line">    allocate(cache, buf, reqCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点分析 <strong>newByteBuf</strong> 的实现，它同样是个<strong>抽象方法</strong>，由子类 <strong>DirectArena 和 HeapArena</strong> 来实现不同类型的<strong>缓冲区分配</strong>。</p>
<p><img src="assets/image-20200728132110796.png" alt="image-20200728132110796"></p>
<p>这里使用的是<strong>直接内存</strong>，因此重点分析 <strong>DirectArena</strong> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> PooledByteBuf&lt;ByteBuffer&gt; <span class="title">newByteBuf</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (HAS_UNSAFE) &#123;</span><br><span class="line">        <span class="keyword">return</span> PooledUnsafeDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PooledDirectByteBuf.newInstance(maxCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 最终执行了 <strong>PooledUnsafeDirectByteBuf</strong> 的 <strong>newInstance</strong> 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PooledDirectByteBuf <span class="title">newInstance</span><span class="params">(<span class="keyword">int</span> maxCapacity)</span> </span>&#123;</span><br><span class="line">    PooledDirectByteBuf buf = RECYCLER.get();</span><br><span class="line">    buf.reuse(maxCapacity);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 RECYCLER 的 get 方法<strong>循环使用 ByteBuf 对象</strong>，如果是<strong>非内存池</strong>实现，则直接创建一个<strong>新的 ByteBuf 对象</strong>。</p>
<h5 id="3-灵活的TCP参数配置能力"><a href="#3-灵活的TCP参数配置能力" class="headerlink" title="3. 灵活的TCP参数配置能力"></a>3. 灵活的TCP参数配置能力</h5><p>合理设置 <strong>TCP 参数</strong>在某些场景下对于性能的提升可以起到显著的效果，例如接收缓冲区 SO_RCVBUF 和发送缓冲区 SO_SNDBUF。如果设置不当，对性能的影响是非常大的。通常建议值为 <strong>128K 或者 256K</strong>。</p>
<p>Netty 在启动辅助类 <strong>ChannelOption</strong> 中可以灵活的<strong>配置 TCP 参数</strong>，满足不同的用户场景。</p>
<img src="assets/image-20200727211530128.png" alt="image-20200727211530128" style="zoom:75%;" />

<h5 id="4-并发优化"><a href="#4-并发优化" class="headerlink" title="4. 并发优化"></a>4. 并发优化</h5><ul>
<li><strong>volatile</strong> 的大量、正确使用。</li>
<li><strong>CAS</strong> 和原子类的广泛使用。</li>
<li>线程<strong>安全容器</strong>的使用。</li>
<li>通过<strong>读写锁</strong>提升并发性能。</li>
</ul>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><h5 id="1-看源码方法"><a href="#1-看源码方法" class="headerlink" title="1. 看源码方法"></a>1. 看源码方法</h5><ul>
<li><strong>先使用：</strong>先看官方文档快速掌握框架的<strong>基本使用</strong>。</li>
<li><strong>抓主线：</strong>找一个 demo 入手，顺藤摸瓜快速<strong>静态</strong>看一遍框架的<strong>主线</strong>源码(<strong>抓大放小</strong>)，<strong>画出源码主流程图</strong>，切勿一开始就<strong>陷入源码的细枝末节</strong>，否则会把自己绕晕。</li>
<li><strong>画图做笔记：</strong>总结框架的一些<strong>核心</strong>功能点，从这些功能点入手深入到源码的细节，<strong>边看源码边画源码走向图</strong>，并对关键<strong>源码的理解做笔记</strong>，把<strong>源码里的闪光点都记录下来</strong>，后续借鉴到工作项目中，理解能力强的可以直接看静态源码，也可以边看源码边 debug 源码执行过程，观察一些关键变量的值。</li>
<li><strong>整合总结：</strong>所有功能点的源码都分析完后，回到主流程图再梳理一遍，争取把自己画的所有图都在脑袋里做一个整合。</li>
</ul>
<h5 id="2-Netty线程模型源码剖析图"><a href="#2-Netty线程模型源码剖析图" class="headerlink" title="2. Netty线程模型源码剖析图"></a>2. Netty线程模型源码剖析图</h5><p>源自图灵诸葛，图链接：<a href="https://www.processon.com/view/link/5dee0943e4b079080a26c2ac" target="_blank" rel="noopener">https://www.processon.com/view/link/5dee0943e4b079080a26c2ac</a></p>
<p>Netty 就是对 Java NIO 代码的进一步封装。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://www.cnblogs.com/AIPAOJIAO/p/10631551.html" target="_blank" rel="noopener">Netty粘包拆包解析</a></li>
<li><a href="https://www.cnblogs.com/rickiyang/p/13100413.html" target="_blank" rel="noopener">Netty内存池</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/M%20RPC/B%20Dubbo/" rel="next" title="ShiftJava/M RPC/B Dubbo">
                <i class="fa fa-chevron-left"></i> ShiftJava/M RPC/B Dubbo
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/N%20Netty/C%20Netty%E5%BA%94%E7%94%A8/" rel="prev" title="ShiftJava/N Netty/C Netty应用">
                ShiftJava/N Netty/C Netty应用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Netty核心功能与线程模型"><span class="nav-number">1.</span> <span class="nav-text">Netty核心功能与线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty基础"><span class="nav-number">1.1.</span> <span class="nav-text">Netty基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Netty使用场景"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. Netty使用场景</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty线程模型"><span class="nav-number">1.2.</span> <span class="nav-text">Netty线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-线程模型架构图"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 线程模型架构图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-线程模型解释"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 线程模型解释</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty模块组件"><span class="nav-number">1.3.</span> <span class="nav-text">Netty模块组件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Bootstrap、ServerBootstrap"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. Bootstrap、ServerBootstrap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Future、ChannelFuture"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. Future、ChannelFuture</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Channel"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. Channel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Selector"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. Selector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-NioEventLoop"><span class="nav-number">1.3.5.</span> <span class="nav-text">5. NioEventLoop</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-NioEventLoopGroup"><span class="nav-number">1.3.6.</span> <span class="nav-text">6. NioEventLoopGroup</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-ChannelHandler"><span class="nav-number">1.3.7.</span> <span class="nav-text">7. ChannelHandler</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8-ChannelHandlerContext"><span class="nav-number">1.3.8.</span> <span class="nav-text">8. ChannelHandlerContext</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-ChannelPipline"><span class="nav-number">1.3.9.</span> <span class="nav-text">9. ChannelPipline</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于Netty的简单客户端服务器实现"><span class="nav-number">1.4.</span> <span class="nav-text">基于Netty的简单客户端服务器实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ByteBuf"><span class="nav-number">1.5.</span> <span class="nav-text">ByteBuf</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于Netty的群聊系统"><span class="nav-number">1.6.</span> <span class="nav-text">基于Netty的群聊系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty编解码"><span class="nav-number">1.7.</span> <span class="nav-text">Netty编解码</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-编解码组件"><span class="nav-number">1.7.1.</span> <span class="nav-text">1. 编解码组件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-ChannelHandler"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">(1) ChannelHandler</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-ChannelPipeline"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">(2) ChannelPipeline</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-编码解码器"><span class="nav-number">1.7.2.</span> <span class="nav-text">2. 编码解码器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-自定义编解码器"><span class="nav-number">1.7.3.</span> <span class="nav-text">3. 自定义编解码器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty粘包拆包"><span class="nav-number">1.8.</span> <span class="nav-text">Netty粘包拆包</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-1"><span class="nav-number">1.8.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-解决方案"><span class="nav-number">1.8.2.</span> <span class="nav-text">2. 解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-报文固定长度"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">(1) 报文固定长度</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-添加报文分隔符"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">(2) 添加报文分隔符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-发送长度"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">(3) 发送长度</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Netty提供的解决方案"><span class="nav-number">1.8.3.</span> <span class="nav-text">3. Netty提供的解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-FixedLengthFrameDecoder"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">(1) FixedLengthFrameDecoder</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-LineBasedFrameDecoder与DelimiterBasedFrameDecoder"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">(2) LineBasedFrameDecoder与DelimiterBasedFrameDecoder</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-LengthFieldBasedFrameDecoder与LengthFieldPrepender"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">(3) LengthFieldBasedFrameDecoder与LengthFieldPrepender</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty心跳检测机制"><span class="nav-number">1.9.</span> <span class="nav-text">Netty心跳检测机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-心跳机制概述"><span class="nav-number">1.9.1.</span> <span class="nav-text">1. 心跳机制概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-心跳机制源码分析"><span class="nav-number">1.9.2.</span> <span class="nav-text">2. 心跳机制源码分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-心跳检测代码示例"><span class="nav-number">1.9.3.</span> <span class="nav-text">3. 心跳检测代码示例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty零拷贝"><span class="nav-number">1.10.</span> <span class="nav-text">Netty零拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-直接内存"><span class="nav-number">1.10.1.</span> <span class="nav-text">1. 直接内存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-零拷贝"><span class="nav-number">1.10.2.</span> <span class="nav-text">2. 零拷贝</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Netty高并发高性能架构设计精髓"><span class="nav-number">1.11.</span> <span class="nav-text">Netty高并发高性能架构设计精髓</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-无锁串行化设计"><span class="nav-number">1.11.1.</span> <span class="nav-text">1. 无锁串行化设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-ByteBuf内存池设计"><span class="nav-number">1.11.2.</span> <span class="nav-text">2. ByteBuf内存池设计</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-灵活的TCP参数配置能力"><span class="nav-number">1.11.3.</span> <span class="nav-text">3. 灵活的TCP参数配置能力</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-并发优化"><span class="nav-number">1.11.4.</span> <span class="nav-text">4. 并发优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#源码分析"><span class="nav-number">1.12.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-看源码方法"><span class="nav-number">1.12.1.</span> <span class="nav-text">1. 看源码方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Netty线程模型源码剖析图"><span class="nav-number">1.12.2.</span> <span class="nav-text">2. Netty线程模型源码剖析图</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.13.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
