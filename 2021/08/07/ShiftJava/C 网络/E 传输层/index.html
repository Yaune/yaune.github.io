<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] 传输层传输层概述1. 进程间通信运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。  网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;C 网络&#x2F;E 传输层">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] 传输层传输层概述1. 进程间通信运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。  网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574661864808.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574665342861.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574665371608.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574665407328.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574663001027.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574665460877.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574663612676.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574663572580.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574663165656.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574665638737.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574678682438.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574678876656.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574665843167.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574666056852.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574673678140.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574673859032.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574674131614.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574674533053.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574684338841.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574684449907.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574684750771.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574684976697.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574685045005.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574685228063.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574685240297.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574685707138.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574686102397.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574686367422.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574686661544.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574686970680.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574688589340.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574687284733.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574687548934.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574687664404.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574687681447.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574687709192.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574687785705.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574687834142.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574687854685.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574687870869.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574688178264.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574688469456.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574741516560.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;image-20200522173211093.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574741905218.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;image-20200804233105341.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574742398806.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;C%20%E7%BD%91%E7%BB%9C&#x2F;E%20%E4%BC%A0%E8%BE%93%E5%B1%82&#x2F;assets&#x2F;1574661864808.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/C 网络/E 传输层/"/>





  <title>ShiftJava/C 网络/E 传输层 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/C%20%E7%BD%91%E7%BB%9C/E%20%E4%BC%A0%E8%BE%93%E5%B1%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/C 网络/E 传输层</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><h4 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h4><h5 id="1-进程间通信"><a href="#1-进程间通信" class="headerlink" title="1. 进程间通信"></a>1. 进程间通信</h5><p><strong>运输层</strong>向它上面的<strong>应用层</strong>提供<strong>通信服务</strong>，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的<strong>边缘部分</strong>中的两个主机使用<strong>网络的核心部分</strong>的功能进行<strong>端到端的通信</strong>时，只有位于<strong>网络边缘部分</strong>的主机的协议栈才有运输层，而<strong>网络核心部分中的路由器</strong>在<strong>转发分组</strong>时都只用到<strong>下三层</strong>的功能。 </p>
<p><strong>网络层</strong>只把<strong>分组</strong>发送到<strong>目的主机</strong>，但是真正通信的并不是主机而是主机中的<strong>进程</strong>。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。所以传输层<strong>为==进程==提供通用数据传输服务</strong>。</p>
<img src="assets/1574661864808.png" alt="1574661864808" style="zoom: 56%;" />

<p><strong>网络层和运输层的区别</strong>：<strong>网络层</strong>是为<strong>主机之间</strong>提供逻辑通信，而<strong>运输层</strong>为<strong>应用进程</strong>之间提供端到端的逻辑通信。</p>
<p>传输层还需要对收到的报文进行<strong>差错检测</strong>。</p>
<h5 id="2-传输层的两个协议"><a href="#2-传输层的两个协议" class="headerlink" title="2. 传输层的两个协议"></a>2. 传输层的两个协议</h5><p>根据应用程序的不同需求，传输层需要有两种不同的运输协议，即<strong>面向连接的 TCP</strong> 和<strong>无连接的 UDP</strong> 。</p>
<ul>
<li>用户数据报协议 <strong>UDP</strong>（User Datagram Protocol）是<strong>无连接</strong>的，使用的是不可靠信道。尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、<strong>一对多</strong>、多对一和多对多的交互通信。<strong>UDP用户数据报</strong>。</li>
<li>传输控制协议 <strong>TCP</strong>（Transmission Control Protocol）是<strong>面向连接</strong>的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是<strong>点对点</strong>的（一对一）。<strong>TCP 报文段</strong>。</li>
</ul>
<img src="assets/1574665342861.png" alt="1574665342861" style="zoom:50%;" />

<p><strong>使用 UDP 或 TCP 协议的应用层协议</strong>：</p>
<table>
<thead>
<tr>
<th align="center">应用</th>
<th align="center">应用层协议</th>
<th align="center">传输层协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">域名系统</td>
<td align="center"><strong>DNS</strong>（域名系统）</td>
<td align="center"><strong>UDP/TCP</strong></td>
</tr>
<tr>
<td align="center">文件传输</td>
<td align="center">TFTP（简单文件传送协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">路由选择协议</td>
<td align="center"><strong>RIP</strong>（路由信息协议）</td>
<td align="center"><strong>UDP</strong></td>
</tr>
<tr>
<td align="center">IP 地址配置</td>
<td align="center"><strong>DHCP</strong>（动态主机配置协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">网络管理</td>
<td align="center">SNMP（简单网络管理协议）</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">远程文件服务器</td>
<td align="center"><strong>NFS</strong>（网络文件系统）</td>
<td align="center"><strong>UDP</strong></td>
</tr>
<tr>
<td align="center">IP 电话</td>
<td align="center">专用协议</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">流式多媒体通信</td>
<td align="center">专用协议</td>
<td align="center">UDP</td>
</tr>
<tr>
<td align="center">多播</td>
<td align="center"><strong>IGMP</strong>（网际组管理协议）</td>
<td align="center"><strong>UDP</strong></td>
</tr>
<tr>
<td align="center">电子邮件</td>
<td align="center">SMTP（简单邮件传送协议）</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">远程终端接入</td>
<td align="center"><strong>TELENT</strong>（远程终端协议）</td>
<td align="center">TCP</td>
</tr>
<tr>
<td align="center">万维网</td>
<td align="center"><strong>HTTP</strong>（超文本传输协议）</td>
<td align="center"><strong>TCP</strong></td>
</tr>
<tr>
<td align="center">文件传输</td>
<td align="center"><strong>FTP</strong>（文件传送协议）</td>
<td align="center"><strong>TCP</strong></td>
</tr>
</tbody></table>
<img src="assets/1574665371608.png" alt="1574665371608" style="zoom:45%;" />

<h5 id="3-传输层的端口"><a href="#3-传输层的端口" class="headerlink" title="3. 传输层的端口"></a>3. 传输层的端口</h5><p>端口用一个 16 位<strong>端口号</strong>进行标志，允许 <strong>65535</strong> 个不同端口。 端口号只具有本地意义，即<strong>端口号只是为了标识本计算机应用层中的各进程</strong>。 在互联网中不同计算机的相同端口号是<strong>没有联系</strong>的。两个计算机中的<strong>进程</strong>要互相通信，<strong>不仅必须知道对方的 IP 地址</strong>（为了找到对方的计算机），<strong>而且还要知道对方的端口号</strong>（为 了找到对方计算机中的<strong>应用进程</strong>）。</p>
<img src="assets/1574665407328.png" alt="1574665407328" style="zoom:45%;" />

<p><strong>端口分为服务器端使用的和客户端使用</strong>的，常用的熟知端口（服务器端）：</p>
<img src="assets/1574663001027.png" alt="1574663001027" style="zoom:50%;" />

<img src="assets/1574665460877.png" alt="1574665460877" style="zoom: 40%;" />



<h4 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p><strong>用户数据协议 UDP **是</strong>无连接**的，它在 IP 层的数据报服务上只增加了：复用和分用的功能、差错检测的功能。 </p>
<p>当运输层从 IP 层收到 UDP 数据报时，就根据<strong>首部</strong>中的<strong>目的端口</strong>，把 UDP 数据报通过相应的端口，上交最后的终点：应用进程。 </p>
<img src="assets/1574663612676.png" alt="1574663612676" style="zoom:47%;" />

<p>如果接收方 UDP 发现收到的报文中的目的端口<strong>不正确</strong>（即不存在对应端口的进程），就丢弃该报文，并由<strong>==网际控制报文协议 ICMP==</strong>发送“<strong>端口不可达</strong>”差错报文给发送方！！</p>
<p><strong>请注意</strong>，虽然在 UDP 之间的通信要用到其端口号，但<strong>由于 UDP 的通信是无连接的，因此==不需要使用套接字==</strong>。 </p>
<h5 id="2-UDP协议的首部格式"><a href="#2-UDP协议的首部格式" class="headerlink" title="2. UDP协议的首部格式"></a>2. UDP协议的首部格式</h5><p>用户数据报 UDP 有两个字段：<strong>数据字段和首部字段</strong>。首部字段很简单，只有 <strong>8 个字节</strong>。四个字段的长度都是 2 字节。</p>
<ul>
<li><strong>源端口</strong>：需要对方回信时使用，不需要时可用全 0。</li>
<li><strong>目的端口</strong></li>
<li><strong>长度</strong>：UDP 数据报的长度，最小值是仅有首部时的 8。</li>
<li><strong>校验和</strong>：检验传输是否出错，出错丢弃。UDP 的校验和是把<strong>首部和数据部分一起校验</strong>。12 字节的伪首部是为了计算检验和临时添加的。</li>
</ul>
<img src="assets/1574663572580.png" alt="1574663572580" style="zoom:60%;" />

<p>注意是<strong>不含 IP 地址</strong>的。</p>
<h5 id="3-UDP协议特点"><a href="#3-UDP协议特点" class="headerlink" title="3. UDP协议特点"></a>3. UDP协议特点</h5><p>(1) <strong>UDP 是无连接的</strong>，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</p>
<p>(2) <strong>UDP 使用尽最大努力交付，即不保证可靠交付</strong>，因此主机不需要维持复杂的连接状态表。 </p>
<p>(3) <strong>UDP 是面向报文的</strong>。UDP 对应用层交下来的报文，既不合并也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。 如下图。</p>
<img src="assets/1574663165656.png" alt="1574663165656" style="zoom:52%;" />

<p>(4) <strong>UDP ==没有拥塞控制==</strong>，因此网络出现的拥塞<strong>不会</strong>使源主机的发送速率降低。<strong>这对某些实时应用是很重要的。很适合多媒体通信的要求</strong>。</p>
<p>(5) <strong>UDP 支持一对一、一对多、多对一和多对多的交互通信</strong>。 </p>
<p>(6) <strong>UDP 的首部开销小</strong>，只有 8 个字节，比 TCP 的 20 个字节的首部要短。 </p>
<h5 id="4-UDP可靠传输"><a href="#4-UDP可靠传输" class="headerlink" title="4. UDP可靠传输"></a>4. UDP可靠传输</h5><p>这是一个常考的面试题。传输层无法保证数据的可靠传输，只能<strong>通过应用层</strong>来实现了。实现的方式可以参照 TCP 可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。主要方式：</p>
<ul>
<li>添加 <strong>seq/ack 机制</strong>，确保数据发送到对端。</li>
<li>添加发送和<strong>接收缓冲区</strong>，配合<strong>超时重传机制</strong>进行丢失数据的重传。</li>
</ul>
<p>相关的协议：</p>
<ul>
<li><strong>RUDP</strong>：提供一组数据服务质量增强机制，如拥塞控制的改进、重发机制及淡化服务器算法等，从而在包丢失和网络拥塞的情况下， RTP 客户机（实时位置）面前呈现的就是一个高质量的 RTP 流。</li>
<li><strong>RTP</strong>：为数据提供了具有实时特征的端对端传送服务，如在组播或单播网络服务下的交互式视频音频或模拟数据。</li>
<li><strong>UDT</strong>：UDT 建于 UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT 是<strong>面向连接的双向的应用层协议</strong>。它同时支持可靠的数据流传输和部分可靠的数据报传输。由于 UDT 完全在 UDP 上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。</li>
</ul>
<h4 id="传输控制协议TCP"><a href="#传输控制协议TCP" class="headerlink" title="传输控制协议TCP"></a>传输控制协议TCP</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><p><strong>传输控制协议TCP</strong>是<strong>面向连接的运输层协议</strong>，<strong>每一条 TCP 连接只能有两个端点</strong> (endpoint)，<strong>每一条 TCP 连接只能是点对点</strong>的（<strong>一对一</strong>）。 TCP 提供<strong>全双工通信</strong>、<strong>面向字节流的可靠交付的服务</strong>（TCP 中的“流”(stream)指的是流入或流出进程的字节序列。 “面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个<strong>数据块</strong>，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的<strong>字节流</strong>） 如下图。</p>
<img src="assets/1574665638737.png" alt="1574665638737" style="zoom: 45%;" />

<p><strong>TCP 连接是一条==虚连接==而不是一条真正的物理连接</strong>。</p>
<p><strong>TCP的连接</strong>：每一条 TCP 连接有 2 个端点，TCP 连接的<strong>端点</strong>叫做<strong>套接字 (socket)</strong> 或插口。 <strong>端口号拼接到 (contatenated with) IP 地</strong>址即构成了<strong>套接字</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">套接字 socket = (IP地址 : 端口号)</span><br></pre></td></tr></table></figure>

<p><strong>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定</strong>。即：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP连接 ::= &#123;socket1, socket2&#125; = &#123;(IP1:port1), (IP2:port2)&#125;</span><br></pre></td></tr></table></figure>

<p>同一个 <strong>IP 地址</strong>可以有多个<strong>不同的 TCP 连接</strong>，而<strong>同一个端口号</strong>也可以出现在<strong>多个不同的 TCP 连接</strong>中。</p>
<p>TCP 为了实现与 UDP 不同的<strong>可靠传输</strong>。需要一些特定的功能：<strong>停止等待协议</strong>、<strong>连续 ARQ 协议 、滑动窗口协议</strong>（<strong>TCP协议的精髓</strong>）。</p>
<h5 id="2-TCP报文格式"><a href="#2-TCP报文格式" class="headerlink" title="2. TCP报文格式"></a>2. TCP报文格式</h5><p>TCP 虽然是面向<strong>字节流</strong>的，但 TCP 传送的数据单元却是<strong>报文段</strong>。一个 TCP 报文段分为<strong>首部和数据</strong>两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。TCP 报文作为 <strong>IP 数据报</strong>的数据部分。</p>
<p>TCP 报文段首部的<strong>前 20</strong> 个字节是<strong>固定</strong>的，后面有 4N 字节是根据需要而增加的选项 (N 是整数)。因此 TCP 首部的最小长度是 <strong>20 字节</strong>。</p>
<p><img src="assets/1574678682438.png" alt="1574678682438"></p>
<ul>
<li><strong>==源端口和目的端口==</strong>：各占 <strong>2 字节</strong>。端口是运输层与应用层的服务接口，运输层的<strong>复用和分用</strong>功能都要通过端口才能实现。 </li>
<li><strong>==序号 seq==</strong> ：占 <strong>4 字节</strong>。TCP 连接中传送的数据流中的<strong>每一个字节</strong>都有一个<strong>序号</strong>。序号字段的值则指的是<strong>本报文段</strong>所<strong>发送的</strong>数据的<strong>第一个字节</strong>的序号。 </li>
</ul>
<img src="assets/1574678876656.png" alt="1574678876656" style="zoom: 40%;" />

<ul>
<li><p><strong>==确认号 ack==</strong>：占 4 字节，是<strong>==期望==</strong>收到<strong>对方</strong>的<strong>下一个报文段</strong>的数据的<strong>第一个字节</strong>序号。 若确认号 <strong>ack = N</strong>，则表明到序号 <strong>N - 1</strong> 为止的所有数据都<strong>已正确收到</strong>。</p>
</li>
<li><p><strong>数据偏移</strong>：即<strong>首部长度</strong>。占 4 位，它指出当前 TCP 报文段的<strong>数据起始处</strong>距离 TCP 报文段的起始处有多远。”数据偏移”的单位是 32 位字（以 4 字节为计算单位）。 </p>
</li>
<li><p><strong>保留</strong>：占 6 位，保留为今后使用，但目前应置为 0。</p>
</li>
<li><p><strong>紧急 URG</strong>：当 URG = 1 时，表明紧急指针字段<strong>有效</strong>。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 </p>
</li>
<li><p><strong>==确认 ACK 标志位==</strong>：只有当 <strong>ACK = 1</strong> 时<strong>确认号字段才有效</strong>。当 ACK = 0 时，确认号无效。 </p>
</li>
<li><p><strong>推送 PSH</strong>：接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 </p>
</li>
<li><p><strong>复位 RST</strong>：当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 </p>
</li>
<li><p>==<strong>同步 SYN 标志位</strong>==：（<strong>Syn</strong>chronize Sequence Numbers）同步 <strong>SYN = 1</strong> 表示这是一个==<strong>连接请求或连接接受</strong>==报文，在<strong>连接时</strong>用来<strong>同步序号</strong>。   </p>
</li>
<li><p><strong>==终止 FIN 标志位==</strong>：用来<strong>释放</strong>一个连接。<strong>FIN = 1</strong> 表明此报文段的<strong>发送端</strong>的数据已<strong>发送完毕</strong>，并<strong>要求释放连接</strong>。 </p>
</li>
<li><p><strong>==窗口==</strong>：占 2 字节，是用来<strong>对方设置</strong>发送窗口大小的依据，单位为字节。窗口字段明确指出了现在<strong>允许对方发送</strong>的数据量，窗口值常在<strong>动态</strong>变化着。TCP 根据对方给出<strong>的窗口值</strong>和当前<strong>网络拥塞的程度</strong>来决定一个报文段应<strong>包含多少个字节</strong>（UDP 发送的报文<strong>长度是应用进程给出</strong>的）。TCP 并不关心应用进程一次把多长的报文发送到 TCP 的缓存中，而是根据<strong>对方给出的窗口值</strong>和当前网络拥塞的程序来决定一个报文段应该包含多少个字节。如果缓存的数据块太长可以划分短一些再传送。</p>
</li>
<li><p><strong>校验和</strong>：占 2 字节。检验和字段检验的范围包括<strong>首部和数据</strong>这两部分。在计算检验和时，临时在 TCP 报文段的前面加上 12 字节的伪首部。</p>
</li>
<li><p><strong>紧急指针字段</strong>：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 </p>
</li>
<li><p><strong>选项</strong>：长度可变。TCP 最初只规定了一种选项，即<strong>最大报文段长度 MSS</strong>。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节” 。其他选项：窗口扩大选项、时间戳选项、选择确认选项。MSS (Maximum Segment Size) 是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以，MSS 是“TCP 报文段长度减去 TCP 首部长度”。</p>
</li>
<li><p><strong>填充</strong>：这是为了使整个首部长度是 <strong>4 字节</strong>的<strong>整数倍</strong>。 </p>
</li>
</ul>
<h4 id="TCP可靠传输的工作原理"><a href="#TCP可靠传输的工作原理" class="headerlink" title="TCP可靠传输的工作原理"></a>TCP可靠传输的工作原理</h4><p><strong>IP</strong> <strong>网络</strong>所提供的是<strong>不可靠</strong>的传输，那如何实现可靠传输？主要有 <strong>ARQ协议（停止等待 ARQ  协议、连续 ARQ 协议）、滑动窗口协议</strong>。</p>
<p>==<strong>注意关系</strong>==：ARQ 协议是<strong>自动重传请求</strong>（Automatic Repeat-reQuest）。包含<strong>停止等待 ARQ</strong> （信道利用率低） 和<strong>连续 ARQ</strong>（信道利用率高），<strong>ARQ</strong> 协议实现<strong>连续发送</strong>是<strong>基于滑动窗口协议</strong>的。除此之外滑动窗口还可以用于<strong>流量控制</strong>。</p>
<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用<strong>确认和超时</strong>这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。<strong>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议</strong>。</p>
<h4 id="ARQ协议"><a href="#ARQ协议" class="headerlink" title="ARQ协议"></a>ARQ协议</h4><p>ARQ 协议的核心就是<strong>自动重传</strong>。</p>
<h5 id="1-停止等待ARQ协议"><a href="#1-停止等待ARQ协议" class="headerlink" title="1. 停止等待ARQ协议"></a>1. 停止等待ARQ协议</h5><p>停止等待 ARQ 协议要点：</p>
<ul>
<li><strong>停止等待</strong>。发送方每次只发送<strong>一个</strong>分组，在<strong>收到确认</strong>后再发送下一个分组。</li>
<li><strong>编号</strong>。对发送的每个分组和确认都进行<strong>编号</strong>。</li>
<li><strong>自动重传请求</strong>。发送方为<strong>每个发送的分组</strong>设置一个<strong>超时计时器</strong>。若超时计时器超时，发送方会<strong>自动重传</strong>分组。</li>
<li><strong>简单</strong>。但信道利用率太低。</li>
</ul>
<p><strong>停止等待协议的要点就是对每个分组都进行编号，且每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组</strong>。</p>
<h6 id="1-无差错情况"><a href="#1-无差错情况" class="headerlink" title="(1) 无差错情况"></a>(1) 无差错情况</h6><p>发送方发送分组，接收方在规定时间内收到，并且回复确认。发送方可再次发送分组，这就是无差错的<strong>正常情况</strong>。</p>
<img src="assets/1574665843167.png" alt="1574665843167" style="zoom:45%;" />

<h6 id="2-出现差错"><a href="#2-出现差错" class="headerlink" title="(2) 出现差错"></a>(2) 出现差错</h6><p>如果 B 接收 M1 分组后进行<strong>校验</strong>出了差错，就会直接<strong>丢弃 M1</strong>，其他什么也不做，<strong>不通知</strong> A 收到有差错的分组。且如果分组 M1 在<strong>传输过程中丢失</strong>了，接收方 B 也什么都不能做。在这两种情况下，B 都<strong>不会回复</strong>任何信息。但 A 都必须<strong>重发分组</strong>，直到 <strong>B 正确接收</strong>为止，这样才能实现可靠通信。</p>
<img src="assets/1574666056852.png" alt="1574666056852" style="zoom:45%;" />

<blockquote>
<p><strong>A 如何知道 B 是否正确收到了 M1 分组？</strong></p>
</blockquote>
<p><strong>解决方法：==超时重传==</strong></p>
<ul>
<li>A 为<strong>每一个已发送的分组</strong>都设置了一个<strong>超时计时器</strong>。</li>
<li>A 只要在超时计时器<strong>到期</strong>之前收到了相应的<strong>确认</strong>，就<strong>撤销</strong>该超时计时器，继续发送下一个分组 M2 。</li>
<li>若 A 在超时计时器规定时间内没有收到 B 的确认，就认为分组错误或丢失，就<strong>重发该分组</strong>。</li>
</ul>
<blockquote>
<p>若分组正确到达 B，但 B 回送的确认丢失或延迟了，A 未收到 B 的确认，会<strong>超时重发</strong>。B 可能会收到<strong>重复的 M1</strong> 。B 如何知道收到了重复的分组，需要<strong>丢弃</strong>呢？</p>
</blockquote>
<p><strong>解决方法：==编号==</strong></p>
<ul>
<li>A 为<strong>每一个发送的分组</strong>都进行<strong>编号</strong>。若 B 收到了编号<strong>相同的分组</strong>，则认为收到了重复分组，<strong>丢弃重复的分组</strong>，并<strong>回送确认</strong>。</li>
<li>B 为发送的确认也进行<strong>编号</strong>，指示该确认是对<strong>哪一个分组的确认</strong>。</li>
<li>A 根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其<strong>丢弃</strong>。</li>
</ul>
<h6 id="3-确认丢失"><a href="#3-确认丢失" class="headerlink" title="(3) 确认丢失"></a>(3) 确认丢失</h6><p>若 B 所发送的对 M1 的<strong>确认信息丢失</strong>了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并<strong>无法知道</strong>：是自己发送的分组出错、丢失了，还是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要<strong>重传</strong> M1。</p>
<p>假定此时 B 又收到了重传的分组 M1。这时 B 应采取<strong>两个行动</strong>：</p>
<ul>
<li>第一，<strong>丢弃这个重复</strong>的分组 M1，不向上层交付。</li>
<li>第二，向 A <strong>发送确认</strong>。<strong>不能认为已经发送过确认就不再发送</strong>，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。</li>
</ul>
<h6 id="4-确认迟到"><a href="#4-确认迟到" class="headerlink" title="(4) 确认迟到"></a>(4) 确认迟到</h6><p>如果传输过程中没有出现差错，但 B 对分组 M1 的<strong>确认迟到</strong>了（如<strong>网络阻塞</strong>等原因）。B 仍然会收到<strong>重复的 M1</strong>，并且同样要<strong>丢弃</strong>重复的 M1，并<strong>重传确认分组</strong>。此时 A 会收到<strong>重复的确认</strong>。对重复的确认的处理很简单：<strong>收下后就丢弃</strong>。</p>
<img src="assets/1574673678140.png" alt="1574673678140" style="zoom:45%;" />

<p>注意：</p>
<ul>
<li>在发送完一个分组后，必须<strong>暂时保留</strong>已发送的分组的<strong>副本</strong>，以备<strong>重发</strong>。</li>
<li><strong>分组和确认分组都必须进行编号</strong>。超时计时器的重传时间应当比数据在分组传输的<strong>平均往返</strong>时间<strong>更长一些</strong>。 </li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 </li>
</ul>
<h6 id="5-信道利用率"><a href="#5-信道利用率" class="headerlink" title="(5) 信道利用率"></a>(5) 信道利用率</h6><p>当往返时间 RTT 远大于分组发送时间 TD 时，信道的利用率就会<strong>非常低</strong>。若出现重传，则对传送有用的数据信息来说，信道的利用率就还要降低。</p>
<img src="assets/1574673859032.png" alt="1574673859032" style="zoom:45%;" />

<h5 id="2-自动请求重传协议"><a href="#2-自动请求重传协议" class="headerlink" title="2. 自动请求重传协议"></a>2. 自动请求重传协议</h5><p>通常发送方最终总是可以收到对所有发出分组的<strong>确认</strong>。如果发送方<strong>不断重传</strong>分组但总是收不到确认，就说明通信<strong>线路太差</strong>，不能进行通信。使用<strong>上述的确认和重传机制，就可以在==不可靠的传输网络上实现可靠的通信==。</strong>像上述的<strong>这种可靠传输协议</strong>常称为==<strong>自动重传请求 ARQ</strong>==  (Automatic Repeat reQuest)。<strong>意思是重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组。</strong></p>
<p>上面的停止等待 ARQ 协议就是自动请求重传协议的一种。</p>
<h5 id="3-流水线传输"><a href="#3-流水线传输" class="headerlink" title="3. 流水线传输"></a>3. <strong>流水线传输</strong></h5><p>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用<strong>流水线传输</strong>。流水线传输就是<strong>发送方可连续发送多个分组</strong>，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 </p>
<img src="assets/1574674131614.png" alt="1574674131614" style="zoom:45%;" />

<p>这就<strong>演变</strong>出来<strong>连续 ARQ 协议</strong>。</p>
<h5 id="4-连续ARQ协议"><a href="#4-连续ARQ协议" class="headerlink" title="4. 连续ARQ协议"></a>4. 连续ARQ协议</h5><p>要点：==<strong>自动请求重传(ARQ) + 流水线</strong>==。</p>
<p>连续 ARQ 协议就是在停止等待 ARQ 协议的基础上，发送方一次可以发出<strong>多个分组</strong>。同时使用<strong>滑动窗口协议</strong>控制发送方和接收方所能发送和接收的分组的<strong>数量和编号</strong>。发送方每收到一个确认，就把发送窗口向前滑动。<strong>接收方</strong>一般采用<strong>累积确认</strong>的方式。不必对分组逐个确认，而可以对按序到达的最后一个分组进行确认表示到这个分组为止的所有分组<strong>都已正确</strong>收到了。<strong>超时重传</strong>则采用<strong>回退 N</strong>（Go-Back-N）方法进行。如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对<strong>前两个</strong>分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组<strong>都再重传</strong>一次。这就叫做 Go-back-N（回退 N），表示需要<strong>再退回来重传已发送过的 N 个分组</strong>。</p>
<img src="assets/1574674533053.png" alt="1574674533053" style="zoom:41%;" />

<p>连续 ARQ 协议是<strong>基于滑动窗口协议</strong>的。下面看看滑动窗口协议怎么搞。</p>
<h4 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h4><p>上一节讲的是实现可靠传输的<strong>基本原理</strong>，这一节具体讲 TCP 是如何实现可靠传输的。分为三个部分。</p>
<h5 id="1-滑动窗口协议"><a href="#1-滑动窗口协议" class="headerlink" title="1. 滑动窗口协议"></a>1. 滑动窗口协议</h5><p><strong>滑动窗口协议</strong>在在发送方和接收方之间各自维持一个<strong>滑动窗口</strong>，发送发是<strong>发送窗口</strong>，接收方是<strong>接收窗口</strong>，而且这个窗口是随着时间变化可以向前<strong>滑动</strong>的。它允许发送方<strong>发送多个分组</strong>而不需等待确认，提高了信道的利用率。</p>
<h6 id="1-基本流程"><a href="#1-基本流程" class="headerlink" title="(1) 基本流程"></a>(1) 基本流程</h6><p>窗口是<strong>缓存</strong>的一部分，用来暂时存放<strong>字节流</strong>。发送方和接收方各有一个窗口，<strong>接收方</strong>通过 TCP 报文段中的<strong>窗口字段</strong>告诉发送方自己的窗口大小，发送方根据这个值和其它信息<strong>设置自己的窗口大小</strong>。TCP 的滑动窗口是以<strong>字节</strong>为单位的。</p>
<p><strong>发送窗口</strong>内的字节都<strong>允许被发送</strong>，<strong>接收窗口</strong>内的字节都<strong>允许被接收</strong>。如果发送窗口左部的字节已经发送并且<strong>收到了确认</strong>，那么就将发送窗口向<strong>右滑动</strong>一定距离，直到左部第一个字节不是已发送<strong>并且已确认</strong>的状态；接收窗口的滑动类似，接收窗口左部字节已经发送<strong>确认</strong>并交付主机，就向<strong>右滑动</strong>接收窗口。</p>
<ul>
<li><strong>发送窗口</strong>表示：即使在<strong>没有收到确认</strong>的情况下，也可以<strong>连续把窗口内的数据</strong>全部发送出去。</li>
<li><strong>接收窗口</strong>表示：<strong>只允许</strong>接收<strong>落入窗口内</strong>的数据。</li>
</ul>
<img src="assets/1574684338841.png" alt="1574684338841" style="zoom:53%;" />

<p>发送窗口里面的序号 <strong>31 - 50</strong> 表示是<strong>允许发送</strong>的序号。发送窗口后沿的后面部分表示已经收到<strong>并且确认</strong>，这部分数据不需要继续保存。描述一个发送窗口需要维护==<strong>三个指针</strong>==，如下图所示。下图中如果 <strong>B 收到了 32、33</strong> 序号的数据，但是并<strong>没有收到 31</strong> 的数据，说明数据<strong>没有按序到达</strong>，所以 B 发送的确认报文段中的<strong>确认号</strong>仍然是 <strong>31</strong>（<strong>期望收到</strong>的序号）。</p>
<p><img src="assets/1574684449907.png" alt="1574684449907"></p>
<p>下图所示为 B <strong>收到</strong> 31-33 的数据并交付主机，同时给 A 确认，其中<strong>窗口值为 20</strong> ，<strong>确认值</strong>变为 <strong>34</strong>（即<strong>下一个期望</strong>收到序号为 34 的数据）。同时下图还收到了 37、38、40 序号的数据，但是<strong>未按序到达</strong>，所以只是<strong>暂存</strong>到接收窗口。此时 B 的<strong>接收窗口向前滑动</strong>到下一个期待接收的位置依然是 34。</p>
<img src="assets/1574684750771.png" alt="1574684750771" style="zoom:55%;" />

<p>此时 A 收到确认号，<strong>发送窗口向前滑动</strong>。</p>
<img src="assets/1574684976697.png" alt="1574684976697" style="zoom:55%;" />

<p>如果 A 的发送窗口内的<strong>序号都已用完</strong>，但还<strong>没有</strong>再收到确认，必须<strong>停止发送</strong>。 如下图。</p>
<p><img src="assets/1574685045005.png" alt="1574685045005"></p>
<p>而如果 A 收到确认落在发送窗口内，那就可以使发送窗口继续<strong>向前滑动</strong>。</p>
<p>注意：</p>
<ul>
<li>发送端的发送窗口<strong>并不总是</strong>和 B 的接收窗口一样大（因为有一定的<strong>时间滞后</strong>）。</li>
<li>TCP 标准没有规定对不按序到达的数据应如何处理。通常是先<strong>临时存放在接收窗口</strong>中，等到字节流中所<strong>缺少的字节收到</strong>后，再按序交付上层的应用进程。</li>
<li>TCP 要求接收方必须有<strong>累积确认</strong>的功能，这样可以减小传输<strong>开销</strong>。 </li>
<li>其实真正的发送窗口值的大小还取决于网络的<strong>拥塞情况</strong>，<strong>发送窗口的上限值 = Min (接收方窗口值，拥塞窗口值)</strong>。</li>
</ul>
<h6 id="2-滑动窗口与缓存"><a href="#2-滑动窗口与缓存" class="headerlink" title="(2) 滑动窗口与缓存"></a>(2) <strong>滑动窗口与缓存</strong></h6><p><strong>发送缓存</strong>用来暂时存放：发送应用程序传送给发送方 TCP <strong>准备发送</strong>的数据，以及 TCP 已发送出但<strong>尚未收到</strong>确认的数据。</p>
<img src="assets/1574685228063.png" alt="1574685228063" style="zoom:45%;" />

<p><strong>接收缓存</strong>用来暂时存放：<strong>按序到达</strong>的、但尚未被接收应用程序读取的数据，以及<strong>未按序</strong>到达的数据。 </p>
<img src="assets/1574685240297.png" alt="1574685240297" style="zoom:45%;" />

<h5 id="2-超时重传时间"><a href="#2-超时重传时间" class="headerlink" title="2. 超时重传时间"></a>2. 超时重传时间</h5><p><strong>重传机制</strong>是 TCP 中最重要和最复杂的问题之一。TCP 每发送一个报文段，就对这个报文段设置一次<strong>计时器</strong>。只要<strong>计时器</strong>设置的重传时间到但还没有收到确认，就要重传这一报文段。这里重传<strong>时间的选择</strong>就是一个麻烦的问题。如果把超时重传时间设置得<strong>太短</strong>，就会引起很多报文段的不必要的重传，使网络负荷增大。但若把超时重传时间设置得<strong>过长</strong>，则又使网络的空闲时间增大，降低了传输效率。</p>
<blockquote>
<p><strong>如何设置超时重传时间？</strong></p>
</blockquote>
<p>TCP 采用了一种<strong>自适应算法</strong>，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 <strong>RTT</strong>。计算<strong>加权平均往返时间 RTTs</strong>。超时重传时间 <strong>RTO</strong> (Retransmission Time-Out) 应<strong>略大于</strong>上面得出的加权平均往返时间 RTTs。</p>
<blockquote>
<p><strong>如何准确计算 RTTs?</strong></p>
</blockquote>
<p>在计算平均往返时间 RTT 时，只要发生了报文段<strong>重传</strong>事件，就<strong>不采用</strong>其往返时间样本。这样得出的加权平均 RTTs 和 RTO 就比较准确。</p>
<h5 id="3-选择确认SACK"><a href="#3-选择确认SACK" class="headerlink" title="3. 选择确认SACK"></a>3. 选择确认SACK</h5><p>若收到的报文段无差错，只是<strong>未按序号</strong>，中间还<strong>缺少</strong>一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？</p>
<img src="assets/1574685707138.png" alt="1574685707138" style="zoom:45%;" />

<p>答案是<strong>可以</strong>的。<strong>选择确认 SACK  (Selective ACK)</strong> 就是一种可行的处理方法。其实<strong>大多数的实现</strong>还是<strong>重传所有</strong>未被确认的数据块。</p>
<h4 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h4><h5 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h5><p><strong>流量控制</strong>就是<strong>控制发送方发送速率</strong>，保证<strong>接收方</strong>来得及接收。<strong>接收方</strong>发送的<strong>确认</strong>报文中的<strong>窗口字段</strong>可以用来<strong>控制发送方窗口值</strong>大小（<strong>利用==滑动窗口==实现流量控制</strong>），从而影响发送方的发送速率。将窗口字段设置为 <strong>0</strong>，则发送方<strong>不能</strong>发送数据。</p>
<img src="assets/1574686102397.png" alt="1574686102397" style="zoom:45%;" />

<h5 id="2-可能发生死锁"><a href="#2-可能发生死锁" class="headerlink" title="2. 可能发生死锁"></a>2. <strong>可能发生死锁</strong></h5><p>B 向 A 发送了零窗口的报文段后不久，B 的接收<strong>缓存</strong>又有了一些<strong>存储空间</strong>。于是 B 向 A 发送了 rwnd = 400 的报文段。<br>但这个报文段在传送过程中<strong>丢失</strong>了。A 一直等待收到 B 发送的<strong>非零窗口</strong>的通知，而 B 也一直等待 A 发送的数据。<br>如果没有其他措施，这种<strong>互相等待的死锁局面</strong>将一直延续下去。为了解决这个问题，TCP 为<strong>每一个连接</strong>设有一个<strong>持续计时器</strong> (persistence timer)。</p>
<h5 id="3-持续计数器"><a href="#3-持续计数器" class="headerlink" title="3. 持续计数器"></a>3. <strong>持续计数器</strong></h5><p>只要 TCP 连接的一方收到对方的<strong>零窗口</strong>通知，就<strong>启动该持续计时器</strong>。<br>若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。若窗口不是零，则死锁的僵局就可以打破了。</p>
<h4 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h4><h5 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的<strong>性能</strong>就要变坏。这种现象称为<strong>拥塞</strong> (congestion)。最坏结果：系统崩溃。</p>
<img src="assets/1574686367422.png" alt="1574686367422" style="zoom:56%;" />

<p><strong>问题</strong>：增加资源能解决拥塞吗？<strong>不能</strong>。这是因为网络拥塞往往是由<strong>许多因素</strong>引起的，这是一个非常复杂的问题。简单地增加资源在许多情况下不但不能解决拥塞问题，而且还可能使网络的性能更坏。</p>
<p><strong>拥塞控制</strong>所起的作用：</p>
<img src="assets/1574686661544.png" alt="1574686661544" style="zoom:45%;" />

<blockquote>
<p><strong>流量控制与拥塞控制的对比</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">流量控制</th>
<th align="center">拥塞控制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">抑制<strong>发送端发</strong>送数据的速率，以使接收端<strong>来得及接收</strong></td>
<td align="center"><strong>防止</strong>过多的数据<strong>注入到网络</strong>中，使网络中的路由器或链路<strong>不致过载</strong></td>
</tr>
<tr>
<td align="center">是<strong>点对点</strong>通信量的控制，是<strong>端到端</strong>的问题</td>
<td align="center">是一个<strong>全局性</strong>的过程，涉及到与降低网络传输性能有关的所有因素</td>
</tr>
<tr>
<td align="center">使用<strong>滑动窗口</strong>实现</td>
<td align="center">使用<strong>拥塞窗口</strong>变量 + <strong>拥塞控制算法</strong>实现，还要<strong>配合滑动窗口</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>滑动窗口与拥塞窗口的区别</strong></p>
</blockquote>
<p><strong>滑动窗口</strong>是接收窗口，就是 TCP 头的那个<strong>窗口</strong>，可以理解为一块<strong>内存</strong>，一方面他要接收数据，一方面他要向应用层交付数据。而拥塞窗口是一个<strong>变量</strong>。</p>
<h5 id="2-TCP的拥塞控制方法"><a href="#2-TCP的拥塞控制方法" class="headerlink" title="2. TCP的拥塞控制方法"></a>2. TCP的拥塞控制方法</h5><p><strong>拥塞控制</strong>：基于<strong>拥塞窗口变量+几种拥塞控制算法</strong>实现。</p>
<ul>
<li>TCP 采用<strong>基于拥塞窗口</strong>的方法进行拥塞控制，该方法属于闭环控制方法。TCP==<strong>发送方</strong>==维持一个<strong>==拥塞窗口 cwnd==</strong> (Congestion Window) 的变量。<strong>发送端</strong>利用<strong>拥塞窗口</strong>根据网络的拥塞情况<strong>调整发送的数据量</strong>。</li>
<li><strong>发送窗口大小</strong>不仅取决于<strong>接收方窗口</strong>（就是 TCP 头部中的窗口值），还取决于网络的<strong>拥塞状况</strong>，所以真正的<strong>发送窗口值</strong>为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发送窗口的上限值 = Min (接收方窗口值，拥塞窗口值) = Min(rwnd, cwnd)</span><br></pre></td></tr></table></figure>

<ul>
<li>当 rwnd &lt; cwnd 时，是<strong>接收方</strong>的接收能力限制发送窗口的<strong>最大值</strong>。</li>
<li>当 cwnd &lt; rwnd 时，则是网络的<strong>拥塞限制</strong>发送窗口的<strong>最大值</strong>。 </li>
</ul>
<p>==发送方让自己的<strong>发送窗口</strong>取为<strong>拥塞窗口和接收方的接受窗口</strong>中<strong>较小的一个</strong>。==</p>
<p><strong>控制拥塞窗口的原则</strong>：</p>
<ul>
<li>只要网络<strong>没有</strong>出现拥塞，拥塞窗口就可以再<strong>增大</strong>一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。</li>
<li>但只要网络<strong>出现</strong>拥塞或有可能出现拥塞，就必须把拥塞窗口<strong>减小</strong>一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</li>
</ul>
<p><strong>拥塞的判断</strong>：</p>
<img src="assets/1574686970680.png" alt="1574686970680" style="zoom:40%;" />

<h5 id="3-TCP拥塞控制算法"><a href="#3-TCP拥塞控制算法" class="headerlink" title="3. TCP拥塞控制算法"></a>3. TCP拥塞控制算法</h5><p>四种拥塞控制算法（ RFC 5681） ：</p>
<ul>
<li><strong>慢开始</strong> (slow-start)</li>
<li><strong>拥塞避免</strong> (congestion avoidance)</li>
<li><strong>快重传</strong> (fast retransmit)</li>
<li><strong>快恢复</strong> (fast recovery)</li>
</ul>
<p>TCP 拥塞控制流程图。</p>
<img src="assets/1574688589340.png" alt="1574688589340" style="zoom:40%;" />

<h6 id="1-慢开始算法"><a href="#1-慢开始算法" class="headerlink" title="(1) 慢开始算法"></a>(1) 慢开始算法</h6><p><strong>目的</strong>：用来确定网络的<strong>负载能力</strong>或拥塞程度。</p>
<p><strong>算法的思路</strong>：由小到大<strong>逐渐</strong>增大拥塞窗口数值。</p>
<p>两个变量：</p>
<p>（1）<strong>拥塞窗口</strong>：<strong>初始</strong>拥塞窗口值。<strong>2 - 4</strong> 个最大报文段，窗口值逐渐增大。</p>
<p>（2）<strong>慢开始门限</strong>（<strong>ssthresh</strong>）：防止拥塞窗口增长过大引起网络拥塞。</p>
<p><strong>拥塞窗口 cwnd 控制方法</strong>：在每收到一个对<strong>新的报文段的确认</strong>后，可以把拥塞窗口<strong>增加最多一个</strong> <strong>SMSS</strong> 的数值。</p>
<img src="assets/1574687284733.png" alt="1574687284733" style="zoom:40%;" />

<p>每经过一个<strong>传输轮次</strong>，拥塞窗口值就==<strong>加倍</strong>==，即 <strong>==cwnd = cwnd * 2==</strong>。一个传输轮次所经历的时间其实就是<strong>往返时间 RTT</strong>。<strong>“传输轮次”</strong>更加强调：把拥塞窗口 cwnd 所允许发送的报文段<strong>都连续发送</strong>出去，并收到了对<strong>已发送</strong>的<strong>最后一个字节</strong>的确认。<br>例如拥塞窗口 cwnd = 4，这时的往返时间 RTT 就是发送方<strong>连续发送 4 个报文段</strong>，并收到这全部 <strong>4 个报文段</strong>的确认，总共经历的时间。</p>
<p><strong>设置慢开始门限状态变量 ssthresh</strong>。<strong>慢开始门限 ssthresh</strong> 的用法如下：</p>
<ul>
<li>当 <strong>cwnd &lt; ssthresh</strong> 时，使用<strong>慢开始</strong>算法。</li>
<li>当 <strong>cwnd &gt; ssthresh</strong> 时，停止使用慢开始算法而改用<strong>拥塞避免算法</strong>。</li>
<li>当 <strong>cwnd = ssthresh</strong> 时，既可使用慢开始算法，也可使用拥塞避免算法。</li>
</ul>
<h6 id="2-拥塞避免算法"><a href="#2-拥塞避免算法" class="headerlink" title="(2) 拥塞避免算法"></a>(2) 拥塞避免算法</h6><p>当 <strong>==cwnd &gt; ssthresh==</strong> 时，停止使用慢开始算法而改用<strong>拥塞避免算法</strong>。</p>
<p><strong>思路</strong>：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。<strong>超时之前</strong>，每经过一个<strong>传输轮次</strong>，拥塞窗口 <strong>==cwnd = cwnd + 1==</strong>。这就使拥塞窗口 cwnd 按<strong>线性规律缓慢增长</strong>。在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</p>
<img src="assets/1574687548934.png" alt="1574687548934" style="zoom:40%;" />

<p>当网络<strong>出现拥塞</strong>时：无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（<strong>重传定时器超时</strong>）：</p>
<p><strong>（1）ssthresh = max (cwnd / 2，2)</strong>：<strong>降低门限值</strong>（<strong>取一半</strong>）。</p>
<p><strong>（2）cwnd = 1</strong>： 拥塞窗口<strong>重新变为 1</strong>。</p>
<p><strong>（3）执行慢开始算法</strong>：重新执行<strong>慢开始</strong>。</p>
<p>目的：<strong>迅速</strong>减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组<strong>处理完毕</strong>。 </p>
<p><strong>慢开始与拥塞避免算法的过程==举例==：</strong></p>
<img src="assets/1574687664404.png" alt="1574687664404" style="zoom:40%;" />

<img src="assets/1574687681447.png" alt="1574687681447" style="zoom:40%;" />

<img src="assets/1574687709192.png" alt="1574687709192" style="zoom:40%;" />

<img src="assets/1574687785705.png" alt="1574687785705" style="zoom:40%;" />

<p>“拥塞避免” <strong>并非指完全</strong>能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“<strong>拥塞避免</strong>”是说在拥塞避免阶段把拥塞窗口<strong>控制为按线性规律增长</strong>，使网络比较<strong>不容易</strong>出现拥塞。 </p>
<img src="assets/1574687834142.png" alt="1574687834142" style="zoom:40%;" />

<img src="assets/1574687854685.png" alt="1574687854685" style="zoom:40%;" />

<img src="assets/1574687870869.png" alt="1574687870869" style="zoom:40%;" />

<h6 id="3-快重传算法"><a href="#3-快重传算法" class="headerlink" title="(3) 快重传算法"></a>(3) 快重传算法</h6><p><strong>发送方</strong>只要一连收到<strong>三个重复确认</strong>，就知道接收方确实<strong>没有收到</strong>报文段，因而应当<strong>立即进行重传</strong>（即“<strong>快重传</strong>”），这样就<strong>不会出现超时</strong>，发送方也不就会误认为出现了网络拥塞。使用快重传可以使整个网络的<strong>吞吐量</strong>提高约 20%。 不难看出，快重传并非取消重传计时器，而是在某些情况下可以<strong>更早地（更快地）重传</strong>丢失的报文段。 </p>
<p>采用<strong>快重传 FR</strong> (Fast Retransmission) 算法可以让<strong>发送方</strong>尽早知道发生了个别报文段的丢失。快重传算法首先要求接收方<strong>不要等待</strong>自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong>，即使收到了<strong>失序</strong>的报文段也要<strong>立即</strong>发出对已收到的报文段的<strong>重复确认</strong>。</p>
<p>下图中<strong>仅仅是丢失了 M3</strong>，其实<strong>并没有发生拥塞</strong>。此时<strong>连续收</strong>到其他三个<strong>重复确认</strong>，就说明其实网络<strong>大概率没有拥塞</strong>，而仅仅是发生了 M3 的丢失。此时启用快重传立即重传 M3。</p>
<img src="assets/1574688178264.png" alt="1574688178264" style="zoom:50%;" />

<h6 id="4-快恢复算法"><a href="#4-快恢复算法" class="headerlink" title="(4) 快恢复算法"></a>(4) 快恢复算法</h6><p>根据上图所示。当发送端收到连续<strong>三个重复的确认</strong>时，由于发送方现在认为网络<strong>很可能==没有==发生拥塞</strong>，因此现在<strong>不需要</strong>执行慢开始算法，而是执行<strong>快恢复算法</strong> FR (Fast Recovery) 算法：</p>
<p><strong>（1）慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；</strong><br><strong>（2）新拥塞窗口 cwnd = 慢开始门限 ssthresh ；</strong><br><strong>（3）开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</strong> </p>
<img src="assets/1574688469456.png" alt="1574688469456" style="zoom:40%;" />

<h5 id="4-AIMD"><a href="#4-AIMD" class="headerlink" title="4. AIMD"></a>4. AIMD</h5><p><strong>拥塞避免算法</strong>中，<strong>拥塞窗口</strong>是按照<strong>线性规律</strong>增大的。这常称为“<strong>加法增大</strong>” AI (Additive Increase)。当出现超时或 3 个<strong>重复的确认</strong>时，就要把<strong>门限值</strong>设置为当前拥塞窗口值的<strong>一半</strong>，并大大减小拥塞窗口的数值这常称为“<strong>乘法减小</strong>”MD (Multiplicative Decrease)。二者合在一起就是所谓的 <strong>AIMD</strong> 算法。</p>
<h4 id="TCP建立连接"><a href="#TCP建立连接" class="headerlink" title="TCP建立连接"></a>TCP建立连接</h4><p>TCP 是<strong>面向连接</strong>的协议。TCP 传输数据有三个阶段：<strong>连接建立</strong>、<strong>数据传送</strong>、<strong>连接释放</strong>。TCP 连接的管理就是使 TCP 连接的<strong>建立和释放</strong>都能正常地进行。</p>
<h5 id="1-连接过程"><a href="#1-连接过程" class="headerlink" title="1. 连接过程"></a>1. 连接过程</h5><p>TCP 连接建立过程中要解决的三个问题：</p>
<ul>
<li>要使每一方能够确知<strong>对方的存在</strong>。</li>
<li>要允许双方<strong>协商一些参数</strong>（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。</li>
<li>能够对运输实体<strong>资源</strong>（如缓存大小、连接表中的项目等）进行<strong>分配</strong>。</li>
</ul>
<p>TCP 建立连接的过程叫做<strong>握手</strong>。握手需要在客户和服务器之间<strong>交换三个 TCP 报文段</strong>，称之为<strong>三报文握手</strong>。流程如下：</p>
<img src="assets/1574741516560.png" alt="1574741516560" style="zoom:38%;" />

<p><strong>第一次握手</strong>：客户端发送连接请求，<strong>SYN</strong> 是<strong>同步号</strong>，<strong>seq</strong> 是数据的第一个<strong>字节序号</strong>，连接请求也有<strong>数据</strong>，只不过数据字节数<strong>为 1</strong>。TCP 连接是只有<strong>客户端才能发起</strong>。</p>
<p><strong>第二次握手</strong>：服务器<strong>收到</strong>连接请求，<strong>SYN 也为 1</strong>。并使 <strong>ACK = 1</strong>，表示收到客户端的连接请求。只有当 <strong>ACK = 1</strong> 时<strong>确认号 ack 字段才有效</strong>。所以必须设置 ACK = 1。由于服务器收到客户端发送的序号 <strong>seq = x</strong>，说明服务器收到这一个字节的数据，因此期待客户端下一个发送的数据的第一个字节是 seq = <strong>x + 1</strong>。所以确认号 <strong>ack = x + 1</strong>。同时服务器也设置一个自己的序号 <strong>seq = y</strong>。</p>
<p>这里要注意<strong>区分 ACK</strong>（<strong>标志位</strong>，<strong>为 1 时 ack 才有效</strong>， ACK 表示回复对方<strong>已经收到</strong>对方的消息） 与 <strong>ack</strong>（<strong>确认号</strong>，用于确认已经收到数据，并且回复下一个期待收到的数据）。</p>
<p><strong>第三次握手</strong>：客户端收到服务器的第二次握手，需要对服务器进行第三次握手，此时客户端回复 <strong>ACK = 1</strong>，表示收到服务端的第二次握手信息。由于之前客户端发送的是序列号 <strong>seq = x</strong>。而且服务端也发回来的确认号也是 x + 1。因此如果是正常的握手报文则客户端第三次握手的数据报文就是 <strong>seq = x + 1</strong>。同时客户端也收到服务器的 <strong>seq = y</strong>，需要确认收到了这个，因此回复给服务器的确认中确认号变为 <strong>ack = y + 1</strong>。</p>
<p>此时完成三次握手。之后进行数据传输。</p>
<p>简化一点（<strong>面试用</strong>）：相当于客户端和服务端<strong>都给</strong>对方发送了 <strong>SYN 和 ACK</strong> 信号。</p>
<img src="assets/image-20200522173211093.png" alt="image-20200522173211093" style="zoom: 45%;" />

<h5 id="2-三次握手的原因"><a href="#2-三次握手的原因" class="headerlink" title="2. 三次握手的原因"></a>2. 三次握手的原因</h5><blockquote>
<p><strong>为什么要进行第三次？只握手两次不行？</strong></p>
</blockquote>
<p><strong>原因 1：三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<ul>
<li><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。</p>
</li>
<li><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常。</p>
</li>
<li><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常。</p>
</li>
</ul>
<p>三次握手是为了确定客户端与服务端都能<strong>正常收发</strong>。</p>
<p><strong>原因 2：进行第三次握手是为了防止失效的连接请求到达服务器，让服务器错误再次打开连接，占用服务器资源。</strong></p>
<p>客户端发送的连接请求如果在网络中==<strong>滞留</strong>==，那么就会隔很长一段时间才能收到服务器端发回的<strong>连接确认</strong>。客户端等待一个==<strong>超时重传</strong>==时间之后，就会<strong>重新请求连接</strong>。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会<strong>打开两个连接</strong>。如果有第三次握手，客户端会<strong>忽略服务</strong>器之后发送的对滞留连接请求的连接确认（因为序号这些对应不上），不进行第三次握手，因此就不会再次打开连接。</p>
<blockquote>
<p><strong>为什么要传回SYN</strong></p>
</blockquote>
<p>服务端传回发送端所发送的 <strong>SYN 是为了告诉发送端</strong>它接收到的信息确实就是客户端所发送的信号。SYN 是 TCP/IP 建立<strong>连接时</strong>使用的<strong>握手信号</strong>。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 <strong>SYN 消息</strong>，服务器使用 <strong>SYN-ACK 应答</strong>表示<strong>接收到了这个消息</strong>，最后客户机*<em>再以 ACK *</em>消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
<h4 id="TCP释放连接"><a href="#TCP释放连接" class="headerlink" title="TCP释放连接"></a>TCP释放连接</h4><p>TCP 连接释放过程比较复杂，与连接不同，数据传输结束后，通信的双方<strong>都可</strong>释放连接。TCP 连接释放过程是<strong>四报文握手</strong>。</p>
<h5 id="1-释放过程"><a href="#1-释放过程" class="headerlink" title="1. 释放过程"></a>1. <strong>释放过程</strong></h5><p>通俗的例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”（第一次），B回答“我知道了”（第二次），但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”（第三次），A 回答“知道了”（第四次），这样通话才算结束。</p>
<p>这里假设客户端<strong>主动</strong>释放连接。释放连接过程如下：</p>
<img src="assets/1574741905218.png" alt="1574741905218" style="zoom:60%;" />

<p><strong>第一次挥手</strong>：客户端发送 <strong>FIN = 1</strong>。并且其数据部分序号为 <strong>seq = u</strong>（仅一个字节数据）。 </p>
<p><strong>第二次挥手</strong>：服务器收到<strong>释放连接</strong>的请求，那么<strong>直接</strong>回复 <strong>ACK = 1</strong>，表示<strong>确认收到</strong>客户端的释放请求。同时回复其确认号 <strong>ack = u + 1</strong>（即服务端期望客户端发送的下一个字节）。</p>
<p>同时：如果服务端还有未发送完成的数据，此时服务端可以<strong>继续</strong>发送给客户端，直到数据发送完成（注意此时只能服务端给客户端发送数据，也就是主动发起释放连接的一方只能接受<strong>不能再发送</strong>了）。</p>
<p><strong>第三次挥手</strong>：服务器数据发送完成之后发送另一个<strong>释放消息</strong>，即 <strong>FIN = 1</strong>，同时 <strong>ACK = 1</strong>，表示收到客户端的消息，此时 ack 有效，且 ack = <strong>u + 1</strong> 。同时服务端设置自己的序列号 seq = w。</p>
<p><strong>第四次挥手</strong>：客户端收到服务器的释放报文后，需要<strong>再次确认</strong>。此时 <strong>ACK = 1</strong>（确认信息有效），同时 <strong>seq = u + 1</strong>（客户端前一次发送 u 的基础上加 1），ack = <strong>w + 1</strong>（表明收到服务器的 seq = w 的信息）。<strong>四次挥手完成</strong>。</p>
<p>四次挥手流程简化版（面试用）：相当于客户端和服务端<strong>都给</strong>对方发送了 <strong>FIN 和 ACK</strong> 信息，只不过服务端的 分成了两次，所以变成了四次挥手。</p>
<img src="assets/image-20200804233105341.png" alt="image-20200804233105341" style="zoom:47%;" />

<blockquote>
<p><strong>四次挥手的原因</strong></p>
</blockquote>
<p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 <strong>CLOSE-WAIT</strong> 状态。这个状态是为了<strong>让服务器端发送还未传送完毕的数据</strong>，传送完毕之后，服务器<strong>会发送 FIN 连接释放</strong>报文。</p>
<h5 id="2-TIME-WAIT与CLOSE-WAIT"><a href="#2-TIME-WAIT与CLOSE-WAIT" class="headerlink" title="2. TIME_WAIT与CLOSE_WAIT"></a>2. TIME_WAIT与CLOSE_WAIT</h5><p><strong>TIME_WAIT</strong> 和 <strong>CLOSE_WAIT</strong> 分别表示主动关闭与被动关闭产生的<strong>阶段性状态</strong>，如果在线服务器大量出现这两种状态则会加重机器负载，影响有效的连接。</p>
<p>四次挥手之后之后<strong>客户端</strong>进入 <strong>Time-Wait 状态</strong>，等待 <strong>==2MSL==</strong> 的时间。<strong>MSL</strong> 中文可以译为“<strong>==报文最大生存时间==</strong>”，它是任何报文在网络上<strong>存在的最长时间</strong>，超过这个时间报文将被<strong>丢弃</strong>。一般时间长度是 30 秒。等待 2MSL 时间主要<strong>目的</strong>是<strong>怕最后一个 ACK</strong> 包对方<strong>没收到</strong>，那么对方在<strong>超时后将重发第三次握手的 FIN 包</strong>，主动关闭端接到<strong>重发的 FIN 包后可以再发一个 ACK 应答包</strong>，从而确保四次挥手完成。在 TIME_WAIT 状态时<strong>两端的端口不能使用</strong>，要等到 2MSL 时间结束<strong>才可继续使用</strong>。当连接处于 2MSL 等待阶段时任何迟到的报文段都将被<strong>丢弃</strong>。</p>
<p><strong>客户端</strong>接收到服务器端的 <strong>FIN 报文</strong>后进入此状态，此时<strong>并不是直接进入 CLOSED</strong> 状态，还需要等待一个<strong>时间计时器</strong>设置的时间 <strong>2MSL</strong>。这么做有两个理由：</p>
<ul>
<li><strong>确认被动关闭方能够顺利进入 CLOSED 状态</strong>。也就是确保<strong>最后一个确认报文</strong>能够到达。如果 <strong>B 没收到</strong> A 发送来的<strong>确认报文</strong>，那么就会<strong>重新发送连接释放</strong>请求报文，A 等待一段时间就是为了处理这种情况的发生。</li>
<li><strong>防止失效请求</strong>。等待一段时间是为了让本连接持续时间内所产生的<strong>所有报文都从网络中消失</strong>，使得下一个新的连接<strong>不会出现旧的连接</strong>请求报文。</li>
</ul>
<p><strong>CLOSE_WAIT：被动要求关闭的机器收到对方请求关闭连接的 FIN 报文，在第一次 ACK 应答后进入马上进入</strong>。</p>
<p><strong>CLOSE_WAIT 状态</strong>。这种状态其实是在<strong>等待关闭</strong>，并且通知应用程序<strong>发送剩余数据</strong>，处理现场信息，关闭相应资源。</p>
<p><strong>注意</strong>：由于 TIME_WAIT 状态无法真正释放句柄资源，此期间 Socket 中使用的本地端口在默认情况下是不能再被使用，对于高并发服务器来说，这会极大的限制有效连接的创建数量，成为性能瓶颈。所以建议将<strong>高并发服务器的 TIME_WAIT 超时时间调小</strong>。</p>
<h5 id="3-TCP连接状态总结"><a href="#3-TCP连接状态总结" class="headerlink" title="3. TCP连接状态总结"></a>3. TCP连接状态总结</h5><ul>
<li><strong>CLOSED</strong>：初始状态。</li>
<li><strong>LISTEN</strong>：服务器处于监听状态。</li>
<li><strong>SYN_SEND</strong>：客户端 socket 执行 CONNECT 连接，发送 SYN 包，进入此状态。</li>
<li><strong>SYN_RECV</strong>：服务端收到 SYN 包并发送服务端 SYN 包，进入此状态。</li>
<li><strong>ESTABLISH</strong>：表示<strong>连接建立</strong>。客户端发送了最后一个 ACK 包后进入此状态，服务端接收到 ACK 包后进入此状态。</li>
<li><strong>FIN_WAIT_1</strong>：终止连接的一方（通常是客户机）发送了 FIN 报文后进入。<strong>等待对方 FIN</strong>。</li>
<li><strong>CLOSE_WAIT</strong>：（假设服务器）接收到客户机 FIN 包之后等待关闭的阶段。在接收到对方的 FIN 包之后，自然是需要立即回复 ACK 包的，表示已经知道断开请求。但是本方是否立即断开连接（发送 FIN 包）取决于是否还有数据需要发送给客户端，若有，则在发送 FIN 包之前均为此状态。</li>
<li><strong>FIN_WAIT_2</strong>：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的 ACK 包，但并没有立即接收到服务端的 FIN 包，进入 FIN_WAIT_2 状态。</li>
<li><strong>LAST_ACK</strong>：服务端发动最后的 FIN 包，等待最后的客户端 ACK 响应，进入此状态。</li>
<li><strong>TIME_WAIT</strong>：客户端收到服务端的 FIN 包，并立即发出 ACK 包做最后的确认，在此之后的 2MSL 时间称为 TIME_WAIT 状态。</li>
</ul>
<h5 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h5><h6 id="1-保活计时器"><a href="#1-保活计时器" class="headerlink" title="(1) 保活计时器"></a>(1) 保活计时器</h6><p>用来防止在 TCP 连接出现<strong>长时期的空闲</strong>，比如客户端<strong>直接断电</strong>，来不及发送释放的报文。<strong>保活计时器</strong> 通常设置为 <strong>2 小时</strong> 。若服务器过了 2 小时<strong>还没有收到</strong>客户的信息，它就发送<strong>探测报文段</strong>。若发送了 10 个探测报文段（每一个相隔 75 秒）还没有响应，就假定客户出了故障，就主动<strong>终止该连接</strong>。</p>
<h6 id="2-TCP有限状态机"><a href="#2-TCP有限状态机" class="headerlink" title="(2) TCP有限状态机"></a>(2) TCP有限状态机</h6><p>箭头旁边的字，表明引起这种变迁的原因，或表明发生状态变迁后又出现什么动作。</p>
<p>图中有三种不同的箭头。</p>
<ul>
<li>粗实线箭头表示对客户进程的正常变迁。</li>
<li>粗虚线箭头表示对服务器进程的正常变迁。</li>
<li>细线箭头表示异常变迁。 </li>
</ul>
<img src="assets/1574742398806.png" alt="1574742398806" style="zoom:56%;" />

<h6 id="3-TCP连接限制"><a href="#3-TCP连接限制" class="headerlink" title="(3) TCP连接限制"></a>(3) TCP连接限制</h6><p>TCP 连接的建立是通过<strong>文件描述符（fd）</strong>完成的，通过创建套接字获取一个 fd，然后服务端和客户端需要基于获得的 fd 调用不同的函数分别进入监听状态和发起连接请求。<strong>fd 的数量</strong>决定了服务端进程能创建连接的数量。所以需要注意调整服务端进程和操作系统所支持的<strong>最大文件句柄数</strong>。</p>
<h4 id="TCP协议保证可靠传输总结"><a href="#TCP协议保证可靠传输总结" class="headerlink" title="TCP协议保证可靠传输总结"></a>TCP协议保证可靠传输总结</h4><p>总结一下 TCP 协议是如何保证传输可靠的？？答案就是：<strong>==ARQ 协议 + 滑动窗口协议==</strong>。</p>
<ol>
<li><strong>数据编号</strong>：应用数据被分割成 TCP 认为最适合发送的<strong>数据块</strong>。TCP 给发送的每一个<strong>数据包进行编号</strong>，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的<strong>检验和</strong>。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。TCP 的接收端会<strong>丢弃重复</strong>的数据。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个<strong>报文</strong>后，它启动一个<strong>定时器</strong>，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将<strong>重发</strong>这个报文段。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
</ol>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><h5 id="1-TCP连接中如果断电怎么办？"><a href="#1-TCP连接中如果断电怎么办？" class="headerlink" title="1. TCP连接中如果断电怎么办？"></a>1. TCP连接中如果断电怎么办？</h5><p>当 TCP 两端 A、B 建立了连接后，如果一端拔掉网线或者<strong>拔掉电源</strong>，那么另一端能够收到通知吗？<strong>答案是不会</strong>。</p>
<p>TCP 是一种<strong>有连接</strong>的协议，但是这个连接并不是指有一条实际的电路，而是一种<strong>虚拟的电路</strong>。TCP 的建立连接和断开连接都是通过<strong>发送数据</strong>实现的，也就是常说的三次握手、四次挥手。TCP 两端保存了一种<strong>数据的状态</strong>，就代表这种连接，TCP 两端之间的路由设备只是将数据转发到目的地，并不知道这些数据实际代表了什么含义，也并没有在其中保存任何的状态信息，也就是说中间的路由设备没有什么连接的概念，只是将数据转发到目的地，只有数据的发送者和接受者两端真正的知道传输的数据代表着一条连接。</p>
<p>但是这就说明了一点，如果<strong>不发送数据</strong>那么是<strong>无法断开连接</strong>的。正常情况下当 TCP 的一端 A 调用了 SOCKET 的 close 或者进程结束，操作系统就会按照 TCP 协议发送 FIN 数据报文。B 端收到后就会<strong>断开连接</strong>。但是当出现了上述的异常情况时：<strong>被拔掉网线或者断掉电源</strong>，总结起来就是<strong>没有机会发出断开的 FIN 数据报文</strong>。那么和 A 直连的路由设备虽然知道 A 设备已经断开了，但是路由设备并没有保存连接的状态信息，所以路由设备也就不可能去通知 B 端 A 端的断开。而 B 端没有收到断开的数据报文就会<strong>依然保持连接</strong>。<strong>所以 A 端拔掉网线或者断掉电源后 B 端是没办法收到断开连接的通知的</strong>。<br><strong>保持连接</strong>并不是毫无代价的，如果这种异常断开的连接有很多，那么势必会耗费大量的资源，必须要想办法<strong>检测出这种异常连接</strong>。<br>检测的方法很简单，只要让 B 端主动通过这个连接向 A 端<strong>继续发送数据</strong>即可。上文说过，A 端异常断开后，和 A 端直接连接的路由器是知道的。当 B 端发送的数据经过转发后到达这个路由器后，必然最终会返回 B 端一个目的不可达。此时 B 端立刻就会知道这条连接其实已经异常断开了。<br>但是 B 端不可能知道什么时候会出现这种异常，所以 B 端必须<strong>定时发送数据来检测连接是否异常断开</strong>。数据的内容无关紧要，任何数据都能达到这个效果。这个数据就是经常在 TCP 编程中所说的<strong>心跳</strong>。</p>
<p><strong>KEEP_ALIVE</strong>：<strong>TCP 协议本身就提供了一种这样的机制来探测对端的存活</strong>。TCP 协议有一个 KEEP_LIVE 开关，只要打开这个开关就会定时发送一些数据<strong>长度为零</strong>的探测心跳包，发送的频率和次数都可以设置。</p>
<p><strong>应用层心跳</strong>：除了使用 TCP 协议本身的保活开关机制，还可以在<strong>应用层主动发送心跳数据包</strong>，那么在应用层主动发送心跳数据包的方式和 TCP 协议本身的保活机制有什么区别呢？应用层的心跳数据包会耗费更多的带宽，因为 TCP 协议的保活机制发送的是<strong>数据长度为零的心跳包</strong>，而应用层的心跳数据包长度则必然会大于 0。应用层的心跳数据包可以带一些应用所需要的数据，随应用自己控制，而 TCP 协议的保活机制则是对于应用层透明的，无法利用心跳携带数据。<br><strong>双向心跳</strong>：那么是否只是一端向另一端发送心跳就行了呢？显然不行。因为两端都有可能发生异常断开的情况。所以 TCP 连接的<strong>两端必须都向对端发送心跳</strong>。</p>
<ul>
<li>参考资料：<a href="https://blog.csdn.net/bjrxyz/article/details/71076442" target="_blank" rel="noopener">https://blog.csdn.net/bjrxyz/article/details/71076442</a></li>
</ul>
<h5 id="2-流量控制和拥塞控制的区别？"><a href="#2-流量控制和拥塞控制的区别？" class="headerlink" title="2. 流量控制和拥塞控制的区别？"></a>2. 流量控制和拥塞控制的区别？</h5><ul>
<li><p><strong>拥塞控制</strong>所要做的都有一个前提，就是网络能够承受现有的<strong>网络负荷</strong>。</p>
</li>
<li><p><strong>拥塞控制</strong>是一个<strong>全局性的过程</strong>，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</p>
</li>
<li><p><strong>流量控制</strong>往往指在给定的发送端和接收端之间的<strong>点对点</strong>通信量的控制。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。 </p>
</li>
<li><p><strong>流量控制</strong>属于通信<strong>双方协商</strong>；<strong>拥塞控制</strong>涉及<strong>通信链路全局</strong>。</p>
</li>
<li><p>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。</p>
</li>
<li><p><strong>发送方实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。</strong></p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/C%20%E7%BD%91%E7%BB%9C/F%20%E5%BA%94%E7%94%A8%E5%B1%82/" rel="next" title="ShiftJava/C 网络/F 应用层">
                <i class="fa fa-chevron-left"></i> ShiftJava/C 网络/F 应用层
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/C%20%E7%BD%91%E7%BB%9C/D%20%E7%BD%91%E7%BB%9C%E5%B1%82/" rel="prev" title="ShiftJava/C 网络/D 网络层">
                ShiftJava/C 网络/D 网络层 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#传输层"><span class="nav-number">1.</span> <span class="nav-text">传输层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传输层概述"><span class="nav-number">1.1.</span> <span class="nav-text">传输层概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-进程间通信"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 进程间通信</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-传输层的两个协议"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 传输层的两个协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-传输层的端口"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. 传输层的端口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户数据报协议UDP"><span class="nav-number">1.2.</span> <span class="nav-text">用户数据报协议UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-UDP协议的首部格式"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. UDP协议的首部格式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-UDP协议特点"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. UDP协议特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-UDP可靠传输"><span class="nav-number">1.2.4.</span> <span class="nav-text">4. UDP可靠传输</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传输控制协议TCP"><span class="nav-number">1.3.</span> <span class="nav-text">传输控制协议TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-TCP报文格式"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. TCP报文格式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP可靠传输的工作原理"><span class="nav-number">1.4.</span> <span class="nav-text">TCP可靠传输的工作原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ARQ协议"><span class="nav-number">1.5.</span> <span class="nav-text">ARQ协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-停止等待ARQ协议"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. 停止等待ARQ协议</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-无差错情况"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">(1) 无差错情况</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-出现差错"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">(2) 出现差错</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-确认丢失"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">(3) 确认丢失</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-确认迟到"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">(4) 确认迟到</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-信道利用率"><span class="nav-number">1.5.1.5.</span> <span class="nav-text">(5) 信道利用率</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-自动请求重传协议"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. 自动请求重传协议</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-流水线传输"><span class="nav-number">1.5.3.</span> <span class="nav-text">3. 流水线传输</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-连续ARQ协议"><span class="nav-number">1.5.4.</span> <span class="nav-text">4. 连续ARQ协议</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP可靠传输的实现"><span class="nav-number">1.6.</span> <span class="nav-text">TCP可靠传输的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-滑动窗口协议"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. 滑动窗口协议</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-基本流程"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">(1) 基本流程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-滑动窗口与缓存"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">(2) 滑动窗口与缓存</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-超时重传时间"><span class="nav-number">1.6.2.</span> <span class="nav-text">2. 超时重传时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-选择确认SACK"><span class="nav-number">1.6.3.</span> <span class="nav-text">3. 选择确认SACK</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP流量控制"><span class="nav-number">1.7.</span> <span class="nav-text">TCP流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-2"><span class="nav-number">1.7.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-可能发生死锁"><span class="nav-number">1.7.2.</span> <span class="nav-text">2. 可能发生死锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-持续计数器"><span class="nav-number">1.7.3.</span> <span class="nav-text">3. 持续计数器</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP拥塞控制"><span class="nav-number">1.8.</span> <span class="nav-text">TCP拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-3"><span class="nav-number">1.8.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-TCP的拥塞控制方法"><span class="nav-number">1.8.2.</span> <span class="nav-text">2. TCP的拥塞控制方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-TCP拥塞控制算法"><span class="nav-number">1.8.3.</span> <span class="nav-text">3. TCP拥塞控制算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-慢开始算法"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">(1) 慢开始算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-拥塞避免算法"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">(2) 拥塞避免算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-快重传算法"><span class="nav-number">1.8.3.3.</span> <span class="nav-text">(3) 快重传算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-快恢复算法"><span class="nav-number">1.8.3.4.</span> <span class="nav-text">(4) 快恢复算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-AIMD"><span class="nav-number">1.8.4.</span> <span class="nav-text">4. AIMD</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP建立连接"><span class="nav-number">1.9.</span> <span class="nav-text">TCP建立连接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-连接过程"><span class="nav-number">1.9.1.</span> <span class="nav-text">1. 连接过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-三次握手的原因"><span class="nav-number">1.9.2.</span> <span class="nav-text">2. 三次握手的原因</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP释放连接"><span class="nav-number">1.10.</span> <span class="nav-text">TCP释放连接</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-释放过程"><span class="nav-number">1.10.1.</span> <span class="nav-text">1. 释放过程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-TIME-WAIT与CLOSE-WAIT"><span class="nav-number">1.10.2.</span> <span class="nav-text">2. TIME_WAIT与CLOSE_WAIT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-TCP连接状态总结"><span class="nav-number">1.10.3.</span> <span class="nav-text">3. TCP连接状态总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-其他"><span class="nav-number">1.10.4.</span> <span class="nav-text">4. 其他</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-保活计时器"><span class="nav-number">1.10.4.1.</span> <span class="nav-text">(1) 保活计时器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-TCP有限状态机"><span class="nav-number">1.10.4.2.</span> <span class="nav-text">(2) TCP有限状态机</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-TCP连接限制"><span class="nav-number">1.10.4.3.</span> <span class="nav-text">(3) TCP连接限制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP协议保证可靠传输总结"><span class="nav-number">1.11.</span> <span class="nav-text">TCP协议保证可靠传输总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面试题"><span class="nav-number">1.12.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-TCP连接中如果断电怎么办？"><span class="nav-number">1.12.1.</span> <span class="nav-text">1. TCP连接中如果断电怎么办？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-流量控制和拥塞控制的区别？"><span class="nav-number">1.12.2.</span> <span class="nav-text">2. 流量控制和拥塞控制的区别？</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
