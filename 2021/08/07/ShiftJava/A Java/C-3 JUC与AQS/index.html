<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] JUC与AQS基础1. 概述JUC 就是 java.util .concurrent 工具包的简称，是一个处理线程的工具包。 AQS 的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面，AQS 是 JUC 的核心。JUC 当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;A Java&#x2F;C-3 JUC与AQS">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-3%20JUC%E4%B8%8EAQS&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] JUC与AQS基础1. 概述JUC 就是 java.util .concurrent 工具包的简称，是一个处理线程的工具包。 AQS 的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面，AQS 是 JUC 的核心。JUC 当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-3%20JUC%E4%B8%8EAQS&#x2F;assets&#x2F;image-20200509112113728.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-3%20JUC%E4%B8%8EAQS&#x2F;assets&#x2F;image-20200509112927403.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-3%20JUC%E4%B8%8EAQS&#x2F;assets&#x2F;image-20200611195954373.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-3%20JUC%E4%B8%8EAQS&#x2F;assets&#x2F;image-20200611200029272.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-3%20JUC%E4%B8%8EAQS&#x2F;assets&#x2F;image-20200611200045343.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-3%20JUC%E4%B8%8EAQS&#x2F;assets&#x2F;image-20200509173912812.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;A%20Java&#x2F;C-3%20JUC%E4%B8%8EAQS&#x2F;assets&#x2F;image-20200509112113728.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/A Java/C-3 JUC与AQS/"/>





  <title>ShiftJava/A Java/C-3 JUC与AQS | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/A%20Java/C-3%20JUC%E4%B8%8EAQS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/A Java/C-3 JUC与AQS</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="JUC与AQS"><a href="#JUC与AQS" class="headerlink" title="JUC与AQS"></a>JUC与AQS</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>JUC 就是 java.util .concurrent 工具包的简称，是一个处理线程的工具包。</p>
<p><strong>AQS</strong> 的全称为（<strong>AbstractQueuedSynchronizer</strong>），这个类在 <strong>java.util.concurrent.locks</strong> 包下面，AQS 是 JUC 的核心。JUC 当中的大多数<strong>同步器</strong>实现都是围绕着<strong>共同的基础行为</strong>，比如<strong>等待队列、条件队列、独占获取、共享获取</strong>等，而这个行为的抽象就基于 AQS 实现，AQS 定义了一套<strong>多线程访问共享资源的同步器框架</strong>，是一个<strong>依赖状态(state)的同步器</strong>。</p>
<img src="assets/image-20200509112113728.png" alt="image-20200509112113728" style="zoom:77%;" />

<p>可以看到这个包下的东西主要是上面的内容。</p>
<p>AQS 是一个用来<strong>构建锁和同步器的框架</strong>，使用 AQS 能简单且高效地构造出应用广泛的<strong>大量的同步器</strong>，比如ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。利用 AQS 可以非常容易地构造出符合自己需求的<strong>自定义同步器</strong>。</p>
<p><strong>AQS 特性</strong>：</p>
<ul>
<li>阻塞等待队列。</li>
<li>共享/独占。</li>
<li>公平/非公平。</li>
<li>可重入。</li>
<li>允许中断。</li>
</ul>
<h4 id="AQS框架概览"><a href="#AQS框架概览" class="headerlink" title="AQS框架概览"></a>AQS框架概览</h4><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<h5 id="1-Node结点"><a href="#1-Node结点" class="headerlink" title="1. Node结点"></a>1. Node结点</h5><p>AQS 是将每条请求共享资源的<strong>线程</strong>封装成一个 CLH 锁队列的一个<strong>结点</strong>（Node）来实现锁的分配。</p>
<h6 id="1-基本属性"><a href="#1-基本属性" class="headerlink" title="(1) 基本属性"></a>(1) 基本属性</h6><p>Node 结点是 AbstractQueuedSynchronizer 中的一个<strong>静态内部类</strong>，是构成 <strong>CLH 队列</strong>的重要类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// waitStatus值，表示线程已被取消（等待超时或者被中断）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus值，表示后继线程需要被唤醒（unpaking）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// waitStatus值，表示结点线程等待在condition上，当被signal后，会从等待队列转移到同步到队列中 </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// waitStatus值，表示下一次共享式同步状态会被无条件地传播下去</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 重要：表示当前Node结点的等待状态，包括五种状态（上面四种值+默认的初始值0）</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">// 当前结点的前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">// 当前结点的后继结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">// 封装与当前结点关联的排队中的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">// 下一个等待结点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否是共享模式</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 返回前驱结点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本节开始讲解 AQS 的源码实现。依照 <strong>acquire-release</strong>、<strong>acquireShared-releaseShared</strong> 的<strong>次序</strong>来。</p>
<h6 id="2-结点状态waitStatus"><a href="#2-结点状态waitStatus" class="headerlink" title="(2) 结点状态waitStatus"></a>(2) 结点状态waitStatus</h6><p>Node 结点是对<strong>每一个等待获取资源的线程的封装</strong>，其包含了<strong>需要同步的线程本身</strong>及其<strong>等待状态</strong>，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量 <strong>waitStatus</strong> 则表示当前 Node 结点的<strong>等待状态</strong>，共有 <strong>5</strong> 种取值 CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。</p>
<ul>
<li><strong>CANCELLED</strong>(1)：表示<strong>当前结点已取消调度</strong>。当 timeout 或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li>
<li><strong>SIGNAL</strong>(-1)：表示后继结点在<strong>等待当前结点唤醒</strong>。后继结点入队时，会将前继结点的状态更新为 SIGNAL。</li>
<li><strong>CONDITION</strong>(-2)：表示结点<strong>等待在 Condition 上</strong>，当其他线程调用了 Condition 的 <strong>signal</strong>() 方法后， CONDITION 状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取<strong>同步锁</strong>。</li>
<li><strong>PROPAGATE</strong>(-3)：共享模式下，前继结点<strong>不仅会</strong>唤醒其后继结点，同时也可能会<strong>唤醒后继的后继结点</strong>。</li>
<li><strong>0</strong>：新结点入队时的默认状态。</li>
</ul>
<p>注意，<strong>==负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用 &gt; 0、&lt; 0来判断结点的状态是否正常==</strong>。</p>
<h5 id="2-框架核心组件"><a href="#2-框架核心组件" class="headerlink" title="2. 框架核心组件"></a>2. 框架核心组件</h5><p>AQS 维护了一个 <strong>==volatile int state==</strong> 状态量（代表共享资源）和一个 <strong>FIFO 线程等待队列（==CLH== 队列）</strong>（多线程争用资源被<strong>阻塞时会进入此队列</strong>）。这里 volatile 是<strong>核心</strong>关键词。AQS 维护一个<strong>共享资源 ==state==</strong>，通过内置的 <strong>==CLH 等待队列==（FIFO队列）</strong> 来完成获取资源线程的<strong>排队</strong>工作。</p>
<p>AQS 是将每条请求共享资源的<strong>线程</strong>封装成一个 CLH 锁队列的一个<strong>结点（Node）</strong>来实现锁的分配。</p>
<img src="assets/image-20200509112927403.png" alt="image-20200509112927403" style="zoom:80%;" />

<h6 id="1-state状态量"><a href="#1-state状态量" class="headerlink" title="(1) state状态量"></a>(1) state状态量</h6><p>AQS 使用一个 int 成员变量来表示<strong>同步状态</strong>，通过内置的 <strong>FIFO 队列</strong>来完成获取<strong>资源线程的排队</strong>工作。AQS 使用 <strong>CAS</strong> 对该<strong>同步状态进行原子操作</strong>实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;    <span class="comment">// 共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>

<p><strong>state 状态信息</strong>通过 protected 类型的 <strong>getState，setState，compareAndSetState</strong> 进行操作与访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>int 类型的 state 共 32 位，分别描述<strong>读锁和写锁的数量</strong>，于是将 state 变量“<strong>按位切割</strong>”切分成了两个部分：</p>
<ul>
<li><p><strong>高 16 位</strong>表示<strong>读锁</strong>状态（<strong>读锁个数</strong>）。</p>
</li>
<li><p><strong>低 16 位</strong>表示<strong>写锁</strong>状态（<strong>写锁个数</strong>）。</p>
</li>
</ul>
<p><img src="assets/image-20200611195954373.png" alt="image-20200611195954373"></p>
<h6 id="2-CLH队列"><a href="#2-CLH队列" class="headerlink" title="(2) CLH队列"></a>(2) CLH队列</h6><p>AQS 当中的<strong>同步等待队列</strong>也称 <strong>CLH 队列</strong>，CLH 队列是 Craig、Landin、Hagersten 三人发明的一种基于双向链表数据结构的队列，是 FIFO 先入先出线程等待队列，Java 中的 CLH 队列是原 CLH 队列的一个变种，线程由原自旋机制改为<strong>阻塞机制</strong>。  </p>
<p>CLH 队列是通过静态内部类 <strong>Node 结点</strong>组成的<strong>双向链表</strong>，每个 Node 结点维护一个 prev 引用和 next 引用，分别指向自己的<strong>前驱和后继结点</strong>。AQS 自身维护两个指针，分别指向队列<strong>头部 head 和尾部 tail</strong>。这个<strong>队列</strong>可以用来构建<strong>锁</strong>或者其他相关的<strong>同步装置</strong>的基础框架。</p>
<p><img src="assets/image-20200611200029272.png" alt="image-20200611200029272"></p>
<p>CLH 队列其实就是个<strong>双端双向链表</strong>。当线程<strong>获取资源失败</strong>（比如 tryAcquire 时试图<strong>设置 state 状态失败</strong>），<strong>线程被封装并被构造</strong>成<strong>一个结点</strong>加入 <strong>CLH 队列</strong>中（Node 结点的一个<strong>属性</strong>就是 Thread），同时当前<strong>线程</strong>会被<strong>阻塞</strong>在队列中（通过 <strong>LockSupport.park</strong> 实现，其实是<strong>等待态</strong>）。当持有同步状态的线程<strong>释放同步状态</strong>时，会<strong>唤醒</strong>后继结点，然后此结点线程继续加入到对同步状态的争夺中。</p>
<h6 id="3-条件等待队列"><a href="#3-条件等待队列" class="headerlink" title="(3) 条件等待队列"></a>(3) 条件等待队列</h6><p>Condition 是一个多线程间协调通信的工具类，使得某个或者某些线程一起等待某个条件（Condition），只有当该条件具备时，这些等待线程才会被唤醒，从而重新争夺锁。</p>
<p>不管是<strong>条件队列</strong>还是 <strong>CLH 等待队列</strong>，都是基于 <strong>AQS 内部类 Node 构建</strong>。注意：<strong>等待队列是双向链表，而条件队列是单向链表</strong>。条件队列里面 prev = null，next = null。</p>
<p>条件队列<strong>不是必须</strong>的 , 只有当程序中<strong>需要</strong> Condition 的时候<strong>才会存在这个单向链表</strong> , 并且可能会有<strong>多个条件队列</strong>。</p>
<p><img src="assets/image-20200611200045343.png" alt="image-20200611200045343"></p>
<h5 id="3-资源共享方式"><a href="#3-资源共享方式" class="headerlink" title="3. 资源共享方式"></a>3. 资源共享方式</h5><p>AQS 定义<strong>两种资源共享方式（同步方式）</strong>：</p>
<ul>
<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁。公平锁：按照线程在队列中的排队顺序，先到者先拿到锁。非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的。</li>
<li><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 后面会讲到。</li>
</ul>
<p>ReentrantReadWriteLock 可以看成是<strong>组合式</strong>，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的<strong>自定义</strong>同步器争用共享资源的方式也不同。<strong>自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可</strong>，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在<strong>顶层</strong>实现好了。自定义<strong>同步器实现时主要实现以下几种方法：</strong></p>
<ul>
<li><strong>isHeldExclusively</strong>()：该线程是否正在<strong>独占</strong>资源。只有用到 <strong>condition</strong> 才需要去实现它。</li>
<li><strong>tryAcquire</strong>(int)：<strong>独占</strong>方式。尝试<strong>获取</strong>资源，成功则返回 true，失败则返回 false。</li>
<li><strong>tryRelease</strong>(int)：<strong>独占</strong>方式。尝试<strong>释放</strong>资源，成功则返回 true，失败则返回 false。</li>
<li><strong>tryAcquireShared</strong>(int)：<strong>共享</strong>方式。尝试获取资源。<strong>负数表示失败</strong>；0 表示成功，但没有剩余可用资源；正数<strong>表示成功</strong>，且有剩余资源。</li>
<li><strong>tryReleaseShared</strong>(int)：<strong>共享</strong>方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回 true，否则返回 false。</li>
</ul>
<p>以 ReentrantLock 为例，<strong>state 初始化为 0</strong>，表示<strong>未锁定</strong>状态。A 线程 lock() 时，会调用 <strong>tryAcquire</strong>() 独占该锁并将 <strong>state+1</strong>。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock() 到 <strong>state=0</strong>（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以<strong>重复获取此锁</strong>的（state 会<strong>累加</strong>），这就是<strong>可重入锁</strong>的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能<strong>回到零值</strong>的。</p>
<p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，<strong>state 也初始化为 N</strong>（注意 N 要与线程个数一致）。这 N 个子线程是<strong>并行</strong>执行的，每个子线程执行完后 countDown() 一次，<strong>state 会 CAS 减 1</strong>。等到所有子线程都执行完后(即 state = 0)，会 <strong>unpark</strong>() 主调用线程，然后主调用线程就会从 <strong>await</strong>() 方法返回，继续后余动作。</p>
<p>这样方便使用者实现不同类型的<strong>同步组件</strong>，<strong>独占式</strong>如 ReentrantLock，<strong>共享式</strong>如 Semaphore，CountDownLatch，<strong>组合式</strong>的如 ReentrantReadWriteLock。总之，AQS 为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</p>
<p>一般来说，自定义同步器要么是<strong>独占方式</strong>，要么是<strong>共享方式</strong>，他们也只需实现 <strong>tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared</strong> 中的<strong>一种</strong>即可（当然也有独占和共享<strong>都有</strong>的如 ReentrantReadWriteLock）。</p>
<h4 id="同步源码分析"><a href="#同步源码分析" class="headerlink" title="同步源码分析"></a>同步源码分析</h4><h5 id="1-独占式获取同步状态acquire-int"><a href="#1-独占式获取同步状态acquire-int" class="headerlink" title="1. 独占式获取同步状态acquire(int)"></a>1. 独占式获取同步状态acquire(int)</h5><p>此方法是<strong>独占模式</strong>下线程获取<strong>共享资源</strong>的顶层入口。如果<strong>获取到资源</strong>，线程<strong>直接返回</strong>，否则进入<strong>等待队列</strong>，直到获取到资源为止，且整个过程忽略中断的影响。这也正是 <strong>lock() 的语义</strong>，当然不仅仅只限于 lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是 acquire() 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数流程如下：</p>
<ul>
<li><strong>tryAcquire</strong>() 尝试直接去<strong>获取资源</strong>，如果成功则直接返回（这里体现了<strong>非公平锁</strong>，每个线程获取锁时会尝试直接抢占一次，而 CLH 队列中可能还有别的线程在等待）；</li>
<li><strong>addWaiter</strong>() 将该线程加入<strong>等待队列的尾部</strong>，并标记为<strong>独占模式</strong>；</li>
<li><strong>acquireQueued</strong>() 使线程阻塞在<strong>等待队列</strong>中获取资源，一直获<strong>取到资源后才返回</strong>。如果在整个等待过程中被中断过，则返回 true，否则返回 false。</li>
<li>如果线程在等待过程中<strong>被中断过</strong>，它是<strong>不响应</strong>的。只是<strong>获取资源后</strong>才再进行自我中断 <strong>selfInterrupt</strong>()，将<strong>中断补上</strong>。</li>
</ul>
<h6 id="1-tryAcquire"><a href="#1-tryAcquire" class="headerlink" title="(1) tryAcquire()"></a>(1) tryAcquire()</h6><p>此方法尝试去<strong>获取独占资源</strong>。如果获取成功，则直接返回 true，否则直接返回 false。这也正是 <strong>tryLock</strong>() 的语义，还是那句话，当然<strong>不仅仅只限于 tryLock()</strong>。如下是 tryAcquire() 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>什么？直接 <strong>throw</strong> 异常？说好的功能呢？<strong>还记得概述里讲的 AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？</strong>就是这里了！！！AQS 这里只定义了一个接口，具体资源的获取<strong>交由自定义同步器去实现</strong>了（<strong>通过 state 的 get/set/CA</strong>S）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p>
<p>这里之所以没有定义成 abstract，是因为<strong>独占模式下只用实现 tryAcquire-tryRelease</strong>，而<strong>共享模式下只用实现 tryAcquireShared-tryReleaseShared</strong>。如果都定义成 abstract，那么每个模式也要去实现另一模式下的接口。</p>
<h6 id="2-addWaiter-Node"><a href="#2-addWaiter-Node" class="headerlink" title="(2) addWaiter(Node)"></a>(2) addWaiter(Node)</h6><p>此方法用于将当前线程<strong>加入到等待队列的队尾</strong>，并返回当前线程所在的结点。还是上源码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前线程封装成Node结点，mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// //尝试快速方式直接放到队尾</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点加入到尾部</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上一步失败则通过enq入队</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>enq(Node) 方法用于<strong>将 node 加入队尾</strong>。源码如下：。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS"自旋"，直到成功加入队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">            <span class="comment">// 正常流程，放入队尾</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果看过 AtomicInteger.getAndIncrement() 函数源码，那么这段代码的精华就容易看出来。<strong>CAS 自旋 volatile 变量</strong>，是一种很经典的用法。</p>
<h6 id="3-acquireQueued-Node-int"><a href="#3-acquireQueued-Node-int" class="headerlink" title="(3) acquireQueued(Node, int)"></a>(3) acquireQueued(Node, int)</h6><p>通过 tryAcquire() 和 addWaiter()，该线程获取资源失败，已经被放入<strong>等待队列尾部</strong>了。该线程下一部该干什么？<strong>进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了</strong>。没错，就是这样！是不是跟医院排队拿号有点相似~~ <strong>acquireQueued</strong>() 就是干这件事：<strong>在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回</strong>。这个函数非常关键，还是上源码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">// 标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">// 标记等待过程中是否被中断过</span></span><br><span class="line">        <span class="comment">// 又是一个“自旋”！</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 拿到前驱</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);<span class="comment">// 拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span></span><br><span class="line">                failed = <span class="keyword">false</span>; <span class="comment">// 成功获取资源</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">// 返回等待过程中是否被中断过</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果自己可以休息了，就通过park()进入waiting状态，直到被unpark()。如果不可中断的情况下被中断了，那么会从park()中醒过来，发现拿不到资源，从而继续进入park()等待</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;<span class="comment">// 如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 如果等待过程中没有成功获取资源（如timeout，或者可中断的情况下被中断了），那么取消结点在队列中的等待</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先不急着总结 acquireQueued() 的函数流程，先看看 shouldParkAfterFailedAcquire() 和 parkAndCheckInterrupt() 具体干些什么。</p>
<p>shouldParkAfterFailedAcquire(Node, Node) 方法主要用于<strong>检查状态</strong>，看看自己是否真的可以去休息了（进入 <strong>waiting</strong> 状态），万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到前驱的状态</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// 如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个流程中，如果前驱结点的状态<strong>不是 SIGNAL</strong>，那么自己就不能安心去休息，需要去找个安心的休息点，同时<strong>可以再尝试</strong>下看有没有机会轮到自己拿号。</p>
<p>parkAndCheckInterrupt() 方法。如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);<span class="comment">// 调用park()使线程进入waiting状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();<span class="comment">// 如果被唤醒，查看自己是不是被中断的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>park</strong>() 会让当前线程进入 <strong>waiting 状态</strong>。在此状态下，有两种途径可以<strong>唤醒该线程</strong>：1）被 <strong>unpark</strong>()；2）被 <strong>interrupt</strong>()。需要注意的是，Thread.interrupted() 会<strong>清除当前线程的中断标记位</strong>。</p>
<p>看了 shouldParkAfterFailedAcquire() 和 parkAndCheckInterrupt()，现在让我们再回到 <strong>acquireQueued</strong>()，总结下该函数的具体流程：</p>
<ol>
<li>结点进入队尾后，检查状态，找到安全休息点。</li>
<li>调用 park() 进入 waiting 状态，等待 unpark() 或i nterrupt() 唤醒自己。</li>
<li>被唤醒后，看自己是不是有资格能拿到号。如果拿到，head 指向当前结点，并返回从入队到拿到号的整个过程中是否被中断过；如果没拿到，继续流程 1。</li>
</ol>
<p>绕了一大圈 acquireQueued() 分析完之后，接下来再回到 <strong>acquire</strong>()！再贴上它的源码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;</span><br><span class="line">        selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来总结下它的流程吧：</p>
<ol>
<li>调用自定义同步器的 <strong>tryAcquire</strong>() 尝试<strong>直接去获取资源</strong>，如果成功则直接返回。</li>
<li>没成功，则 <strong>addWaiter</strong>() 将该线程加入<strong>等待队列的尾部</strong>，并标记为<strong>独占模式</strong>。</li>
<li>acquireQueued() 使线程在<strong>等待队列中休息</strong>，有机会时（轮到自己，会被 unpark()）会去<strong>尝试获取资源</strong>。获取到资源后才返回。如果在整个等待过程中被中断过，则返回 true，否则返回 false。</li>
<li>如果线程在等待过程中<strong>被中断过</strong>，它是不响应的。只是获取资源后才再进行自我中断 selfInterrupt()，将中断补上。</li>
</ol>
<p>由于此函数是重中之重，再用流程图总结一下：</p>
<p><img src="assets/image-20200509173912812.png" alt="image-20200509173912812"></p>
<p>至此，acquire() 的流程终于算是告一段落了。这也就是 ReentrantLock.lock() 的<strong>流程</strong>，不信你去看其 lock() 源码吧，整个函数就是一条 <strong>acquire</strong>(1)！！！</p>
<h5 id="2-独占式释放同步状态release"><a href="#2-独占式释放同步状态release" class="headerlink" title="2. 独占式释放同步状态release()"></a>2. 独占式释放同步状态release()</h5><p>上一小节已经把 acquire() 说完了，这一小节就来讲讲它的<strong>反操作 release()</strong>吧。此方法是<strong>独占模式</strong>下线程<strong>释放共享资源</strong>的顶层入口。它会释放指定量的资源，如果彻底释放了（即 state = 0）,它会<strong>唤醒等待队列里的其他线程来获取资源</strong>。这也正是 <strong>unlock() 的语义</strong>，当然不<strong>仅仅只限于 unlock()</strong>。下面是 release() 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 找到头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒等待队列里的下一个线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑并不复杂。它调用 <strong>tryRelease</strong>() 来<strong>释放资源</strong>。有一点需要注意的是，<strong>它是根据 tryRelease() 的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计 tryRelease() 的时候要明确这一点！！</strong></p>
<h6 id="1-tryRelease-int"><a href="#1-tryRelease-int" class="headerlink" title="(1) tryRelease(int)"></a>(1) tryRelease(int)</h6><p>此方法<strong>尝试去释放指定量的资源</strong>。下面是 tryRelease() 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟 <strong>tryAcquire</strong>() 一样，这个方法是需要<strong>独占模式</strong>的<strong>自定义同步器</strong>去实现的。正常来说，tryRelease() 都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接<strong>减掉</strong>相应量的资源即可(state -= arg)，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，<strong>release() 是根据 tryRelease() 的返回值来判断该线程是否已经完成释放掉资源了！</strong>所以自义定同步器在实现时，如果已经彻底释放资源(state = 0)，要返回 true，否则返回 false。</p>
<h6 id="2-unparkSuccessor-Node"><a href="#2-unparkSuccessor-Node" class="headerlink" title="(2) unparkSuccessor(Node)"></a>(2) unparkSuccessor(Node)</h6><p>此方法用于唤醒等待队列中下一个线程。下面是源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里，node一般为当前线程所在的结点</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">// 置零当前线程所在的结点状态，允许失败</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;<span class="comment">// 找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">// 如果为空或已取消</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev) <span class="comment">// 从后向前找。</span></span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">// 从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">// 唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数并不复杂。一句话概括：<strong>用 unpark() 唤醒等待队列中最前边的那个未放弃线程</strong>，这里也用 s 来表示吧。此时，再和 acquireQueued() 联系起来，s 被唤醒后，进入 if (p == head &amp;&amp; tryAcquire(arg)) 的判断（即使 p != head 也没关系，它会再进入 shouldParkAfterFailedAcquire() 寻找一个<strong>安全点</strong>。这里既然 s 已经是等待队列中最前边的那个未放弃线程了，那么通过 shouldParkAfterFailedAcquire() 的调整，s 也必然会跑到 head 的 next 结点，下一次自旋 p == head 就成立啦），然后 s 把自己设置成 head 标杆结点，表示自己已经获取到资源了，acquire() 也返回了！！And then, DO what you WANT!</p>
<p>release() 是<strong>独占模式下线程释放共享资源</strong>的顶层入口。它会释放指定量的资源，如果彻底释放了（即 state = 0）,它会唤醒等待队列里的其他线程来获取资源。</p>
<h5 id="3-共享式获取同步状态acquireShared-int"><a href="#3-共享式获取同步状态acquireShared-int" class="headerlink" title="3. 共享式获取同步状态acquireShared(int)"></a>3. 共享式获取同步状态acquireShared(int)</h5><p>共享式：共享式地获取同步状态。对于独占式同步组件来讲，同一时刻只有一个线程能获取到同步状态，其他线程都得去排队等待，其待重写的尝试获取同步状态的方法 tryAcquire 返回值为 <strong>boolean</strong>，这很容易理解；对于<strong>共享式</strong>同步组件来讲，同一时刻可以有<strong>多个线程同时获取到</strong>同步状态，这也是“共享”的意义所在。其待重写的尝试获取同步状态的方法 tryAcquireShared 返回值为 <strong>int</strong>。</p>
<p>此方法是<strong>共享模式</strong>下线程获取<strong>共享资源</strong>的顶层入口。它会获取<strong>指定量</strong>的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是 acquireShared() 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 tryAcquireShared() 依然需要<strong>自定义同步器</strong>去实现。但是 AQS 已经把其<strong>返回值的语义</strong>定义好了：</p>
<ul>
<li><p>1.当返回值<strong>大于 0</strong> 时，表示获取<strong>同步状态成功</strong>，同时<strong>还有剩余同步状态</strong>可供其他线程获取；</p>
</li>
<li><p>2.当返回值<strong>等于 0</strong> 时，表示获取<strong>同步状态成功</strong>，但<strong>没有可用同步状态</strong>了；</p>
</li>
<li><p>3.当返回值<strong>小于 0</strong> 时，表示获取<strong>同步状态失败</strong>。</p>
</li>
</ul>
<p>所以这里 acquireShared() 的流程就是：</p>
<ul>
<li><strong>tryAcquireShared</strong>() 尝试获取资源，成功则直接返回；</li>
<li>失败则通过 doAcquireShared() 进入<strong>等待队列</strong>，<strong>直到</strong>获取到资源为止才返回。</li>
</ul>
<h6 id="1-doAcquireShared-int"><a href="#1-doAcquireShared-int" class="headerlink" title="(1) doAcquireShared(int)"></a>(1) doAcquireShared(int)</h6><p>此方法用于将当前线程加入<strong>等待队列尾部</strong>休息，直到其他线程释放资源唤醒自己，自己成功拿到相应量的资源后才返回。下面是 doAcquireShared() 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">// 加入队列尾部</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">// 是否成功标志</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">// 等待过程中是否被中断过的标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">// 前驱</span></span><br><span class="line">            <span class="comment">// 如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">// 尝试获取资源</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">// 成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);<span class="comment">// 将head指向自己，还有剩余资源可以再唤醒之后的线程</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)<span class="comment">// 如果等待过程中被打断过，此时将中断补上。</span></span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有木有觉得跟 acquireQueued() 很<strong>相似</strong>？对，其实流程并没有太大区别。只不过这里将补中断的 selfInterrupt() 放到 doAcquireShared() 里了，而独占模式是放到 acquireQueued() 之外。</p>
<p>跟独占模式比，还有一点需要注意的是，这里只有线程是 <strong>head.next</strong> 时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了 5 个资源，而老二需要 6 个，老三需要 1 个，老四需要 2 个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续 <strong>park</strong>() 等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但<strong>共享模式下，多个线程是可以同时执行</strong>的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是 AQS 保证严格按照<strong>入队顺序唤醒</strong>罢了（保证公平，但降低了并发）。</p>
<h6 id="2-setHeadAndPropagate-Node-int"><a href="#2-setHeadAndPropagate-Node-int" class="headerlink" title="(2) setHeadAndPropagate(Node, int)"></a>(2) setHeadAndPropagate(Node, int)</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; </span><br><span class="line">    setHead(node);<span class="comment">// head指向自己</span></span><br><span class="line">     <span class="comment">// 如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法在 setHead() 的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去<strong>唤醒后继结点</strong>，毕竟是共享模式！</p>
<p>doReleaseShared() 留着下一小节的 releaseShared() 里来讲。</p>
<p>OK，至此，acquireShared() 也要告一段落了。让我们再梳理一下它的流程：</p>
<ul>
<li><strong>tryAcquireShared</strong>() 尝试获取资源，成功则直接返回；</li>
<li>失败则通过 <strong>doAcquireShared</strong>() 进入<strong>等待队列 park()</strong>，直到被 unpark()/interrupt() 并成功获取到资源才返回。整个等待过程也是<strong>忽略中断</strong>的。</li>
</ul>
<p>其实跟 <strong>acquire</strong>() 的流程大同小异，只不过多了个<strong>自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）</strong>。</p>
<h5 id="4-共享式释放同步状态releaseShared"><a href="#4-共享式释放同步状态releaseShared" class="headerlink" title="4. 共享式释放同步状态releaseShared()"></a>4. 共享式释放同步状态releaseShared()</h5><p>上一小节已经把 acquireShared() 说完了，这一小节就来讲讲它的<strong>反操作 releaseShared()</strong> 吧。此方法是<strong>共享模式下线程释放共享资源</strong>的顶层入口。它会释放指定量的资源，如果成功释放且允许唤醒等待线程，它会唤醒等待队列里的其他线程来获取资源。下面是 releaseShared() 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">// 尝试释放资源</span></span><br><span class="line">        doReleaseShared();<span class="comment">// 唤醒后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的 <strong>release</strong>() 相似，但有一点稍微需要注意：独占模式下的 tryRelease() 在完全释放掉资源（state = 0）后，才会返回 true 去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的 releaseShared() 则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是 13，A（5）和 B（7）分别获取到资源并发运行，C（4）来时只剩 1 个资源就需要等待。A 在运行过程中释放掉 2 个资源量，然后 tryReleaseShared(2) 返回 true 唤醒C，C 一看只有 3 个仍不够继续等待；随后 B 又释放 2 个，tryReleaseShared(2) 返回 true 唤醒 C，C 一看有 5 个够自己用了，然后 C 就可以跟 A 和 B 一起运行。而 ReentrantReadWriteLock 读锁的 tryReleaseShared() 只有在完全释放掉资源（state = 0）才返回 true，所以自定义同步器可以根据需要决定 tryReleaseShared() 的返回值。</p>
<h6 id="1-doReleaseShared"><a href="#1-doReleaseShared" class="headerlink" title="(1) doReleaseShared()"></a>(1) doReleaseShared()</h6><p>此方法主要用于唤醒后继。下面是它的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);<span class="comment">// 唤醒后继</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)<span class="comment">// head发生变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本节我们详解了<strong>独占和共享</strong>两种模式下获取-释放资源(acquire-release、acquireShared-releaseShared)的源码，相信大家都有一定认识了。值得注意的是，acquire() 和 acquireShared() 两种方法下，<strong>线程在等待队列中都是忽略中断</strong>的。AQS 也<strong>支持响应中断</strong>的，<strong>acquireInterruptibly()/acquireSharedInterruptibly()</strong> 即是，相应的源码跟 acquire() 和 acquireShared() 差不多，这里就不再详解了。</p>
<h4 id="AQS与模板方法模式"><a href="#AQS与模板方法模式" class="headerlink" title="AQS与模板方法模式"></a>AQS与模板方法模式</h4><p>AQS 同步器的设计是<strong>基于模板方法模式</strong>的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者<strong>继承 AbstractQueuedSynchronizer</strong> 并覆写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）。</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其<strong>模板方法</strong>，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p><strong>AQS 使用了模板方法模式，自定义同步器时需要覆写下面几个 AQS 提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 独占式获取同步状态，试着获取，成功返回true，反之为false</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="comment">// 独占式释放同步状态，等待中的其他线程此时将有机会获取到同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="comment">// 共享式获取同步状态，返回值大于等于0，代表获取成功；反之获取失败</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="comment">// 共享式释放同步状态，成功为true，失败为false</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"><span class="comment">// 是否在独占模式下被线程占用</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用方式</strong></p>
</blockquote>
<p>首先需要继承 <strong>AbstractQueuedSynchronizer</strong> 这个类，然后根据需求去<strong>重写</strong>相应的方法，比如要实现一个<strong>独占锁</strong>，那就去重写 <strong>tryAcquire</strong>，<strong>tryRelease</strong> 方法，要实现<strong>共享锁</strong>，就去重写 <strong>tryAcquireShared</strong>，<strong>tryReleaseShared</strong>；最后，在组件中<strong>调用 AQS 中的模板方法</strong>就可以了，而这些模板方法是<strong>会调用到之前重写的那些方法</strong>的。也就是说只需要很小的工作量就可以实现自己的<strong>同步组件</strong>，重写的那些方法，仅仅是一些简单的对于共享资源 <strong>state 的获取和释放操作</strong>，至于像是获取资源失败，线程需要阻塞之类的操作，自然是 AQS 自己完成了。</p>
<p>默认情况下，每个方法都抛出 <strong>UnsupportedOperationException</strong>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的<strong>其他方法都是 final</strong> ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以 ReentrantLock 为例，state 初始化为0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock() 到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>
<p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 state=0)，会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>
<ul>
<li><a href="http://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920797.html</a></li>
<li><a href="https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html" target="_blank" rel="noopener">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html</a></li>
</ul>
<h4 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h4><h5 id="1-自定义同步器Mutex-互斥锁"><a href="#1-自定义同步器Mutex-互斥锁" class="headerlink" title="1. 自定义同步器Mutex(互斥锁)"></a>1. 自定义同步器Mutex(互斥锁)</h5><p>下面就以 AQS 源码里的 Mutex 为例，讲一下 AQS 的简单应用。直接采用 JDK 官方文档中的小例子来说明问题。</p>
<p>Mutex 是一个<strong>不可重入的互斥锁</strong>实现。锁资源（AQS 里的 state）只有<strong>两种状态</strong>：<strong>0 表示未锁定，1 表示锁定</strong>。下边是 Mutex 的核心源码：</p>
<p>这里自定义同步器继承了 AQS，然后覆写了 AQS 的 <strong>isHeldExclusively 方法、tryAcquire 方法和 tryRelease 方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义同步器继承AQS类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">// 既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);	<span class="comment">// 释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面是实现控制逻辑的自定义方法</span></span><br><span class="line">    <span class="comment">// 真正同步类的实现都依赖继承于AQS的自定义同步器！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// unlock&lt;--&gt;release。两者语文一样：释放资源。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁是否占有状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步类在实现时一般都将<strong>自定义同步器（sync）定义为内部类</strong>，供自己使用；而同步类自己（Mutex）则<strong>实现某个接口</strong>，对外服务。当然，接口的实现要直接依赖 sync，它们在语义上也存在某种对应关系！！而 <strong>sync 只用实现资源 state 的获取-释放方式 tryAcquire-tryRelelase</strong>，至于线程的排队、等待、唤醒等，上层的 AQS 都已经实现好了。</p>
<p>除了 Mutex，ReentrantLock/CountDownLatch/Semphore 这些同步类的实现方式都差不多，不同的地方就在<strong>获取-释放资源的方式 tryAcquire-tryRelelase</strong>。掌握了这点，AQS 的核心便被攻破了！</p>
<p>测试下这个自定义的同步器，使用并发环境下 a++ 的例子来说明问题（a++ 的原子性其实最好使用原子类 AtomicInteger 来解决，此处用 Mutex 有点大炮打蚊子的意味，好在能说明问题就好）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMutex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">31</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  Mutex mutex = <span class="keyword">new</span> Mutex();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 说明:我们启用30个线程，每个线程对i自加10000次，同步正常的话，最终结果应为300000；</span></span><br><span class="line">        <span class="comment">// 未加锁前</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>;i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">                        increment1();<span class="comment">// 没有同步措施的a++；</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        barrier.await();<span class="comment">// 等30个线程累加完毕</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">        barrier.await();</span><br><span class="line">        System.out.println(<span class="string">"加锁前，a="</span> + a);</span><br><span class="line">        <span class="comment">// 加锁后</span></span><br><span class="line">        barrier.reset();<span class="comment">// 重置CyclicBarrier</span></span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">                        <span class="comment">// a++采用Mutex进行同步处理</span></span><br><span class="line">                        increment2();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        barrier.await();<span class="comment">// 等30个线程累加完毕</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        barrier.await();</span><br><span class="line">        System.out.println(<span class="string">"加锁后，a="</span>+a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有同步措施的a++</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用自定义的Mutex进行同步处理的a++</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mutex.lock();</span><br><span class="line">        a++;</span><br><span class="line">        mutex.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">加锁前，a=<span class="number">279204</span></span><br><span class="line">加锁后，a=<span class="number">300000</span></span><br></pre></td></tr></table></figure>





<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><a href="https://www.cnblogs.com/waterystone/p/4920797.html" target="_blank" rel="noopener">AQS源码高质量分析（牛皮）</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/C-4%20%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/" rel="next" title="ShiftJava/A Java/C-4 线程安全总结">
                <i class="fa fa-chevron-left"></i> ShiftJava/A Java/C-4 线程安全总结
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/C-2%20JMM%E4%B8%8EVolatile/" rel="prev" title="ShiftJava/A Java/C-2 JMM与Volatile">
                ShiftJava/A Java/C-2 JMM与Volatile <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC与AQS"><span class="nav-number">1.</span> <span class="nav-text">JUC与AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 概述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS框架概览"><span class="nav-number">1.2.</span> <span class="nav-text">AQS框架概览</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Node结点"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. Node结点</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-基本属性"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">(1) 基本属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-结点状态waitStatus"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">(2) 结点状态waitStatus</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-框架核心组件"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 框架核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-state状态量"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">(1) state状态量</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-CLH队列"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">(2) CLH队列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-条件等待队列"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">(3) 条件等待队列</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-资源共享方式"><span class="nav-number">1.2.3.</span> <span class="nav-text">3. 资源共享方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#同步源码分析"><span class="nav-number">1.3.</span> <span class="nav-text">同步源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-独占式获取同步状态acquire-int"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 独占式获取同步状态acquire(int)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-tryAcquire"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">(1) tryAcquire()</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-addWaiter-Node"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">(2) addWaiter(Node)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-acquireQueued-Node-int"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">(3) acquireQueued(Node, int)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-独占式释放同步状态release"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 独占式释放同步状态release()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-tryRelease-int"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">(1) tryRelease(int)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-unparkSuccessor-Node"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">(2) unparkSuccessor(Node)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-共享式获取同步状态acquireShared-int"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 共享式获取同步状态acquireShared(int)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-doAcquireShared-int"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">(1) doAcquireShared(int)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-setHeadAndPropagate-Node-int"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">(2) setHeadAndPropagate(Node, int)</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-共享式释放同步状态releaseShared"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 共享式释放同步状态releaseShared()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-doReleaseShared"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">(1) doReleaseShared()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AQS与模板方法模式"><span class="nav-number">1.4.</span> <span class="nav-text">AQS与模板方法模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用实例"><span class="nav-number">1.5.</span> <span class="nav-text">应用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-自定义同步器Mutex-互斥锁"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. 自定义同步器Mutex(互斥锁)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.6.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
