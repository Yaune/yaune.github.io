<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] 基本数据结构结构与存储1. 线性结构与非线性结构(1) 线性结构线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。 线性结构见的有：组队列、链表和">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;B 数据结构与算法&#x2F;B 基础数据结构">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] 基本数据结构结构与存储1. 线性结构与非线性结构(1) 线性结构线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。线性结构有两种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。 线性结构见的有：组队列、链表和">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;1565000508963-1569397664724.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;1565001222410-1569397664724.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191216214220866.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191216214444081.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191216214610372.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191216215559974.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;1565089271980-1569397664725.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217125925596.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217130931332.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217131311652.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217131733305.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217144730730.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217144808583.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217145131381.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217153931658.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217154220360.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217154744257.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217155148065.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191217155629685.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;1563523769927.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;0dbc4f7d-05c9-4aae-8065-7b7ea7e9709e.gif">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191219123741643.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191219123802820.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191219123844301.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191219123934771.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191219133042581.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191219133111364.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191219133300378.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191219133315335.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191219133330143.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;image-20191219133347962.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95&#x2F;B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#x2F;assets&#x2F;1565000508963-1569397664724.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/B 数据结构与算法/B 基础数据结构/"/>





  <title>ShiftJava/B 数据结构与算法/B 基础数据结构 | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/B%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/B 数据结构与算法/B 基础数据结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:14+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><h4 id="结构与存储"><a href="#结构与存储" class="headerlink" title="结构与存储"></a>结构与存储</h4><h5 id="1-线性结构与非线性结构"><a href="#1-线性结构与非线性结构" class="headerlink" title="1. 线性结构与非线性结构"></a>1. 线性结构与非线性结构</h5><h6 id="1-线性结构"><a href="#1-线性结构" class="headerlink" title="(1) 线性结构"></a>(1) 线性结构</h6><p>线性结构作为最常用的数据结构，其特点是数据元素之间存在<strong>一对一</strong>的线性关系。线性结构有两种不同的存储结构，即<strong>顺序存储结构和链式存储结构</strong>。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息。</p>
<p>线性结构见的有：<strong>组队列、链表和栈</strong>。</p>
<h6 id="2-非线性结构"><a href="#2-非线性结构" class="headerlink" title="(2) 非线性结构"></a>(2) 非线性结构</h6><p>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构。</p>
<h5 id="2-存储方式的分析"><a href="#2-存储方式的分析" class="headerlink" title="2. 存储方式的分析"></a>2. 存储方式的分析</h5><h6 id="1-数组存储"><a href="#1-数组存储" class="headerlink" title="(1) 数组存储"></a>(1) 数组存储</h6><p>优点：通过下标方式访问元素，速度快。<strong>对于有序数组</strong>，还可使用二分查找提高检索速度。<br>缺点：如果要检索具体某个值，或者插入值(按一定顺序)<strong>会整体移动</strong>，效率较低。可能还涉及到数组扩容，这中间的数据复制开销较大。</p>
<h6 id="2-链式存储"><a href="#2-链式存储" class="headerlink" title="(2) 链式存储"></a>(2) 链式存储</h6><p>优点：在一定程度上对数组存储方式有优化 (比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，<br>删除效率也很好)。</p>
<p>缺点：在进行检索查找时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) 。</p>
<h6 id="3-树存储"><a href="#3-树存储" class="headerlink" title="(3) 树存储"></a>(3) 树存储</h6><p>能提高数据<strong>存储，读取</strong>的效率,  比如利用 <strong>二叉排序树</strong>(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><h5 id="1-稀疏数组"><a href="#1-稀疏数组" class="headerlink" title="1. 稀疏数组"></a>1. 稀疏数组</h5><p>应用场景：记录一个<strong>棋盘</strong>。或者<strong>地图</strong>等，如下所示。</p>
<img src="assets/1565000508963-1569397664724.png" alt="1565000508963" style="zoom:67%;" />

<p>因为该二维数组的很多值是<strong>默认值 0</strong>, 因此记录了很多没有意义的数据，考虑使用稀疏数组。</p>
<p>当一个数组中<strong>大部分元素为０</strong>，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p>
<p>稀疏数组的处理方法是:</p>
<ul>
<li>记录数组一共有<strong>几行几列</strong>，有多少个<strong>不同的值</strong>；</li>
<li>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模。</li>
<li>行不确定，但是列是三列的动态数组。</li>
</ul>
<p><strong>转化举例</strong></p>
<img src="assets/1565001222410-1569397664724.png" alt="1565001222410" style="zoom:60%;" />

<p>上述数组 0 较多，使用稀疏数组表示，该数组第 0 个元素记录原始数组的行数、列数和有效数据数。后面的值就是记录有效的位置和数据值。</p>
<h4 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p><strong>线性表</strong>存储方式分为<strong>==顺序存储和链式存储==</strong>。顺序存储使用数组进行存储。链式存储使用链表进行存储。</p>
<p>对比表格如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">顺序表</th>
<th align="center">链式表</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>存储方式</strong></td>
<td align="center"><strong>数组</strong></td>
<td align="center"><strong>链表</strong></td>
</tr>
<tr>
<td align="center"><strong>地址连续性</strong></td>
<td align="center">内存地址<strong>连续</strong>存储</td>
<td align="center">节点的地址不是连续的，是通过<strong>指针</strong>连起来的</td>
</tr>
<tr>
<td align="center"><strong>查找</strong></td>
<td align="center">方便。直接内存寻址</td>
<td align="center">不方便。需要遍历链表</td>
</tr>
<tr>
<td align="center"><strong>插入</strong></td>
<td align="center">不方便。后面的元素需要整体后移</td>
<td align="center">方便。修改指针即可</td>
</tr>
<tr>
<td align="center"><strong>删除</strong></td>
<td align="center">不方便。后面的元素需要整体前移</td>
<td align="center">方便。修改指针即可</td>
</tr>
</tbody></table>
<p><strong>使用</strong>：当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，用顺序存储结构效率会高很多。</p>
<h5 id="2-数组实现线性表"><a href="#2-数组实现线性表" class="headerlink" title="2. 数组实现线性表"></a>2. 数组实现线性表</h5><p>元素的存储空间是<strong>连续</strong>的。在内存中是以顺序存储，内存划分的<strong>区域是连续</strong>的。如下图。</p>
<img src="assets/image-20191216214220866.png" alt="image-20191216214220866" style="zoom:67%;" />

<p><strong>插入元素</strong>：在<strong>指定的位置</strong>添加元素时，需要把<strong>后面的元素整体移动</strong>，效率不高。位置编号越大， 插入时所需要移动的元素越少，时间越快。当加入的元素<strong>超过容量之后也需要扩展数组</strong>，并把原来的数组内容进行<strong>复制</strong>，这里也是效率不高。如插入 11 需要将 10 和 2 整体后移再插入。</p>
<img src="assets/image-20191216214444081.png" alt="image-20191216214444081" style="zoom:60%;" />

<p><strong>删除元素</strong>：删除指定位置的元素之后，也需要把后面的元素<strong>整体往前移动补空位</strong>。如下图删除 3 之后，需要把后面的数据整体前移。</p>
<img src="assets/image-20191216214610372.png" alt="image-20191216214610372" style="zoom:60%;" />

<p><strong>缺点</strong>就是<strong>添、删</strong>的时候比较麻烦，特别是添和改的时候要<strong>移动数组</strong>，数组容易越界。可能出现数组存储满的情况，需要进行<strong>扩容并复制</strong>。</p>
<h5 id="3-单向链表"><a href="#3-单向链表" class="headerlink" title="3. 单向链表"></a>3. 单向链表</h5><p>元素在内存中<strong>不一定</strong>是连续存储的。如下图所示。</p>
<img src="assets/image-20191216215559974.png" alt="image-20191216215559974" style="zoom:57%;" />

<p>链表是以<strong>结点</strong>方式来存储数据，每个结点包含 <strong>data 域， next 域</strong>，用于指向下一个结点。链表中的节点不一定是连续存储的。如上图头结点指针 head 指向 150 地址的 a1 元素。</p>
<h5 id="4-双向链表"><a href="#4-双向链表" class="headerlink" title="4. 双向链表"></a>4. 双向链表</h5><p>单向链表<strong>查找的方向只能是一个方向</strong>，而双向链表可以向前或者向后查找。单向链表<strong>不能自我删除</strong>，需要靠<strong>辅助节点</strong> ，而双向链表，则可以<strong>自我删除</strong>，所以前面我们单链表删除节点时，总是需要先找到 temp, temp 是待删除节点的前一个节点。双向链表维护了一个 next 指向下一个结点，维护了一个 pre 指向上一个结点。因此添加删除操作等需要<strong>同时操作 next 和 pre</strong> ，不要遗忘了。</p>
<img src="assets/1565089271980-1569397664725.png" alt="1565089271980" style="zoom:67%;" />

<h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><h5 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h5><ul>
<li>栈的操作端通常被称为<strong>栈顶</strong>，另一端被称为<strong>栈底</strong>。所有添加都位于<strong>栈顶</strong>。栈顶是最新的数据。删除也是先删除栈顶。<strong>后进先出</strong>（LIFO）结构。</li>
<li>基本操作：<strong>入栈</strong>（push）：增加元素；<strong>出栈</strong>（pop）：删除元素；<strong>查看</strong>（peak）：获取栈顶但不删除。</li>
<li>顺序存储的栈称为<strong>顺序栈</strong>；链式存储的栈称为<strong>链式栈</strong>。</li>
<li>栈的常见应用：十进制转 N 进制、行编辑器、校验括号是否匹配、中缀表达式转后缀表达式、表达式求值等。</li>
</ul>
<p>栈的抽象接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">MyStack&lt;Item&gt; <span class="title">push</span><span class="params">(Item item)</span></span>;</span><br><span class="line">    <span class="function">Item <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-栈的实现"><a href="#2-栈的实现" class="headerlink" title="2. 栈的实现"></a>2. 栈的实现</h5><h6 id="1-栈的数组实现"><a href="#1-栈的数组实现" class="headerlink" title="(1) 栈的数组实现"></a>(1) 栈的数组实现</h6><p>使用可变大小数组实现栈，容量不够时可以自动<strong>扩容</strong>。使用数组实现栈则数组的第一个位置是<strong>栈底</strong>，数组<strong>最后占用</strong>的位置才指向<strong>栈顶</strong>，否则压栈会整体<strong>移动</strong>元素位置。</p>
<img src="assets/image-20191217125925596.png" alt="image-20191217125925596" style="zoom:42%;" />

<p>弹栈操作可以将所有的元素依次弹栈即可。可以看看 <strong>ArrayDeque</strong> 的源码。这里给个demo。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">MyStack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 栈元素数组，只能通过转型来创建泛型数组</span></span><br><span class="line">    <span class="keyword">private</span> Item[] a = (Item[]) <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyStack&lt;Item&gt; <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line">        check();</span><br><span class="line">        a[N++] = item;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Item item = a[--N];</span><br><span class="line">        check();</span><br><span class="line">        <span class="comment">// 避免对象游离</span></span><br><span class="line">        a[N] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (N &gt;= a.length) &#123;</span><br><span class="line">            resize(<span class="number">2</span> * a.length);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (N &gt; <span class="number">0</span> &amp;&amp; N &lt;= a.length / <span class="number">4</span>) &#123;</span><br><span class="line">            resize(a.length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调整数组大小，使得栈具有伸缩性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        Item[] tmp = (Item[]) <span class="keyword">new</span> Object[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            tmp[i] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        a = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回逆序遍历的迭代器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Item&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> i = N;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[--i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-栈的链式实现"><a href="#2-栈的链式实现" class="headerlink" title="(2) 栈的链式实现"></a>(2) 栈的链式实现</h6><p>需要使用链表的<strong>头插法或尾插法</strong>来实现，因为<strong>头插法</strong>中最后压入栈的元素在<strong>链表的开头</strong>，它的 next 指针指向前一个压入栈的元素，在弹出元素时就可以通过 <strong>next</strong> 指针遍历到前一个压入栈的元素从而让这个元素成为新的栈顶元素。</p>
<p>使用单链表实现栈，则<strong>首节点</strong>应该指向<strong>栈顶</strong>元素。</p>
<img src="assets/image-20191217130931332.png" alt="image-20191217130931332" style="zoom:42%;" />

<p>==<strong>压栈</strong>==操作就是分配一个新结点，使之指向目前的栈链，如下图所示。</p>
<img src="assets/image-20191217131311652.png" alt="image-20191217131311652" style="zoom:39%;" />

<p>a) 构造<strong>新结点</strong>并指向栈顶结点；</p>
<p>b) 头指针指向<strong>栈顶新节点</strong>。</p>
<p><strong>==弹栈==</strong>操作就是将<strong>首节点的引用赋给 topNode</strong>，从而出栈。故将 topNode 指向链中的第二个结点。如下图所示。</p>
<p><img src="assets/image-20191217131733305.png" alt="image-20191217131733305"></p>
<p>可以参考 LinkedList 的源码实现。</p>
<p>单链表一般使用头插法，而双链表则头插法和尾插法都可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListStack</span>&lt;<span class="title">Item</span>&gt; <span class="keyword">implements</span> <span class="title">MyStack</span>&lt;<span class="title">Item</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node top = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Item item;</span><br><span class="line">        Node next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyStack&lt;Item&gt; <span class="title">push</span><span class="params">(Item item)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Node newTop = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">        newTop.item = item;</span><br><span class="line">        newTop.next = top;</span><br><span class="line"></span><br><span class="line">        top = newTop;</span><br><span class="line"></span><br><span class="line">        N++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Item <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"stack is empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Item item = top.item;</span><br><span class="line"></span><br><span class="line">        top = top.next;</span><br><span class="line">        N--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;Item&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;Item&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> Node cur = top;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cur != <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Item <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Item item = cur.item;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-栈的向量Vector类实现"><a href="#3-栈的向量Vector类实现" class="headerlink" title="(3) 栈的向量Vector类实现"></a>(3) 栈的向量Vector类实现</h6><p>Java 类库 <strong>Vector 类</strong>，其实例（称为向量）的行为类似于一个可变大小的<strong>数组</strong>。可用于构造栈。Vector 类的实现基于<strong>==动态可变大小的数组==</strong>，但是其内部已经实现了许多方法，可以轻松实现栈结构。</p>
<p>如果使用向量实现栈，则向量的<strong>首元素</strong>应该指向<strong>栈底元素</strong>。而向量的最后的占用位置指向栈顶元素。</p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><h5 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h5><ul>
<li>先进先出 <strong>FIFO</strong> 结构。添加元素在<strong>后端</strong>，出队列在<strong>前端</strong>。</li>
</ul>
<h5 id="2-队列的实现"><a href="#2-队列的实现" class="headerlink" title="2. 队列的实现"></a>2. 队列的实现</h5><h6 id="1-队列的数组实现"><a href="#1-队列的数组实现" class="headerlink" title="(1) 队列的数组实现"></a>(1) 队列的数组实现</h6><p>使用<strong>数组</strong>来存放队列，维护一个 <strong>frontIndex</strong> 和 <strong>backIndex</strong> 来指示<strong>队头队尾</strong>。</p>
<p>使用==<strong>带一个不用位置的循环数组</strong>==来实现队列。即该数组中始终有一个位置<strong>空缺</strong>， 可以将其放在<strong>队尾</strong>。此时判断队列的<strong>空与满有不同的条件</strong>。所以存储对象的数组应比设定的大小<strong>多 1</strong>。</p>
<p>下图是队列<strong>满与空</strong>流程图。</p>
<img src="assets/image-20191217144730730.png" alt="image-20191217144730730" style="zoom:33%;" />

<img src="assets/image-20191217144808583.png" alt="image-20191217144808583" style="zoom:35%;" />

<p>队列<strong>满</strong>时：（公式源自《数据结构与抽象 Java 版》）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">frontIndex == (backIndex + <span class="number">2</span>) % queue.length</span><br><span class="line"><span class="number">6</span> == (<span class="number">4</span> + <span class="number">2</span>)% <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>队列<strong>空</strong>时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frontIndex == (backIndex + <span class="number">1</span>) % queue.length</span><br></pre></td></tr></table></figure>

<p><strong>入队</strong>即在<strong>队列后端</strong>添加元素，数组是<strong>循环</strong>的，需要使用 <strong>==%==</strong> 来确定索引位置。</p>
<p><strong>出队</strong>过程即把 frontIndex 指向<strong>下一个</strong>元素。</p>
<p><strong>数组扩容</strong>：容量不足实现<strong>扩容</strong>时，与之前的数组扩容有所差距如下图。将原来的循环队列<strong>全都复制到新队列的开始</strong>处。</p>
<img src="assets/image-20191217145131381.png" alt="image-20191217145131381" style="zoom:40%;" />

<h6 id="2-队列的链式实现"><a href="#2-队列的链式实现" class="headerlink" title="(2) 队列的链式实现"></a>(2) 队列的链式实现</h6><p>队列的两端在<strong>链的两端</strong>。队列的<strong>前端</strong>放在链的<strong>开头</strong>，队列的<strong>后端</strong>放在链的<strong>链尾</strong>。<strong>firstNode</strong> 指向队列前端，<strong>lastNode</strong> 指向队列后端，如下图所示。当队列为<strong>空</strong>时两个<strong>都为 null</strong>。</p>
<img src="assets/image-20191217153931658.png" alt="image-20191217153931658" style="zoom:40%;" />

<p><strong>入队</strong>是添加新结点到后端，需要判断链是否为<strong>空</strong>！如果是空链，则添加元素之后如下，即 firstNode 和 lastNode 均指向新结点。</p>
<img src="assets/image-20191217154220360.png" alt="image-20191217154220360" style="zoom:40%;" />

<p>如果是一般结点<strong>入队</strong>，则链中最后一个结点和 lastNode 指向新结点，如下。</p>
<ul>
<li><strong>最后一个结点</strong>指向新结点；</li>
<li><strong>lastNode</strong> 指向新结点。</li>
</ul>
<img src="assets/image-20191217154744257.png" alt="image-20191217154744257" style="zoom:40%;" />

<p>如果有多个结点，<strong>出队</strong>将 firstNode 指向链的第二个结点。如果队列中<strong>仅有一个节点</strong>，则出队之后为空。如下所示。</p>
<img src="assets/image-20191217155148065.png" alt="image-20191217155148065" style="zoom:40%;" />

<h6 id="3-队列的循环链式实现"><a href="#3-队列的循环链式实现" class="headerlink" title="(3) 队列的循环链式实现"></a>(3) 队列的循环链式实现</h6><p>循环链中最后一个结点指向<strong>第一个</strong>结点。每个结点的 <strong>nextNode</strong> 域<strong>不会为 null</strong>。如下图有指向最后结点的外部引用的循环链。</p>
<img src="assets/image-20191217155629685.png" alt="image-20191217155629685" style="zoom:40%;" />

<p>只需要<strong>一个 lastNode</strong> 数据域即可，它属于<strong>链尾</strong>，使用 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lastNode.getNextNode();</span><br></pre></td></tr></table></figure>

<p> 就可以获取到<strong>链头</strong>。</p>
<h5 id="3-双端队列（deque）"><a href="#3-双端队列（deque）" class="headerlink" title="3. 双端队列（deque）"></a>3. 双端队列（deque）</h5><p>能在队列的<strong>前端和后端</strong>进行添加、删除与获取操作。行为上类似于<strong>双端栈</strong>。</p>
<h5 id="4-优先级队列（Priority-Queue）"><a href="#4-优先级队列（Priority-Queue）" class="headerlink" title="4. 优先级队列（Priority Queue）"></a>4. 优先级队列（Priority Queue）</h5><p>根据<strong>优先级</strong>组织队列中的对象。对象优先级通过 <strong>compareTo()</strong> 方法确定。需要按项的优先级对项进行排序。Java中有对应的类库：<strong>PriorityQueue</strong> 类。重点是<strong>堆</strong>实现。</p>
<h5 id="5-Java队列实现"><a href="#5-Java队列实现" class="headerlink" title="5. Java队列实现"></a>5. Java队列实现</h5><h6 id="1-Queue接口"><a href="#1-Queue接口" class="headerlink" title="(1) Queue接口"></a>(1) Queue接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将元素插入队列</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">// 将元素插入队列，与add相比，在容量受限时应该使用这个</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line"><span class="comment">// 将队首的元素删除，队列为空则抛出异常</span></span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 将队首的元素删除，队列为空则返回null</span></span><br><span class="line"><span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取队首元素，但不移除，队列为空则抛出异常</span></span><br><span class="line"><span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取队首元素，但不移除，队列为空则返回null</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>入队、出队和取值两个一组，一个<strong>抛出异常，一个返回 null</strong>。</p>
<h6 id="2-Deque接口"><a href="#2-Deque接口" class="headerlink" title="(2) Deque接口"></a>(2) Deque接口</h6><p>继承于 Queue 接口。两种方法<strong>成对</strong>，出现问题时一个出现<strong>异常</strong>一个返回 <strong>NULL</strong>。</p>
<table>
<thead>
<tr>
<th align="center">操作类型</th>
<th align="center">第一个元素（Deque实例的开头）</th>
<th align="center">最后一个元素（Deque实例的结尾）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">插入</td>
<td align="center">addFirst(e)  offerFirst(e)</td>
<td align="center">addLast(e)  offerLast(e)</td>
</tr>
<tr>
<td align="center">移除</td>
<td align="center">removeFirst()  pollFirst()</td>
<td align="center">removeLast()  pollLast()</td>
</tr>
<tr>
<td align="center">检索</td>
<td align="center">getFirst()  peekFirst()</td>
<td align="center">getLast()  peekLast()</td>
</tr>
</tbody></table>
<h6 id="3-ArrayDeque类"><a href="#3-ArrayDeque类" class="headerlink" title="(3) ArrayDeque类"></a>(3) ArrayDeque类</h6><p>实现了 <strong>Deque 接口</strong>。因为 Deque 接口声明了对应于<strong>双端队列、队列和栈</strong>的方法，因此可以用 ArrayDeque 类来创建这些数据集合的实例。==<strong>不要</strong>使用 Stack 类来创建栈，而是使用 ArrayDeque 类==。</p>
<h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><p>符号表是一种<strong>存储键值对</strong>的数据结构，支持两种操作：<strong>插入</strong>，即将一组新的键值存存入表中；<strong>快速查找</strong>，即根据特定的键得到相应的值。符号表的主要目的就是将<strong>一个键和一个值</strong>联系起来。</p>
<p>符号表分为<strong>有序和无序</strong>两种，有序符号表主要指支持 min()、max() 等根据键的<strong>大小关系</strong>来实现的操作，有序符号表保证的是<strong>键</strong>的有序性，比较的是键。</p>
<p>符号表有<strong>多种实现</strong>方式。<strong>树或者散列表</strong>等都可以。散列表的查找算法也可以基于前一节的基础查找算法，只需要有适当改变即可。</p>
<h5 id="1-基础实现"><a href="#1-基础实现" class="headerlink" title="1. 基础实现"></a>1. 基础实现</h5><h6 id="1-链表实现无序符号表"><a href="#1-链表实现无序符号表" class="headerlink" title="(1) 链表实现无序符号表"></a>(1) 链表实现无序符号表</h6><p>一般不用这种实现的，只是理论上可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListUnorderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; <span class="keyword">implements</span> <span class="title">UnorderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node first;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        Key key;</span><br><span class="line">        Value value;</span><br><span class="line">        Node next;</span><br><span class="line"></span><br><span class="line">        Node(Key key, Value value, Node next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        Node cur = first;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        Node cur = first;</span><br><span class="line">        <span class="comment">// 如果在链表中找到节点的键等于 key 就更新这个节点的值为 value</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.key.equals(key)) &#123;</span><br><span class="line">                cur.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则使用头插法插入一个新节点</span></span><br><span class="line">        first = <span class="keyword">new</span> Node(key, value, first);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (first.key.equals(key))</span><br><span class="line">            first = first.next;</span><br><span class="line">        Node pre = first, cur = first.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.key.equals(key)) &#123;</span><br><span class="line">                pre.next = cur.next;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        Node cur = first;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.key.equals(key))</span><br><span class="line">                <span class="keyword">return</span> cur.value;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-二分查找实现有序符号表"><a href="#2-二分查找实现有序符号表" class="headerlink" title="(2) 二分查找实现有序符号表"></a>(2) 二分查找实现有序符号表</h6><p>使用一对平行<strong>数组</strong>，一个存储键一个存储值。二分查找的 rank() 方法至关重要，当键在表中时，它能够知道该键的位置；当键不在表中时，它也能知道在何处插入新键。</p>
<p>二分查找最多需要 logN+1 次比较，使用二分查找实现的符号表的查找操作所需要的时间最多是对数级别的。但是插入操作需要移动数组元素，是线性级别的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchOrderedST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Key</span>&gt;, <span class="title">Value</span>&gt; <span class="keyword">implements</span> <span class="title">OrderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinarySearchOrderedST</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Comparable[capacity];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, h = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> cmp = key.compareTo(keys[m]);</span><br><span class="line">            <span class="keyword">if</span> (cmp == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                h = m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Key&gt; <span class="title">keys</span><span class="params">(Key l, Key h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = rank(l);</span><br><span class="line">        List&lt;Key&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (keys[index].compareTo(h) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            list.add(keys[index]);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = rank(key);</span><br><span class="line">        <span class="comment">// 如果找到已经存在的节点键为 key，就更新这个节点的值为 value</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; N &amp;&amp; keys[index].compareTo(key) == <span class="number">0</span>) &#123;</span><br><span class="line">            values[index] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则在数组中插入新的节点，需要先将插入位置之后的元素都向后移动一个位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N; j &gt; index; j--) &#123;</span><br><span class="line">            keys[j] = keys[j - <span class="number">1</span>];</span><br><span class="line">            values[j] = values[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[index] = key;</span><br><span class="line">        values[index] = value;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = rank(key);</span><br><span class="line">        <span class="keyword">if</span> (index &lt; N &amp;&amp; keys[index].compareTo(key) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> values[index];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Key <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> keys[N - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-其他实现"><a href="#2-其他实现" class="headerlink" title="2. 其他实现"></a>2. 其他实现</h5><p>其他实现参考<strong>二叉查找树、红黑树、散列表</strong>等。</p>
<h5 id="3-符号表算法比较"><a href="#3-符号表算法比较" class="headerlink" title="3. 符号表算法比较"></a>3. 符号表算法比较</h5><table>
<thead>
<tr>
<th align="center">算法</th>
<th align="center">插入</th>
<th align="center">查找</th>
<th align="center">是否有序</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>链表实现</strong>的无序符号表</td>
<td align="center">N</td>
<td align="center">N</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><strong>二分查找实现</strong>的有序符号表</td>
<td align="center">N</td>
<td align="center">logN</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><strong>二叉查找树</strong></td>
<td align="center">logN</td>
<td align="center">logN</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><strong>2-3 查找树</strong></td>
<td align="center">logN</td>
<td align="center">logN</td>
<td align="center">是</td>
</tr>
<tr>
<td align="center"><strong>拉链法</strong>实现的散列表</td>
<td align="center">N/M</td>
<td align="center">N/M</td>
<td align="center">否</td>
</tr>
<tr>
<td align="center"><strong>线性探测法</strong>实现的散列表</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">否</td>
</tr>
</tbody></table>
<p><strong>无序</strong>时应当优先考虑<strong>散列表</strong>，当需要<strong>有序</strong>性操作时使用<strong>红黑树</strong>。</p>
<p>符号表的各种实现方式优缺点对比。</p>
<table>
<thead>
<tr>
<th align="center">数据结构</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>链表</strong>（顺序查找）</td>
<td align="center">适用于小型问题</td>
<td align="center">对大型符号表效率低</td>
</tr>
<tr>
<td align="center"><strong>有序数组</strong>（二分查找）</td>
<td align="center">最优的<strong>查找效率和空间</strong>需求，能够进行有序性相关的操作</td>
<td align="center"><strong>插入</strong>操作很<strong>慢</strong></td>
</tr>
<tr>
<td align="center"><strong>散列表</strong></td>
<td align="center">能够快速的<strong>查找和插入</strong>常见类型的数据</td>
<td align="center"><strong>无法进行有序性</strong>相关的操作，链接与空节点需要额外空间</td>
</tr>
<tr>
<td align="center"><strong>二叉查找树</strong></td>
<td align="center">实现简单，能够进行<strong>有序性</strong>的相关操作</td>
<td align="center">没有性能上界的保证，链接需要额外空间</td>
</tr>
<tr>
<td align="center"><strong>平衡二叉查找树</strong></td>
<td align="center">最优的<strong>查找和插入</strong>效率，能够进行有序性相关的操作</td>
<td align="center">链接需要额外的空间</td>
</tr>
</tbody></table>
<h5 id="4-Java的符号表实现"><a href="#4-Java的符号表实现" class="headerlink" title="4. Java的符号表实现"></a>4. Java的符号表实现</h5><ul>
<li>java.util.TreeMap：<strong>红黑树</strong>。</li>
<li>java.util.HashMap：<strong>拉链法的散列表。</strong></li>
</ul>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><p>散列表是<strong>符号表</strong>的一种实现方式。散列表类似于数组，可以把散列表的散列值看成数组的索引值。访问散列表和访问数组元素一样快速，它可以在常数时间内实现<strong>查找和插入</strong>操作。由于无法通过散列值知道键的大小关系，因此散列表<strong>无法实现有序性</strong>操作。</p>
<p>散列表（Hash table，也叫哈希表），是根据<strong>键值(Key value)</strong> 而直接进行访问的数据结构。也就是说它通过把<strong>键值映射到表中一个位置</strong>来访问记录，以加快查找的速度。这个<strong>映射函数叫做==散列函数==</strong>，存放记录的数组叫做散列表。</p>
<h5 id="1-散列函数"><a href="#1-散列函数" class="headerlink" title="1. 散列函数"></a>1. 散列函数</h5><h6 id="1-定义"><a href="#1-定义" class="headerlink" title="(1) 定义"></a>(1) 定义</h6><p>每个<strong>关键字</strong>被映射到从 <strong>0 到 TableSize - 1</strong> 这个范围的某个数，并被放到合适的单元中，这个映射就是<strong>==散列函数==</strong>。</p>
<p>对于一个大小为 <strong>M</strong> 的散列表，散列函数能够把任意键转换为 <strong>[0, M - 1]</strong> 内的正整数，该正整数即为 <strong>hash</strong> 值。</p>
<p>我们需要寻找一个散列函数，该函数要在单元之间<strong>均匀的分配</strong>关键字。</p>
<p>散列函数应该满足以下<strong>三个条件</strong>：</p>
<ul>
<li><strong>一致性</strong>：相等的键应当有相等的 hash 值，两个键相等表示调用 equals() 返回的值相等。</li>
<li><strong>高效性</strong>：计算应当简便，有必要的话可以把 hash 值缓存起来，在调用 hash 函数时直接返回。</li>
<li><strong>均匀性</strong>：所有键的 hash 值应当均匀地分布到 [0, M-1] 之间，如果不能满足这个条件，有可能产生很多冲突，从而导致散列表的性能下降。</li>
</ul>
<h6 id="2-常见散列函数"><a href="#2-常见散列函数" class="headerlink" title="(2) 常见散列函数"></a>(2) 常见散列函数</h6><p><strong>除留余数法（取模）</strong>可以将整数散列到 [0, M-1] 之间，例如一个正整数 k，计算 k % M 既可得到一个 [0, M-1] 之间的 hash 值。注意 <strong>M 最好是一个素数</strong>，否则无法利用键包含的所有信息。例如 M 为 10<sup>k</sup>，那么只能利用键的后 k 位。</p>
<p>对于其它数，可以将其<strong>转换成整数</strong>的形式，然后利用除留余数法。例如对于<strong>浮点数</strong>，可以将其的<strong>二进制形式</strong>转换成整数。</p>
<p>对于<strong>多部分组合</strong>的类型，每个部分都需要计算 hash 值，这些 hash 值都具有同等重要的地位。为了达到这个目的，可以将该类型看成 R 进制的整数，每个部分都具有不同的<strong>权值</strong>。</p>
<p>例如，字符串的散列函数实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">    hash = (R * hash + s.charAt(i)) % M;</span><br></pre></td></tr></table></figure>

<p>再比如，拥有<strong>多个成员</strong>的自定义类的哈希函数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = (((day * R + month) % M) * R + year) % M;</span><br></pre></td></tr></table></figure>

<p>R 通常取 <strong>31</strong>。</p>
<p>Java 中的 <strong>hashCode</strong>() 实现了哈希函数，但是默认使用对象的<strong>内存地址值</strong>。在使用 hashCode() 时，应当结合除留余数法来使用。因为<strong>内存地址是 32 位整数</strong>，我们只需要 <strong>31 位</strong>的非负整数，因此应当屏蔽符号位之后再使用除留余数法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = (x.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br></pre></td></tr></table></figure>

<p>使用 Java 的 HashMap 等自带的哈希表实现时，只需要去实现 <strong>Key 类型</strong>的 hashCode() 函数即可。Java 规定 hashCode() 能够将键均匀分布于所有的 32 位整数，Java 中的 String、Integer 等对象的 hashCode() 都能实现这一点。以下展示了<strong>自定义类型</strong>如何实现 hashCode()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String who;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date when;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> amount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(String who, Date when, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.who = who;</span><br><span class="line">        <span class="keyword">this</span>.when = when;</span><br><span class="line">        <span class="keyword">this</span>.amount = amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义散列函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = <span class="number">17</span>;</span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">31</span>;</span><br><span class="line">        hash = R * hash + who.hashCode();</span><br><span class="line">        hash = R * hash + when.hashCode();</span><br><span class="line">        hash = R * hash + ((Double) amount).hashCode();</span><br><span class="line">        <span class="keyword">return</span> hash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-散列冲突"><a href="#2-散列冲突" class="headerlink" title="2. 散列冲突"></a>2. 散列冲突</h5><p>当两个关键字散列到<strong>同一个值</strong>的时候，就产生了散列冲突。散列表存在<strong>==冲突==</strong>，也就是两个<strong>不同的键可能有相同的 hash 值</strong>。解决散列冲突的简单方法有：<strong>拉链法和开放定址法</strong>。</p>
<h6 id="1-拉链法"><a href="#1-拉链法" class="headerlink" title="(1) 拉链法"></a>(1) 拉链法</h6><p>拉链法使用<strong>数组 + 链表</strong>来存储 hash 值相同的键，从而解决冲突（比如 HashMap 类）。<strong>查找</strong>需要分两步，首先查找 Key 所在的<strong>链表</strong>（对应的数据槽），然后在链表中<strong>顺序查找</strong>。对于 N 个键，M 条链表 (N &gt; M)，如果哈希函数能够满足均匀性的条件，每条链表的<strong>长度趋向于 N/M</strong>，因此未命中的查找和插入操作所需要的比较次数为 ~N/M。</p>
<img src="assets/1563523769927.png" alt="1563523769927" style="zoom:70%;" />

<p>这个详细可看 <strong>HashMap</strong> 的源码。</p>
<h6 id="2-开放地址法"><a href="#2-开放地址法" class="headerlink" title="(2) 开放地址法"></a>(2) 开放地址法</h6><p>线性探测法使用<strong>空位</strong>来解决冲突，当冲突发生时，<strong>向前探测一个空位</strong>来存储冲突的键。</p>
<p>更常见的是，单元 h<del>0</del>(x), h<del>1</del>(x), ….  相继被试选，其中</p>
<p><strong><em>h <del>i</del> (x) = (hash(x) + f <del>i</del> (x) ) mod TableSize, 且 f(0) = 0</em>。</strong></p>
<p><strong>函数 f  是解决冲突解决方法（冲突函数）</strong>。此时<strong>所有的数据都需要放入表</strong>内，所以<strong>需要的表比拉链法散列需要的表更大</strong>。把这样的表叫做<strong>探测散列表</strong>。</p>
<p>使用线性探测法，数组的大小 M 应当<strong>大于键的个数 N</strong>（M&gt;N)。</p>
<div align="center"> <img src="assets/0dbc4f7d-05c9-4aae-8065-7b7ea7e9709e.gif" width="350px"> </div><br>

<p>现考察三种具体的冲突解决方案。<strong>线性探测法、平方探测法、双散列法。</strong></p>
<blockquote>
<p><strong>线性探测法</strong></p>
</blockquote>
<p>线性探测法中典型的情形是<strong>冲突函数 f 为一次函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(i) = i</span><br></pre></td></tr></table></figure>

<p>这相当于相继<strong>逐个探测单元</strong>（必要时可以回绕）以查找出一个<strong>空</strong>单元。</p>
<p>存在的<strong>问题</strong>：有时候占据的单元会形成一些<strong>区块</strong>，其结果成为==<strong>一次聚集</strong>==，就是说散列到<strong>区块</strong>中的任何关键字都需要<strong>多次尝试</strong>才能解决冲突。</p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; <span class="keyword">implements</span> <span class="title">UnorderedST</span>&lt;<span class="title">Key</span>, <span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> M = <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">private</span> Key[] keys;</span><br><span class="line">    <span class="keyword">private</span> Value[] values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.M = M;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[M];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % M)</span><br><span class="line">        <span class="keyword">if</span> (keys[i].equals(key))</span><br><span class="line">            <span class="keyword">return</span> values[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">    resize();</span><br><span class="line">    putInternal(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putInternal</span><span class="params">(Key key, Value value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = hash(key); keys[i] != <span class="keyword">null</span>; i = (i + <span class="number">1</span>) % M)</span><br><span class="line">        <span class="keyword">if</span> (keys[i].equals(key)) &#123;</span><br><span class="line">            values[i] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    keys[i] = key;</span><br><span class="line">    values[i] = value;</span><br><span class="line">    N++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<p>删除操作应当将右侧所有相邻的键值对<strong>重新</strong>插入散列表中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = hash(key);</span><br><span class="line">    <span class="keyword">while</span> (keys[i] != <span class="keyword">null</span> &amp;&amp; !key.equals(keys[i]))</span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (keys[i] == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    keys[i] = <span class="keyword">null</span>;</span><br><span class="line">    values[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将之后相连的键值对重新插入</span></span><br><span class="line">    i = (i + <span class="number">1</span>) % M;</span><br><span class="line">    <span class="keyword">while</span> (keys[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Key keyToRedo = keys[i];</span><br><span class="line">        Value valToRedo = values[i];</span><br><span class="line">        keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        values[i] = <span class="keyword">null</span>;</span><br><span class="line">        N--;</span><br><span class="line">        putInternal(keyToRedo, valToRedo);</span><br><span class="line">        i = (i + <span class="number">1</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    N--;</span><br><span class="line">    resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调整数组大小</strong></p>
<p>线性探测法的成本取决于连续条目的长度，连续条目也叫<strong>聚簇</strong>。当聚簇很长时，在查找和插入时也需要进行<strong>很多次探测</strong>。<strong>装填因子</strong>的选取很重要。</p>
<p><strong>α = N/M</strong>，把 α 称为<strong>使用率</strong>。理论证明，当 α 小于 1/2 时探测的预计次数只在 1.5 到 2.5 之间。为了保证散列表的性能，应当调整数组的大小，使得 <strong>α 在 [1/4, 1/2]</strong> 之间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (N &gt;= M / <span class="number">2</span>)</span><br><span class="line">        resize(<span class="number">2</span> * M);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (N &lt;= M / <span class="number">8</span>)</span><br><span class="line">        resize(M / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    LinearProbingHashST&lt;Key, Value&gt; t = <span class="keyword">new</span> LinearProbingHashST&lt;Key, Value&gt;(cap);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">        <span class="keyword">if</span> (keys[i] != <span class="keyword">null</span>)</span><br><span class="line">            t.putInternal(keys[i], values[i]);</span><br><span class="line"></span><br><span class="line">    keys = t.keys;</span><br><span class="line">    values = t.values;</span><br><span class="line">    M = t.M;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>平方探测法</strong></p>
</blockquote>
<p>平方探测是<strong>消除</strong>线性探测中<strong>一次聚集</strong>问题的散列冲突解决方法。</p>
<p>平方探测就是<strong>冲突函数为二次</strong>的探测方法。典型的情形是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(i) = i * i</span><br></pre></td></tr></table></figure>

<p><strong>定理</strong>：如果使用<strong>平方探测</strong>，且表的大小是<strong>素数</strong>，那么当表至少有<strong>一半是空</strong>的时候，<strong>总能够</strong>插入一个新的元素。即使表被填充的位置仅仅比<strong>一半多一个</strong>，那么插入都<strong>可能失败</strong>。</p>
<p>平方探测也可能产生<strong>二次聚集</strong>问题。</p>
<blockquote>
<p><strong>双散列法</strong></p>
</blockquote>
<p>双散列法冲突函数一般的选择是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(i) = i * hash2(x)</span><br></pre></td></tr></table></figure>

<p>这个公式是说将第二个散列函数应用到 x 并在距离 <strong>hash<del>2</del>(x)</strong>,  <strong>2 hash<del>2</del>(x)….</strong> 等处进行探测。</p>
<h5 id="3-再散列"><a href="#3-再散列" class="headerlink" title="3. 再散列"></a>3. 再散列</h5><p>如果散列表装的太满，那么再插入新元素的时候可能消耗时间很长，而且可能失败。解决方法是建立另一个大约 2 倍大的表，然后扫描整个原始散列表，<strong>重新计算元素的新散列值</strong>并装入到新的散列表中。这个操作就是<strong>再散列</strong>。</p>
<p>再散列显然开销较大。</p>
<p><strong>再散列策略</strong></p>
<ul>
<li>散列表到一半满就再散列。</li>
<li>当插入元素失败才再散列（比较极端）。</li>
<li><strong>途中策略</strong>：当散列表达到一个<strong>装填因子</strong>时进行再散列（较好）。</li>
</ul>
<h5 id="4-高级散列"><a href="#4-高级散列" class="headerlink" title="4. 高级散列"></a>4. 高级散列</h5><p>介绍几个高级一定的散列表。</p>
<h6 id="1-完美散列"><a href="#1-完美散列" class="headerlink" title="(1) 完美散列"></a>(1) 完美散列</h6><p><strong>完美散列的定义</strong>：在关键字集不再变化的情况下，运用某种散列技术，将所有的关键字存入散列表中，可以在最坏运行时间为 O(1) 的情况下完成对散列表的查找工作，这种散列方法就是<strong>完美散列</strong>。</p>
<p>我们期望最坏的情况下，查找的时间函数也是 O(1) — <strong>完美散列</strong>。</p>
<p>使用<strong>二级散列表</strong>可以实现完美散列。每个二级散列表将用一个<strong>不同的散列函数</strong>进行构造，直到没有冲突为止。</p>
<h6 id="2-布谷鸟散列"><a href="#2-布谷鸟散列" class="headerlink" title="(2) 布谷鸟散列"></a>(2) 布谷鸟散列</h6><p>CuckooHash（布谷鸟散列）是为了解决<strong>哈希冲突问题</strong>而提出，利用较少的计算换取较大的<strong>空间</strong>。</p>
<p>假设有 N 个项，分别维护<strong>两个</strong>超过半空的表，且有<strong>两个独立的散列函数</strong>，可以把每个项分配到每个表的一个位置。布谷鸟散列保持不变的是一个项总是会被存储在这两个位置之一。</p>
<p><strong>算法描述</strong></p>
<p>使用 hashA、hashB 计算对应的 key 位置：</p>
<p>1、两个位置均为空，则任选一个插入；<br>2、两个位置中一个为空，则插入到空的那个位置<br>3、两个位置均不为空，则踢出一个位置后插入，被踢出的对调用该算法，再执行该算法找其另一个位置，循环直到插入成功。<br>4、如果被踢出的次数达到一定的阈值，则认为 hash 表已满，并进行再哈希 rehash。</p>
<p>布谷鸟散列通常被实现成一张巨大的表，且带有<strong>两个（或多个）可以探测整表的散列函数</strong>。</p>
<p>具体实现参考：<a href="https://www.jianshu.com/p/68220564f341" target="_blank" rel="noopener">https://www.jianshu.com/p/68220564f341</a></p>
<h6 id="6-跳房子散列"><a href="#6-跳房子散列" class="headerlink" title="(6) 跳房子散列"></a>(6) 跳房子散列</h6><p>线性探测法是在散列位置的相邻点开始探测，这会引起很多问题，于是各种优化版本例如平方探测、双散列等被提出来改进其中的聚集问题。但是探测相邻位置和第二次散列相比，显然探测相邻位置更有优势，所以线性探测仍然是实用的，甚至是最佳选择。</p>
<p>跳房子散列的思路：<strong>用事先确定的，对计算机底层体系结构而言最优的一个常数</strong>，给探测序列的最大长度加个上界。这样做可以给出常数级的最坏查询时间，并且与<strong>布谷鸟散列</strong>一样，查询可以并行化，以同时检查可用位置 的有限集。</p>
<p> <strong>要点：</strong></p>
<p> a）依然是线性探测。</p>
<p> b）探测长度 <em>i</em> 有个上限。</p>
<p> c）上限是提前定好的，跟计算机底层体系结构有关系。</p>
<p> 但是布谷鸟散列和跳房子散列还处于实验室状态，能否在实际中代替线性探测法或者平方探测法，还有待验证。</p>
<h4 id="优先级队列与堆"><a href="#优先级队列与堆" class="headerlink" title="优先级队列与堆"></a>优先级队列与堆</h4><h5 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1. 概述"></a>1. 概述</h5><p><strong>优先级队列</strong>有多种实现方法，对比如下表。</p>
<table>
<thead>
<tr>
<th align="center">数据结构</th>
<th align="center">插入元素</th>
<th align="center">删除最大元素</th>
</tr>
</thead>
<tbody><tr>
<td align="center">有序数组</td>
<td align="center">N</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">无序数组</td>
<td align="center">1</td>
<td align="center">N</td>
</tr>
<tr>
<td align="center"><strong>二叉堆</strong></td>
<td align="center"><strong><em>logN</em></strong></td>
<td align="center"><strong><em>logN</em></strong></td>
</tr>
<tr>
<td align="center">理想情况1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>用堆实现优先队列比较香。</p>
<h5 id="2-二叉堆"><a href="#2-二叉堆" class="headerlink" title="2. 二叉堆"></a>2. 二叉堆</h5><h6 id="1-存储特点"><a href="#1-存储特点" class="headerlink" title="(1) 存储特点"></a>(1) 存储特点</h6><p><strong>根结点</strong>是堆有序的二叉树中的最大结点或最小结点。<strong>堆中</strong>某个节点的值总是<strong>大于等于</strong>其子节点的值，并且堆是<strong>==一颗完全二叉树==</strong>。堆可以用==<strong>数组</strong>==来表示，这是因为<strong>堆是完全二叉树</strong>，而<strong>完全二叉树</strong>很容易就存储在<strong>数组</strong>中。这里<strong>不使用数组索引为 0</strong> 的位置，可以清晰地描述节点的<strong>位置关系</strong>。位置 <strong>k</strong> 的节点的父节点位置为 <strong>k / 2</strong>，而它的两个子节点的位置分别为 <strong>2k 和 2k+1</strong>。</p>
<img src="assets/image-20191219123741643.png" alt="image-20191219123741643" style="zoom:47%;" />

<p>因为<strong>堆</strong>在形式上是一颗<strong>完全二叉树</strong>，用数组来存储它<strong>不会浪费</strong>任何空间。<strong>注意：</strong>这里是把下标为 <strong>0</strong> 的地方<strong>空出来</strong>了的，主要是为了方便理解，如果 0 不空出来只需要在计算的时候把 i 值往右偏移一个位置就行了。</p>
<table>
<thead>
<tr>
<th align="center">结点</th>
<th align="center">位置</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>当前结点</strong></td>
<td align="center"><strong>a[i]</strong></td>
</tr>
<tr>
<td align="center"><strong>父结点</strong></td>
<td align="center"><strong>a[i/2]</strong></td>
</tr>
<tr>
<td align="center"><strong>左子结点</strong></td>
<td align="center"><strong>a[2i]</strong></td>
</tr>
<tr>
<td align="center"><strong>右子结点</strong></td>
<td align="center"><strong>a[2i+1]</strong></td>
</tr>
</tbody></table>
<p>注意父节点位置这里是<strong>整数除</strong>，<strong>2 和 3 除以 2 都为 1</strong>。</p>
<h6 id="2-基本属性与操作"><a href="#2-基本属性与操作" class="headerlink" title="(2) 基本属性与操作"></a>(2) 基本属性与操作</h6><p>以下是<strong>二叉堆类</strong>的基本属性与基本操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryHeap</span>&lt;<span class="title">AnyType</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">AnyType</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前堆中的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> currentSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放堆元素的数组</span></span><br><span class="line">    <span class="keyword">private</span> AnyType[] dataArray;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryHeap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        currentSize = <span class="number">0</span>;</span><br><span class="line">        dataArray = (AnyType[]) <span class="keyword">new</span> Comparable[ capacity + <span class="number">1</span> ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组扩容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enlargeArray</span><span class="params">(<span class="keyword">int</span> newSize)</span> </span>&#123;</span><br><span class="line">        AnyType[] old = dataArray;</span><br><span class="line">        dataArray = (AnyType[]) <span class="keyword">new</span> Comparable[newSize];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; old.length; i++) &#123;</span><br><span class="line">            dataArray[i] = old[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回二叉堆最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AnyType <span class="title">findMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( isEmpty() ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException( );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前构造的最小堆，数组第一个元素就是最小值 注意索引0是不用的</span></span><br><span class="line">        <span class="keyword">return</span> dataArray[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空二叉堆</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String [ ] args )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numItems = <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">// 构造一个堆</span></span><br><span class="line">        BinaryHeap&lt;Integer&gt; h = <span class="keyword">new</span> BinaryHeap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">37</span>;</span><br><span class="line">        <span class="comment">// 将元素加入堆</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">37</span>; i != <span class="number">0</span>; i = (i + <span class="number">37</span>) % numItems) &#123;</span><br><span class="line">            h.insert(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; numItems; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(h.deleteMin() != i) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Oops! "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-插入元素"><a href="#3-插入元素" class="headerlink" title="(3) 插入元素"></a>(3) 插入元素</h6><p>当<strong>插入</strong>一个元素到堆中时，它可能<strong>不满足堆</strong>的性质，在这种情况下，需要<strong>调整堆中元素的位置使之重新变成堆</strong>，这个过程称为<strong>堆化</strong>（<strong>heapify</strong>）；在最大堆中，要堆化一个元素，需要<strong>找到它的父亲结点</strong>，如果不满足堆的基本性质则<strong>交换两个元素的位置</strong>，重复该过程直到每个结点都满足堆的性质为止。</p>
<p>在堆的<strong>==下一个可用位置（也就是存放元素数组的下一个位置）创建一个空穴==</strong>，否则该堆将不是完全树。将<strong>待插入的元素</strong>与<strong>空穴的父结点</strong>进行比较，如果比父节点小就交换空穴与父节点位置，空穴<strong>==上浮==</strong>，循环此过程。实现时就是将<strong>新元素</strong>放到<strong>==数组末尾==</strong>，然后<strong>==上浮==</strong>到合适的位置。</p>
<p>下面在该堆中插入一个新的元素 <strong>26</strong>：在二叉堆的下一个可用位置放置一个<strong>空穴</strong>，该空穴值假定为 26，但是<strong>不赋值</strong>，可以<strong>==减少比较与交换操作==</strong>。</p>
<img src="assets/image-20191219123802820.png" alt="image-20191219123802820" style="zoom:50%;" />

<p>通过二叉堆的<strong>索引</strong>公式可以找到新插入元素的<strong>父亲结点</strong>，然后<strong>比较它们的大小</strong>，如果新元素更大则交换两个元素的位置，这个操作就相当于把该元素<strong>==上浮==</strong>了一下。如下图中 26 与 16 交换位， 26 上浮。</p>
<img src="assets/image-20191219123844301.png" alt="image-20191219123844301" style="zoom:50%;" />

<p>重复该操作直到 26 到了一个<strong>满足堆条件的位置</strong>，此时就完成了插入的操作，下图插入 26 完成。</p>
<img src="assets/image-20191219123934771.png" alt="image-20191219123934771" style="zoom:50%;" />

<p><strong>插入元素</strong>代码实现如下（下面的代码是插入元素到小顶堆中）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(AnyType newNode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先检查数组容量是否需要扩容</span></span><br><span class="line">    <span class="keyword">if</span>(currentSize == dataArray.length - <span class="number">1</span>) &#123;</span><br><span class="line">        enlargeArray(dataArray.length * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 空穴位置是当前元素数量＋1</span></span><br><span class="line">    <span class="keyword">int</span> hole = ++currentSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断将插入元素与空穴的父节点进行比较</span></span><br><span class="line">    <span class="keyword">for</span>(dataArray[<span class="number">0</span>] = newNode; newNode.compareTo(dataArray[hole / <span class="number">2</span>]) &lt; <span class="number">0</span>; hole /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 交换空穴与其父节点位置 空穴上浮</span></span><br><span class="line">        dataArray[hole] = dataArray[hole / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后才将插入值赋给空穴处 可以减少每次的交换操作</span></span><br><span class="line">    dataArray[hole] = newNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="4-删除顶部元素"><a href="#4-删除顶部元素" class="headerlink" title="(4) 删除顶部元素"></a>(4) 删除顶部元素</h6><p>取出堆中的<strong>堆顶元素</strong>就是用<strong>最后一个元素替换掉栈顶元素</strong>，然后把最后一个元素删除掉，这样一来元素的总个数也满足条件，然后只需要把<strong>栈顶元素依次往下调整</strong>就好了，这个操作就叫做 <strong>sink（下沉）</strong>。</p>
<p><strong>操作</strong>也是将<strong>堆顶元素置换为空穴</strong>，然后将空穴的<strong>两个儿子中较小者</strong>与其交换位置，直到下沉到对应位置。但是可能遇到<strong>只有一个子结点</strong>的情况，此时一种解决方法是始终保证算法把每一个结点都<strong>看成有两个子结点</strong>。为了实施这种解法，当堆的大小为偶数时在每个<strong>下沉开始处</strong>，可将其值<strong>大于堆中任何元素的标记</strong>放到堆的<strong>终端后面</strong>的位置上。也就是假想有一个大于或者小于任何元素的结点此时正在堆的<strong>最后一个位置</strong>上。</p>
<p>从数组<strong>顶端删除最大</strong>的元素，并将数组的<strong>最后一个元素放到顶端</strong>，并让这个元素<strong>==下沉到合适==</strong>的位置。</p>
<p>例如删除堆顶元素 62。</p>
<img src="assets/image-20191219133042581.png" alt="image-20191219133042581" style="zoom:50%;" />

<p>用数组最后的一个元素<strong>==替换==</strong>掉堆顶元素，然后删除最后一个元素并返回堆顶元素：</p>
<img src="assets/image-20191219133111364.png" alt="image-20191219133111364" style="zoom:50%;" />

<p>然后比较其孩子结点的大小：</p>
<img src="assets/image-20191219133300378.png" alt="image-20191219133300378" style="zoom:50%;" />

<p>如果<strong>不满足堆</strong>的条件，那么就跟<strong>孩子结点中较大</strong>的一个交换位置：41 ＞ 30，所以16 与 41 <strong>交换</strong>位置。</p>
<img src="assets/image-20191219133315335.png" alt="image-20191219133315335" style="zoom:50%;" />

<p>重复该步骤，直到 16 到达合适的位置：</p>
<img src="assets/image-20191219133330143.png" alt="image-20191219133330143" style="zoom:50%;" />

<p><strong>完成</strong>取出堆顶元素的操作：</p>
<img src="assets/image-20191219133347962.png" alt="image-20191219133347962" style="zoom:50%;" />

<p>代码实现如下（下面的代码是移除小顶堆的最小值代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除最小值 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnyType <span class="title">deleteMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判空</span></span><br><span class="line">    <span class="keyword">if</span>(isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 找到堆顶的元素</span></span><br><span class="line">    AnyType minItem = findMin();</span><br><span class="line">    <span class="comment">// 交换堆顶元素与最后一个元素</span></span><br><span class="line">    dataArray[<span class="number">1</span>] = dataArray[currentSize--];</span><br><span class="line">    <span class="comment">// 执行下沉操作 </span></span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 返回堆顶的元素</span></span><br><span class="line">    <span class="keyword">return</span> minItem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下沉操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hole 空穴</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> hole)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    AnyType tmp = dataArray[hole];</span><br><span class="line">    <span class="keyword">for</span>( ; hole * <span class="number">2</span> &lt;= currentSize; hole = child) &#123;</span><br><span class="line">        child = hole * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(child != currentSize &amp;&amp; dataArray[child + <span class="number">1</span>].compareTo(dataArray[child]) &lt; <span class="number">0</span> ) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dataArray[child].compareTo(tmp) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            dataArray[hole] = dataArray[child];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dataArray[hole] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="5-根据数组构造堆"><a href="#5-根据数组构造堆" class="headerlink" title="(5) 根据数组构造堆"></a>(5) 根据数组构造堆</h6><p>下列的代码是根据数组<strong>构造</strong>小顶堆。就是<strong>不断对每个元素</strong>执行 <strong>sink下沉</strong>操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过给定的任意数组构造一个小顶堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BinaryHeap</span><span class="params">(AnyType[] items)</span> </span>&#123;</span><br><span class="line">    currentSize = items.length;</span><br><span class="line">    dataArray = (AnyType[]) <span class="keyword">new</span> Comparable[(currentSize + <span class="number">2</span>) * <span class="number">11</span> / <span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 默认从1索引开始，第0个位置不管</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(AnyType item : items) &#123;</span><br><span class="line">        dataArray[i++] = item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构建堆</span></span><br><span class="line">    buildHeap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = currentSize / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 执行下沉操作</span></span><br><span class="line">        sink(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-Java中的PriorityQueue"><a href="#3-Java中的PriorityQueue" class="headerlink" title="3. Java中的PriorityQueue"></a>3. Java中的PriorityQueue</h5><p>在 Java 中也实现了自己的优先队列<code>java.util.PriorityQueue</code>，默认为<strong>最小堆</strong>，与上述相比有一些函数名不一样，底层还是维护了一个 <strong>Object 类型的数组</strong>，另外如果想要把最小堆变成<strong>最大堆</strong>可以给 PriorityQueue 传入自己的<strong>比较器</strong>，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为最小堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">pq.add(<span class="number">5</span>);</span><br><span class="line">pq.add(<span class="number">2</span>);</span><br><span class="line">pq.add(<span class="number">1</span>);</span><br><span class="line">pq.add(<span class="number">10</span>);</span><br><span class="line">pq.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">    System.out.println(pq.poll() + <span class="string">", "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">System.out.println(<span class="string">"————————————————————————"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Lambda表达式传入自己的比较器转换成最大堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; pq2 = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">pq2.add(<span class="number">5</span>);</span><br><span class="line">pq2.add(<span class="number">2</span>);</span><br><span class="line">pq2.add(<span class="number">1</span>);</span><br><span class="line">pq2.add(<span class="number">10</span>);</span><br><span class="line">pq2.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!pq2.isEmpty()) &#123;</span><br><span class="line">    System.out.println(pq2.poll() + <span class="string">", "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-优先级队列的应用"><a href="#4-优先级队列的应用" class="headerlink" title="4. 优先级队列的应用"></a>4. 优先级队列的应用</h5><p>应用很多：</p>
<ul>
<li>数据压缩：赫夫曼编码算法；</li>
<li>最短路径算法：Dijkstra 算法；</li>
<li>最小生成树算法：Prim 算法；</li>
<li>事件驱动仿真：顾客排队算法；</li>
<li>选择问题：查找第 k 个最小元素；</li>
</ul>
<h6 id="1-动态数据排序找前-K-个值"><a href="#1-动态数据排序找前-K-个值" class="headerlink" title="(1) 动态数据排序找前 K 个值"></a>(1) 动态数据排序找前 K 个值</h6><p>在某些数据处理的例子中，总数据量太大，无法排序（甚至无法全部装进内存）。例如，需要从十亿个元素中选出<strong>最大的十个</strong>，你真的想把一个 <strong>10 亿规模</strong>的数组排序（或者是<strong>无限的数据流</strong>）吗？但有了优先队列，你只用一个能存储<strong>十个元素的队列</strong>即可。具体做法是让元素一个个输入，只要优先队列的个数大于 10，就不断删除最小元素，最后优先队列长度不大于 10 时停止删除，只剩 10 个自然就是所有元素中最大的 10 个了。很多情况我们会收集一些元素，处理当前键值最大（或最小）的元素，然后再收集更多的元素，再处理当前最大的（或最小的）元素，这可以看成我们按照事件的优先级顺序来处理，生活中很多任务都是有优先级高低之分的，所以优先队列可以高效地处理这些情况。</p>
<h6 id="2-找中值"><a href="#2-找中值" class="headerlink" title="(2) 找中值"></a>(2) 找中值</h6><p>可以维护两个堆，一个大顶堆、一个小顶堆，用于找很多数或者无界数的中值。</p>
<h5 id="5-左式堆"><a href="#5-左式堆" class="headerlink" title="5. 左式堆"></a>5. 左式堆</h5><p>设计一种堆结构像二叉堆那样高效的支持合并操作而且<strong>只使用一个数组</strong>似乎很困难。原因在于，<strong>合并</strong>似乎需要把一个数组拷贝到另一个数组中去，对于相同大小的堆，这将花费O(N)。正因为如此，所有<strong>支持高效合并</strong>的高级数据结构都需要使用指针。</p>
<p>像二叉堆那样，<strong>左式堆</strong>也有结构性和堆序性。不仅如此，左式堆也是二叉树，它和二叉堆之间的唯一区别在于：<strong>左式堆不是理想平衡的，而实际上是趋向于非常不平衡</strong>。<br>把任意节点 X 的<strong>零路径长</strong>(null path length, <strong>NPL</strong>) NPL(X) 定义为从 X 到一个<strong>没有两个儿子</strong>的节点的<strong>最短路径</strong>长。因此，具有 0 个或 1 个儿子的节点的 NPL 值为 0，而 NPL(NULL) = -1。注意，任意节点的零路径长比它的各个儿子节点的最小值多 1。</p>
<p>左式堆的性质是：对于堆中的每一个节点 X，<strong>左儿子的零路径长至少与右儿子的零路径长一样大</strong>。这个性质使左式堆明显更偏重于<strong>使树向左增加深度</strong>，左式堆的名称也由此而来。</p>
<h5 id="6-斜堆"><a href="#6-斜堆" class="headerlink" title="6. 斜堆"></a>6. 斜堆</h5><p>斜堆是左式堆的自调节形式，实现起来较为简单。斜堆是具有堆序的二叉树，但不存在对树的结构限制。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h4><ul>
<li><a href="https://www.jianshu.com/p/68220564f341" target="_blank" rel="noopener">https://www.jianshu.com/p/68220564f341</a></li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/A%20Java/B-4-3%20BlockingQueue/" rel="next" title="ShiftJava/A Java/B-4-3 BlockingQueue">
                <i class="fa fa-chevron-left"></i> ShiftJava/A Java/B-4-3 BlockingQueue
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/B%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/A%20%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/" rel="prev" title="ShiftJava/B 数据结构与算法/A 算法基础">
                ShiftJava/B 数据结构与算法/A 算法基础 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本数据结构"><span class="nav-number">1.</span> <span class="nav-text">基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#结构与存储"><span class="nav-number">1.1.</span> <span class="nav-text">结构与存储</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-线性结构与非线性结构"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 线性结构与非线性结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-线性结构"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">(1) 线性结构</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-非线性结构"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">(2) 非线性结构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-存储方式的分析"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. 存储方式的分析</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-数组存储"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">(1) 数组存储</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-链式存储"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">(2) 链式存储</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-树存储"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">(3) 树存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">1.2.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-稀疏数组"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 稀疏数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线性表"><span class="nav-number">1.3.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-数组实现线性表"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 数组实现线性表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-单向链表"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 单向链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-双向链表"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 双向链表</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈"><span class="nav-number">1.4.</span> <span class="nav-text">栈</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-1"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-栈的实现"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 栈的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-栈的数组实现"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">(1) 栈的数组实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-栈的链式实现"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">(2) 栈的链式实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-栈的向量Vector类实现"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">(3) 栈的向量Vector类实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列"><span class="nav-number">1.5.</span> <span class="nav-text">队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-2"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-队列的实现"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. 队列的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-队列的数组实现"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">(1) 队列的数组实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-队列的链式实现"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">(2) 队列的链式实现</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-队列的循环链式实现"><span class="nav-number">1.5.2.3.</span> <span class="nav-text">(3) 队列的循环链式实现</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-双端队列（deque）"><span class="nav-number">1.5.3.</span> <span class="nav-text">3. 双端队列（deque）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-优先级队列（Priority-Queue）"><span class="nav-number">1.5.4.</span> <span class="nav-text">4. 优先级队列（Priority Queue）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Java队列实现"><span class="nav-number">1.5.5.</span> <span class="nav-text">5. Java队列实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-Queue接口"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">(1) Queue接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-Deque接口"><span class="nav-number">1.5.5.2.</span> <span class="nav-text">(2) Deque接口</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-ArrayDeque类"><span class="nav-number">1.5.5.3.</span> <span class="nav-text">(3) ArrayDeque类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#符号表"><span class="nav-number">1.6.</span> <span class="nav-text">符号表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-基础实现"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. 基础实现</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-链表实现无序符号表"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">(1) 链表实现无序符号表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-二分查找实现有序符号表"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">(2) 二分查找实现有序符号表</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-其他实现"><span class="nav-number">1.6.2.</span> <span class="nav-text">2. 其他实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-符号表算法比较"><span class="nav-number">1.6.3.</span> <span class="nav-text">3. 符号表算法比较</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Java的符号表实现"><span class="nav-number">1.6.4.</span> <span class="nav-text">4. Java的符号表实现</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#散列表"><span class="nav-number">1.7.</span> <span class="nav-text">散列表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-散列函数"><span class="nav-number">1.7.1.</span> <span class="nav-text">1. 散列函数</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-定义"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">(1) 定义</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-常见散列函数"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">(2) 常见散列函数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-散列冲突"><span class="nav-number">1.7.2.</span> <span class="nav-text">2. 散列冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-拉链法"><span class="nav-number">1.7.2.1.</span> <span class="nav-text">(1) 拉链法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-开放地址法"><span class="nav-number">1.7.2.2.</span> <span class="nav-text">(2) 开放地址法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-再散列"><span class="nav-number">1.7.3.</span> <span class="nav-text">3. 再散列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-高级散列"><span class="nav-number">1.7.4.</span> <span class="nav-text">4. 高级散列</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-完美散列"><span class="nav-number">1.7.4.1.</span> <span class="nav-text">(1) 完美散列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-布谷鸟散列"><span class="nav-number">1.7.4.2.</span> <span class="nav-text">(2) 布谷鸟散列</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#6-跳房子散列"><span class="nav-number">1.7.4.3.</span> <span class="nav-text">(6) 跳房子散列</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优先级队列与堆"><span class="nav-number">1.8.</span> <span class="nav-text">优先级队列与堆</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述-3"><span class="nav-number">1.8.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-二叉堆"><span class="nav-number">1.8.2.</span> <span class="nav-text">2. 二叉堆</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-存储特点"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">(1) 存储特点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-基本属性与操作"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">(2) 基本属性与操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-插入元素"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">(3) 插入元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-删除顶部元素"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">(4) 删除顶部元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#5-根据数组构造堆"><span class="nav-number">1.8.2.5.</span> <span class="nav-text">(5) 根据数组构造堆</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Java中的PriorityQueue"><span class="nav-number">1.8.3.</span> <span class="nav-text">3. Java中的PriorityQueue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-优先级队列的应用"><span class="nav-number">1.8.4.</span> <span class="nav-text">4. 优先级队列的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-动态数据排序找前-K-个值"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">(1) 动态数据排序找前 K 个值</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-找中值"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">(2) 找中值</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-左式堆"><span class="nav-number">1.8.5.</span> <span class="nav-text">5. 左式堆</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-斜堆"><span class="nav-number">1.8.6.</span> <span class="nav-text">6. 斜堆</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.9.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
