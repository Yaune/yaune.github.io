<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="[TOC] Docker基础1. 什么是DockerDocker 是世界领先的软件容器平台。Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核 提供的 CGroup 功能和 name space 来实现的，以及 AUFS 类的 UnionFS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称">
<meta property="og:type" content="article">
<meta property="og:title" content="ShiftJava&#x2F;Y 其他&#x2F;B Docker">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;index.html">
<meta property="og:site_name" content="路漫漫其修远兮">
<meta property="og:description" content="[TOC] Docker基础1. 什么是DockerDocker 是世界领先的软件容器平台。Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核 提供的 CGroup 功能和 name space 来实现的，以及 AUFS 类的 UnionFS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200728232339554.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200728232438225.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200728232938707.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200803102336535.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200803102412872.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200803102444986.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200803102514884.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200803102623779.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200803102634947.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200803102719868.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200729110136312.png">
<meta property="og:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200729110317808.png">
<meta property="og:updated_time" content="2021-01-06T11:22:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2021&#x2F;08&#x2F;07&#x2F;ShiftJava&#x2F;Y%20%E5%85%B6%E4%BB%96&#x2F;B%20Docker&#x2F;assets&#x2F;image-20200728232339554.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"right","wideth":200,"display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":1},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/08/07/ShiftJava/Y 其他/B Docker/"/>





  <title>ShiftJava/Y 其他/B Docker | 路漫漫其修远兮</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">路漫漫其修远兮</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/08/07/ShiftJava/Y%20%E5%85%B6%E4%BB%96/B%20Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Yue">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="路漫漫其修远兮">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">ShiftJava/Y 其他/B Docker</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-07T19:04:17+08:00">
                2021-08-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="1-什么是Docker"><a href="#1-什么是Docker" class="headerlink" title="1. 什么是Docker"></a>1. 什么是Docker</h5><p><strong>Docker 是世界领先的软件容器平台</strong>。Docker 使用 Google 公司推出的 <strong>Go 语言</strong> 进行开发实现，基于 <strong>Linux 内核</strong> 提供的 CGroup 功能和 name space 来实现的，以及 AUFS 类的 <strong>UnionFS</strong> 等技术，<strong>对进程进行封装隔离，属于操作系统层面的虚拟化技术。</strong> 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。<strong>Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</strong>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>
<h5 id="2-Docker思想"><a href="#2-Docker思想" class="headerlink" title="2. Docker思想"></a>2. Docker思想</h5><ul>
<li><strong>集装箱</strong>。</li>
<li><strong>标准化：</strong> ① 运输方式 ② 存储方式 ③ API 接口。</li>
<li><strong>隔离</strong>。</li>
</ul>
<h5 id="3-Docker容器的特点"><a href="#3-Docker容器的特点" class="headerlink" title="3. Docker容器的特点"></a>3. Docker容器的特点</h5><p><strong>轻量</strong>：在一台机器上运行的多个 Docker 容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</p>
<p><strong>标准</strong>：Docker 容器基于开放式标准，能够在所有主流 Linux 版本、Microsoft Windows 以及包括 VM、裸机服务器和云在内的任何基础设施上运行。</p>
<p><strong>安全</strong>：Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。</p>
<h5 id="4-Docker优点"><a href="#4-Docker优点" class="headerlink" title="4. Docker优点"></a>4. Docker优点</h5><ul>
<li><strong>Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；——一致的运行环境</strong></li>
<li><strong>可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间</strong></li>
<li><strong>避免公用的服务器，资源会容易受到其他用户的影响。——隔离性</strong></li>
<li><strong>善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展</strong></li>
<li><strong>可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便</strong></li>
<li><strong>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署</strong></li>
</ul>
<h4 id="容器与虚拟机"><a href="#容器与虚拟机" class="headerlink" title="容器与虚拟机"></a>容器与虚拟机</h4><h5 id="1-容器"><a href="#1-容器" class="headerlink" title="1. 容器"></a>1. 容器</h5><p>一句话概括容器：<strong>容器就是将软件打包成标准化单元，以用于开发、交付和部署</strong>。</p>
<ul>
<li><p><strong>容器镜像是轻量的、可执行的独立软件包</strong>，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</p>
</li>
<li><p><strong>容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。</strong></p>
</li>
<li><p><strong>容器赋予了软件独立性</strong>，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</p>
<p><strong>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</strong></p>
</li>
</ul>
<h5 id="2-容器与虚拟机关系"><a href="#2-容器与虚拟机关系" class="headerlink" title="2. 容器与虚拟机关系"></a>2. 容器与虚拟机关系</h5><p>简单来说： <strong>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。</strong></p>
<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个<strong>完整操作系统</strong>，在该系统上再运行所需应用进程；而<strong>容器内的应用进程直接运行于宿主的内核</strong>，<strong>容器内没有自己的内核</strong>，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="assets/image-20200728232339554.png" alt="image-20200728232339554"></p>
<p><strong>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。</strong> <strong>多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行</strong> 。与虚拟机相比， <strong>容器占用的空间较少</strong>（容器镜像大小通常只有几十兆），<strong>瞬间就能完成启动</strong> 。</p>
<p><strong>虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。</strong> 管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 <strong>占用大量空间</strong> 。而且 VM <strong>启动也十分缓慢</strong> 。</p>
<p>虚拟机与容器对比：</p>
<p><img src="assets/image-20200728232438225.png" alt="image-20200728232438225"></p>
<p>两者有不同的使用场景。<strong>虚拟机更擅长于彻底隔离整个运行环境</strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 <strong>Docker 通常用于隔离不同的应用</strong>，例如前端，后端以及数据库。</p>
<p><img src="assets/image-20200728232938707.png" alt="image-20200728232938707"></p>
<h4 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h4><p>Docker 中有非常重要的三个基本概念，理解了这三个概念，就理解了 Docker 的整个生命周期。</p>
<ul>
<li><strong>镜像（Image）</strong></li>
<li><strong>容器（Container）</strong></li>
<li><strong>仓库（Repository）</strong></li>
</ul>
<h5 id="1-镜像-Image"><a href="#1-镜像-Image" class="headerlink" title="1. 镜像(Image)"></a>1. 镜像(Image)</h5><p>镜像即一个特殊的文件系统。</p>
<p><strong>操作系统分为内核和用户空间</strong>。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就<strong>相当于是一个 root 文件系统</strong>。</p>
<p><strong>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</strong> 镜像不包含任何动态数据，其内容在构建之后也<strong>不会被改变</strong>。</p>
<p>Docker 设计时，就充分利用 <strong>Union FS</strong>的技术，将其设计为 <strong>分层存储的架构</strong> 。 镜像实际是由多层文件系统联合组成。</p>
<p><strong>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</strong>比如删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<h5 id="2-容器-Container"><a href="#2-容器-Container" class="headerlink" title="2. 容器(Container)"></a>2. 容器(Container)</h5><p>容器即镜像运行时的实体。镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 <strong>类 和 实例</strong> 一样，镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等</strong> 。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，<strong>容器不应该向其存储层内写入任何数据</strong> ，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， <strong>使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。</strong></p>
<h5 id="3-仓库-Repository"><a href="#3-仓库-Repository" class="headerlink" title="3. 仓库(Repository)"></a>3. 仓库(Repository)</h5><p>仓库即集中存放镜像文件的地方。镜像构建完成后，可以很容易的在当前宿主上运行，但是， <strong>如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</strong></p>
<p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。所以说：<strong>镜像仓库是 Docker 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</strong></p>
<p>通常，<strong>一个仓库会包含同一个软件不同版本的镜像</strong>，而<strong>标签就常用于对应该软件的各个版本</strong> 。可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;</strong> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>
<p><strong>这里补充一下 Docker Registry 公开服务和私有 Docker Registry 的概念：</strong></p>
<p><strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>在 Docker Hub 的搜索结果中，有几项关键的信息有助于选择合适的镜像：</p>
<ul>
<li><strong>OFFICIAL Image</strong>：代表镜像为 Docker <strong>官方提供</strong>和维护，相对来说稳定性和安全性较高。</li>
<li><strong>Stars</strong>：和点赞差不多的意思，类似 GitHub 的 Star。</li>
<li><strong>Dowloads</strong>：代表镜像被拉取的次数，基本上能够表示镜像被使用的频度。</li>
</ul>
<p>可以通过 <strong>docker search</strong> 这个命令搜索 Docker Hub 中的镜像，搜索的结果是一致的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker search mysql</span><br><span class="line">NAME                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   8763                [OK]</span><br><span class="line">mariadb                           MariaDB is a community-developed fork of MyS…   3073                [OK]</span><br><span class="line">mysql/mysql-server                Optimized MySQL Server Docker images. Create…   650                                     [OK]</span><br></pre></td></tr></table></figure>



<h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h4><h5 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker version <span class="comment"># 查看docker版本</span></span><br><span class="line">docker images <span class="comment"># 查看所有已下载镜像，等价于：docker image ls 命令</span></span><br><span class="line">docker container ls <span class="comment"># 查看所有容器</span></span><br><span class="line">docker ps <span class="comment">#查看正在运行的容器</span></span><br><span class="line">docker image prune <span class="comment"># 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span></span><br></pre></td></tr></table></figure>

<h5 id="2-拉取镜像"><a href="#2-拉取镜像" class="headerlink" title="2. 拉取镜像"></a>2. 拉取镜像</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql <span class="comment"># 查看mysql相关镜像</span></span><br><span class="line">docker pull mysql:5.7 <span class="comment"># 拉取mysql镜像</span></span><br><span class="line">docker image ls <span class="comment"># 查看所有已下载镜像</span></span><br></pre></td></tr></table></figure>

<h5 id="3-删除镜像"><a href="#3-删除镜像" class="headerlink" title="3. 删除镜像"></a>3. 删除镜像</h5><h6 id="1-通过标签删除镜像"><a href="#1-通过标签删除镜像" class="headerlink" title="(1) 通过标签删除镜像"></a>(1) 通过标签删除镜像</h6><p>通过如下两个都可以删除镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [image]</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [image]</span><br></pre></td></tr></table></figure>

<p>支持的子命令如下：</p>
<ul>
<li><strong>-f,-force</strong>：强制删除镜像，即便有容器引用该镜像。</li>
<li><strong>-no-prune</strong>：不要删除未带标签的父镜像。</li>
</ul>
<p><img src="assets/image-20200803102336535.png" alt="image-20200803102336535"></p>
<p>Docker 查看镜像信息。例如想删除 allen_mysql:5.7 镜像，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi allen_mysql:5.7</span><br></pre></td></tr></table></figure>

<p><img src="assets/image-20200803102412872.png" alt="image-20200803102412872"></p>
<p>实际上，当同一个镜像拥有多个标签时，执行 docker rmi 命令，只是会删除了该镜像众多标签中，自己指定的标签而已，并不会影响原始的那个镜像文件。可以执行 docker images 命令，来看下 docker.io/mysql:5.7 镜像还在不在：</p>
<p><img src="assets/image-20200803102444986.png" alt="image-20200803102444986"></p>
<p>可以看到， docker.io/mysql:5.7 镜像依然存在！</p>
<p>如果某个镜像不存在多个标签，当且仅当只有一个标签时，执行删除命令时就要小心了，这会<strong>彻底删除镜像</strong>。</p>
<p>例如这个时候再执行 docker rmi docker.io/mysql:5.7 命令：</p>
<p><img src="assets/image-20200803102514884.png" alt="image-20200803102514884"></p>
<p>从上图可以看到已经删除了 docker.io/mysql:5.7 镜像的所有文件层。该镜像在本地已不复存在了！</p>
<h6 id="2-通过ID删除镜像"><a href="#2-通过ID删除镜像" class="headerlink" title="(2) 通过ID删除镜像"></a>(2) 通过ID删除镜像</h6><p>除了通过标签名称来删除镜像，还可以通过制定<strong>镜像 ID</strong> 来删除镜像，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi ee7cbd482336</span><br></pre></td></tr></table></figure>

<p>一旦制定了通过 ID 来删除镜像，它会先尝试删除所有指向该镜像的标签，然后在删除镜像本身。</p>
<h6 id="3-删除镜像的限制"><a href="#3-删除镜像的限制" class="headerlink" title="(3) 删除镜像的限制"></a>(3) 删除镜像的限制</h6><p>删除镜像很简单，但也不是何时何地都能删除的，它存在一些限制条件。</p>
<p>当通过该镜像创建的容器未被销毁时，镜像是无法被删除的。为了验证这一点来做个试验。首先通过 <strong>docker pull alpine</strong> 命令，拉取一个最新的 alpine 镜像, 然后启动镜像，让其输出 hello,docker!:</p>
<p><img src="assets/image-20200803102623779.png" alt="image-20200803102623779"></p>
<p>接下来删除这个镜像试试：</p>
<p><img src="assets/image-20200803102634947.png" alt="image-20200803102634947"></p>
<p>可以看到提示信息，无法删除该镜像，因为有容器正在引用他！同时，这段信息还告诉除非<strong>通过添加 -f 参数</strong>，也就是强制删除，才能移除掉该镜像！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f docker.io/alpine</span><br></pre></td></tr></table></figure>

<p>但是一般不推荐这样暴力的做法，正确的做法应该是：</p>
<ol>
<li>先删除引用这个镜像的容器。</li>
<li>再删除这个镜像。</li>
</ol>
<p>也就是，根据上图中提示的，引用该镜像的容器 ID ( <code>9d59e2278553</code>), 执行删除命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm 9d59e2278553</span><br></pre></td></tr></table></figure>

<p>然后再执行删除镜像的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 5cb3aa00f899</span><br></pre></td></tr></table></figure>

<p><img src="assets/image-20200803102719868.png" alt="image-20200803102719868"></p>
<p>这个时候，就能正常删除了！</p>
<h6 id="4-清理镜像"><a href="#4-清理镜像" class="headerlink" title="(4) 清理镜像"></a>(4) 清理镜像</h6><p>在使用 Docker 一段时间后，系统一般都会残存一些<strong>临时的、没有被使用的镜像文件</strong>，可以通过以下命令进行清理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>



<h4 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>这里谈谈：Build, Ship, and Run。</p>
<p>如果搜索 Docker 官网，会发现如下的字样：<strong>“Docker - Build, Ship, and Run Any App, Anywhere”</strong>。</p>
<ul>
<li><strong>Build（构建镜像）</strong>： 镜像就像是集装箱包括文件以及运行环境等等资源。</li>
<li><strong>Ship（运输镜像）</strong>：主机和仓库间运输，这里的仓库就像是超级码头一样。</li>
<li><strong>Run（运行镜像）</strong>：运行的镜像就是一个容器，容器就是运行程序的地方。</li>
</ul>
<p><strong>Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。所以常常将 Docker 称为码头工人或码头装卸工，这和 Docker 的中文翻译搬运工人如出一辙。</strong></p>
<h5 id="2-查看镜像详细信息"><a href="#2-查看镜像详细信息" class="headerlink" title="2. 查看镜像详细信息"></a>2. 查看镜像详细信息</h5><p>通过 <strong>docker inspect</strong> 命令，我们可以获取镜像的详细信息，其中，包括创建者，各层的数字摘要等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect docker.io/mysql:5.7</span><br></pre></td></tr></table></figure>

<p><img src="assets/image-20200729110136312.png" alt="image-20200729110136312"></p>
<p>docker inspect 返回的是 <strong>JSON</strong> 格式的信息，如果想获取其中指定的一项内容，可以通过 -f 来指定，如获取镜像大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;&quot;.Size&quot;&#125;&#125; docker.io/mysql:5.7</span><br></pre></td></tr></table></figure>

<p><img src="assets/image-20200729110317808.png" alt="image-20200729110317808"></p>
<h4 id="Docker底层原理"><a href="#Docker底层原理" class="headerlink" title="Docker底层原理"></a>Docker底层原理</h4><h5 id="1-基于LXC的虚拟容器技术"><a href="#1-基于LXC的虚拟容器技术" class="headerlink" title="1. 基于LXC的虚拟容器技术"></a>1. 基于LXC的虚拟容器技术</h5><p>Docker 技术是基于 <strong>LXC（Linux container- Linux 容器）虚拟容器技术</strong>的。</p>
<p>LXC，其名称来自 Linux 软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为 Linux 内核容器功能的一个用户空间接口。它将应用软件系统打包成一个软件容器（Container），内含应用软件本身的代码，以及所需要的操作系统核心和库。通过统一的名字空间和共用 API 来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境，使得 Linux 用户可以容易的创建和管理系统或应用容器。</p>
<p>LXC 技术主要是借助 Linux 内核中提供的 <strong>CGroup 功能和 name space 来实现</strong>的，通过 LXC 可以为软件提供一个独立的操作系统运行环境。</p>
<p><strong>cgroup 和 namespace 介绍：</strong></p>
<ul>
<li><p><strong>namespace 是 Linux 内核用来隔离内核资源的方式。</strong> 通过 namespace 可以让一些进程只能看到与自己相关的一部分资源，而另外一些进程也只能看到与它们自己相关的资源，这两拨进程根本就感觉不到对方的存在。具体的实现方式是把一个或多个进程的相关资源指定在同一个 namespace 中。Linux namespaces 是对全局系统资源的一种封装隔离，使得处于不同 namespace 的进程拥有独立的全局系统资源，改变一个 namespace 中的系统资源只会影响当前 namespace 里的进程，对其他 namespace 中的进程没有影响。</p>
</li>
<li><p>CGroup 是 Control Groups 的缩写，是 Linux 内核提供的一种可以限制、记录、隔离进程组 (process groups) 所使用的物力资源 (如 cpu memory i/o 等等) 的机制。</p>
</li>
</ul>
<p><strong>cgroup 和 namespace 两者对比：</strong></p>
<p>两者都是将进程进行分组，但是两者的作用还是有本质区别。namespace 是为了隔离进程组之间的资源，而 cgroup 是为了对一组进程进行统一的资源监控和限制。</p>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/53260098" target="_blank" rel="noopener" title="10分钟看懂Docker和K8S">10 分钟看懂 Docker 和 K8S</a></p>
</li>
<li><p><a href="https://www.infoq.cn/article/te70FlSyxhltL1Cr7gzM" target="_blank" rel="noopener" title="从零开始入门 K8s：详解 K8s 容器基本概念">从零开始入门 K8s：详解 K8s 容器基本概念</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000009732550" target="_blank" rel="noopener" title="Linux Namespace和Cgroup">Linux Namespace 和 Cgroup</a></p>
</li>
<li><p><a href="https://www.upguard.com/articles/docker-vs-lxc" target="_blank" rel="noopener" title="LXC vs Docker: Why Docker is Better">LXC vs Docker: Why Docker is Better</a></p>
</li>
<li><p><a href="https://www.ibm.com/developerworks/cn/linux/1506_cgroup/index.html" target="_blank" rel="noopener" title="CGroup 介绍、应用实例及原理描述">CGroup 介绍、应用实例及原理描述</a></p>
</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/W%20%E9%9D%A2%E8%AF%95/A%20%E7%AE%80%E5%8E%86%E7%9B%B8%E5%85%B3/" rel="next" title="ShiftJava/W 面试/A 简历相关">
                <i class="fa fa-chevron-left"></i> ShiftJava/W 面试/A 简历相关
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/08/07/ShiftJava/Y%20%E5%85%B6%E4%BB%96/A%20Git/" rel="prev" title="ShiftJava/Y 其他/A Git">
                ShiftJava/Y 其他/A Git <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Yue</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">163</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker"><span class="nav-number">1.</span> <span class="nav-text">Docker</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础"><span class="nav-number">1.1.</span> <span class="nav-text">基础</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-什么是Docker"><span class="nav-number">1.1.1.</span> <span class="nav-text">1. 什么是Docker</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Docker思想"><span class="nav-number">1.1.2.</span> <span class="nav-text">2. Docker思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Docker容器的特点"><span class="nav-number">1.1.3.</span> <span class="nav-text">3. Docker容器的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Docker优点"><span class="nav-number">1.1.4.</span> <span class="nav-text">4. Docker优点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#容器与虚拟机"><span class="nav-number">1.2.</span> <span class="nav-text">容器与虚拟机</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-容器"><span class="nav-number">1.2.1.</span> <span class="nav-text">1. 容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-容器与虚拟机关系"><span class="nav-number">1.2.2.</span> <span class="nav-text">2. 容器与虚拟机关系</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Docker基本概念"><span class="nav-number">1.3.</span> <span class="nav-text">Docker基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-镜像-Image"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. 镜像(Image)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-容器-Container"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 容器(Container)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-仓库-Repository"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 仓库(Repository)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常见命令"><span class="nav-number">1.4.</span> <span class="nav-text">常见命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-基本命令"><span class="nav-number">1.4.1.</span> <span class="nav-text">1. 基本命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-拉取镜像"><span class="nav-number">1.4.2.</span> <span class="nav-text">2. 拉取镜像</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-删除镜像"><span class="nav-number">1.4.3.</span> <span class="nav-text">3. 删除镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-通过标签删除镜像"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">(1) 通过标签删除镜像</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-通过ID删除镜像"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">(2) 通过ID删除镜像</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-删除镜像的限制"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">(3) 删除镜像的限制</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#4-清理镜像"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">(4) 清理镜像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#镜像操作"><span class="nav-number">1.5.</span> <span class="nav-text">镜像操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-概述"><span class="nav-number">1.5.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-查看镜像详细信息"><span class="nav-number">1.5.2.</span> <span class="nav-text">2. 查看镜像详细信息</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Docker底层原理"><span class="nav-number">1.6.</span> <span class="nav-text">Docker底层原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-基于LXC的虚拟容器技术"><span class="nav-number">1.6.1.</span> <span class="nav-text">1. 基于LXC的虚拟容器技术</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#参考资料"><span class="nav-number">1.7.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yue</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
